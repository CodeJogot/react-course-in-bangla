# Learn ReactJS in 30 Chapters

### After completing this course, we'll build [5 Projects](#) with ReactJS.

While you complete the 30-chapter module, jump in the [Projects Section](#).

|                                                  Chapter                                                  |                                                                                          Topics                                                                                          | Video Explanation |
| :-------------------------------------------------------------------------------------------------------: | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | :---------------: |
|                                                  [00](#)                                                  |                                                                                           []()                                                                                           |   [Watch Now]()   |
|                                 [01](#chapter-01-introduction-to-reactjs)                                 |                                                             [Introduction to React.js](#chapter-01-introduction-to-reactjs)                                                              |   [Watch Now]()   |
|                                 [01.1](#chapter-011-library-vs-framework)                                 |                                                                 [Libray vs Framework](#chapter-011-library-vs-framework)                                                                 |   [Watch Now]()   |
|                               [02](#chapter-02-react-virtual-dom-what--why)                               |                                                         [React Virtual DOM: What & Why](#chapter-02-react-virtual-dom-what--why)                                                         |     Watch Now     |
|              [03](#chapter-03-how-to-install-react-step-by-step-guide-with-example-project)               |                            [How to Install React (Step by Step Guide with Example)](#chapter-03-how-to-install-react-step-by-step-guide-with-example-project)                            |     Watch Now     |
|                               [03.1](#chapter-031-react-install-with-vite)                                |                                                             [React Install with Vite](#chapter-031-react-install-with-vite)                                                              |     Watch Now     |
|                                    [04](#chapter-04-react-render-html)                                    |                                                                    [React Render HTML](#chapter-04-react-render-html)                                                                    |     Watch Now     |
|                                        [05](#chapter-05-react-jsx)                                        |                                                                            [React JSX](#chapter-05-react-jsx)                                                                            |     Watch Now     |
|                                    [06](#chapter-06-react-components)                                     |                                                                     [React Components](#chapter-06-react-components)                                                                     |     Watch Now     |
|                                 [07](#chapter-07-react-class-components)                                  |                                                               [React Class Components](#chapter-07-react-class-components)                                                               |     Watch Now     |
|                        [07.1](#chapter-071-lifecycle-methods-in-class-components)                         |                                                [Lifecyle Methods in Class Components](#chapter-071-lifecycle-methods-in-class-components)                                                |     Watch Now     |
|                              [07.2](#chapter-072-props-in-class-components)                               |                                                           [Props in Class Components](#chapter-072-props-in-class-components)                                                            |     Watch Now     |
|                             [08](#chapter-08-props-in-functional-components)                              |                                                       [Props in Functional Components](#chapter-08-props-in-functional-components)                                                       |     Watch Now     |
|                       [09](#chapter-09-react-state--lifecycle-in-class-components)                        |                                          [React State & Lifecycle in Class Components](#chapter-09-react-state--lifecycle-in-class-components)                                           |     Watch Now     |
|                                                 [09.1](#)                                                 |                                                                        [React State in Functional Components](#)                                                                         |     Watch Now     |
|                                      [10](#chapter-10-react-events)                                       |                                                                         [React Events](#chapter-10-react-events)                                                                         |     Watch Now     |
|                               [11](#chapter-11-react-conditional-rendering)                               |                                                          [React Conditional Rendering](#chapter-11-react-conditional-rendering)                                                          |     Watch Now     |
|                               [11.1](#chapter-111-react-list--keys)                               |                                                          [React List & Keys](#chapter-111-react-list--keys)                                                          |     Watch Now     |
|                               [11.2](#chapter-112--react-form-handling---controlled-vs-uncontrolled-components)                               |                                                          [React Form Handling: Controlled vs Uncontrolled Components](#chapter-112--react-form-handling---controlled-vs-uncontrolled-components)                                                          |     Watch Now     |
|                               [11.3](#chapter-113--react-lifting-state-up)                               |                                                          [React Lifting State Up](#chapter-113--react-lifting-state-up)                                                          |     Watch Now     |
|                                   [12](#chapter-12--react-inheritance)                                    |                                                                   [React Inheritance](#chapter-12--react-inheritance)                                                                    |     Watch Now     |
|                                 [12.1](#chapter-121-react-composition-️)                                  |                                                                  [React Composition](#chapter-121-react-composition-️)                                                                   |     Watch Now     |
| [12.2](#chapter-122--react-inheritance-vs-composition---detailed-example-with-tight-coupling-explanation) | [React Inheritance vs Composition - Detailed Example with Tight Coupling Explanation](#chapter-122--react-inheritance-vs-composition---detailed-example-with-tight-coupling-explanation) |     Watch Now     |
|                            [13](#chapter-13-react-higher-order-components-hoc)                            |                                                   [React Higher Order Components (HOC)](#chapter-13-react-higher-order-components-hoc)                                                   |     Watch Now     |
|                            [13.1](#chapter-131-a-real-world-example-of-hoc)                            |                                                   [A Real-World Example of HOC](#chapter-131-a-real-world-example-of-hoc)                                                   |     Watch Now     |
|                                   [14](#chapter-14-react-render-props)                                    |                                                                   [React Render Props](#chapter-14-react-render-props)                                                                   |     Watch Now     |
|                                    [15](#chapter-15-react-context-api)                                    |                                                                    [React Context API](#chapter-15-react-context-api)                                                                    |     Watch Now     |
|                              [16](#chapter-16-how-to-use-react-context-api)                               |                                                         [How to Use React Context API](#chapter-16-how-to-use-react-context-api)                                                         |     Watch Now     |
|                     [17](#chapter-17-react-context-api-contexttype--usecontext-hook)                      |                                      [React Context API contextType & useContext Hook](#chapter-17-react-context-api-contexttype--usecontext-hook)                                       |     Watch Now     |
|                                       [18](#chapter-18-react-hooks)                                       |                                                                          [React Hooks](#chapter-18-react-hooks)                                                                          |     Watch Now     |
|                         [19](#chapter-19-visualize-and-play-with-css-properties)                          |                                                                  [](#chapter-19-visualize-and-play-with-css-properties)                                                                  |     Watch Now     |
|                                     [20](#chapter-20-css-grid-layout)                                     |                                                                             [](#chapter-20-css-grid-layout)                                                                              |     Watch Now     |
|                                      [21](#chapter-21-css-gradient)                                       |                                                                               [](#chapter-21-css-gradient)                                                                               |     Watch Now     |
|                                [22](#chapter-22-css-2d-and-3d-transforms)                                 |                                                                         [](#chapter-22-css-2d-and-3d-transforms)                                                                         |     Watch Now     |
|                                     [23](#chapter-23-css-animations)                                      |                                                                                           []()                                                                                           |     Watch Now     |
|                                                    24                                                     |                                                                                                                                                                                          |     Watch Now     |
|                                                    25                                                     |                                                                                                                                                                                          |     Watch Now     |
|                                                    26                                                     |                                                                                                                                                                                          |     Watch Now     |
|                                                    27                                                     |                                                                                                                                                                                          |     Watch Now     |
|                                                    28                                                     |                                                                                                                                                                                          |     Watch Now     |
|                                                    29                                                     |                                                                                                                                                                                          |     Watch Now     |
|                                                    30                                                     |                                                                                                                                                                                          |     Watch Now     |

# 5 React.js Projects

|                     Project No.                      |                    Project Name                    | Video Explanation |   Live Demo   |
| :--------------------------------------------------: | :------------------------------------------------: | :---------------: | :-----------: |
|                          01                          |                                                    |     Watch Now     |   Live Demo   |
|  [02](#project-02-simple-website-layout-with-float)  |  [](#project-02-simple-website-layout-with-float)  |     Watch Now     |   Live Demo   |
| [03](#project-03-simple-website-layout-with-flexbox) | [](#project-03-simple-website-layout-with-flexbox) |     Watch Now     |   Live Demo   |
|                          04                          |                                                    |     Watch Now     |   Live Demo   |
|      [05](#project-05-simple-3d-animation-page)      |      [](#project-05-simple-3d-animation-page)      |  [Watch Now](#)   | [Live Demo]() |

# Chapter-00: How The Course is Designed

### কোর্সটি যেভাবে সাজানো হয়েছেঃ

- এই পুরো Article কে একটা বই মনে করতে পারেন। কোর্সটি 30 টি Chapter এ ভাগ করা হয়েছে। প্রতিটি Chapter এ React.js এর বিভিন্ন Topics নিয়ে আলোচনা করা হয়েছে।
- প্রতিটা Chapter এর Module সাজানো হয়েছে ক্রমানুসারে । উদাহরণস্বরূপ, Chapter-05 এর টপিকসগুলো শিখতে হলে অবশ্যই আপনাকে Chapter-04 শেষ করে আসতে হবে। একইভাবে Chapter-04 শিখতে হলে আপনাকে Chapter-03 শেষ করে আসতে হবে ।
- প্রতিটা Chapter এর Topics এর Written Documentation/Explanation এর সাথে সাথে Video Explanation-ও দেয়া আছে। যাতে শিক্ষার্থীরা খুব সহজেই টপিকসগুলো আত্মস্থ করতে পারে।

### কোর্সটি কাদের জন্য?

- এই কোর্সটিতে যেকেউ অংশগ্রহণ করতে পারবে। শিখার জন্য মনের ইচ্ছাটাই আসল!
- Course টি মূলত Beginner-friendly.

### Prerequisite

- Good understanding of HTML, CSS, JavaScript.

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-01: Introduction to React.js

### Table of Contents:

1. [What is React?](#what-is-react)
   - [Single Page Application (SPA) কি?](#single-page-application-spa-কি)
   - [Component-Based Architecture কি?](#component-based-architecture-কি)
2. [Why Use React?](#why-use-react)
   - [Efficient UI Updates](#efficient-ui-updates)
   - [Example of Efficient UI Updates](#example-of-efficient-ui-updates)
3. [Problems Without React](#problems-without-react)
   - [Manual DOM Manipulation এর জটিলতা](#manual-dom-manipulation-জটিলতা)
   - [Poor Code Reusability](#poor-code-reusability)
   - [Complex State Management](#complex-state-management)
4. [Conclusion](#conclusion)

---

### 1. What is React?

**ReactJS** হলো একটি **JavaScript library** যা user interfaces (UI) তৈরি করতে ব্যবহৃত হয়। এটি মূলত **Single Page Applications (SPA)** এর জন্য ব্যবহৃত হয়, যেখানে web page এর বিভিন্ন অংশ dynamically update হয়, কিন্তু পুরো page reload হয় না। React প্রথমে **Facebook** দ্বারা ২০১৩ সালে তৈরি করা হয় এবং এখন এটি modern web development এর অন্যতম জনপ্রিয় library হিসেবে বিবেচিত হয়।

#### Example of a Simple React Component:

```jsx
function Welcome() {
  return <h1>Hello, React!</h1>;
}

export default Welcome;
```

React এর প্রধান বৈশিষ্ট্য হলো **Component-based Architecture**, যেখানে UI কে ছোট ছোট, পুনরায় ব্যবহারযোগ্য অংশে ভাগ করা যায়।

---

### 1.1 Single Page Application (SPA) কি?

**Single Page Application (SPA)** হলো একটি ধরনের web application, যেখানে একটি page load হওয়ার পর user এর interaction অনুযায়ী page এর বিভিন্ন অংশ dynamically update হয়, কিন্তু পুরো page reload হয় না। Traditional multi-page applications এ প্রতিবার কোনো page পরিবর্তন করার জন্য server থেকে নতুন HTML file fetch করতে হয়, কিন্তু SPA তে এটি প্রয়োজন হয় না। React মূলত SPA তৈরি করার জন্য ব্যবহৃত হয়, যা web applications কে দ্রুততর এবং seamless করে তোলে।

#### Example:

ধরুন, আপনি একটি Traditional web application ব্যবহার করছেন, যেখানে প্রতিবার আপনি কোনো নতুন section এ যান, তখন নতুন একটি HTML পেজ লোড হয় এবং পুরো পেজ রিলোড হয়। কিন্তু **React** ব্যবহার করলে, page এর নির্দিষ্ট অংশ dynamically update হয়, যা user experience কে দ্রুত এবং responsive করে তোলে।

---

### 1.2 Component-Based Architecture কি?

React এর সবচেয়ে শক্তিশালী বৈশিষ্ট্য হলো এর **component-based architecture**। এর মাধ্যমে পুরো UI কে ছোট ছোট পুনঃব্যবহারযোগ্য অংশে ভাগ করা যায়, যাকে **components** বলে। প্রতিটি component একটি নির্দিষ্ট কাজ সম্পন্ন করে এবং UI এর বিভিন্ন অংশের জন্য আলাদা আলাদা component তৈরি করা যায়।

#### Example:

```jsx
function Navbar() {
  return (
    <nav>
      <ul>
        <li>Home</li>
        <li>About</li>
        <li>Contact</li>
      </ul>
    </nav>
  );
}
```

এখানে একটি **Navbar** component তৈরি করা হয়েছে। এখন আপনি Navbar component কে যেকোনো page এ পুনরায় ব্যবহার করতে পারবেন, এবং যদি কোনো পরিবর্তন প্রয়োজন হয়, তবে component এ পরিবর্তন করে সমস্ত জায়গায় একই পরিবর্তন reflect হবে। এটি development process কে দ্রুত এবং maintainable করে।

---

### 2. Why Use React?

React এর কিছু গুরুত্বপূর্ণ সুবিধা হলো:

1. **Efficient UI Updates**:
   - React এর মাধ্যমে user interaction এর উপর ভিত্তি করে page এর নির্দিষ্ট অংশ update করা যায়। React এর **Virtual DOM** feature এর কারণে এটি খুব দ্রুত এবং efficient ভাবে কাজ করে।

#### Example of Efficient UI Updates with Virtual DOM:

```jsx
import React, { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

উপরের উদাহরণে, **count** state প্রতিবার increment হচ্ছে যখন user **button** এ click করছে। React এর **Virtual DOM** এর মাধ্যমে শুধুমাত্র **count** এর অংশটি রি-রেন্ডার হচ্ছে। DOM এর অন্য কোনো অংশ পরিবর্তন হচ্ছে না, যার ফলে UI দ্রুত এবং efficient ভাবে update হচ্ছে।

#### Example Without Virtual DOM:

ধরা যাক, আমরা traditional JavaScript দিয়ে এটি করতে চাই:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Counter Example</title>
    <script>
      function increment() {
        var count = document.getElementById("count");
        count.innerHTML = parseInt(count.innerHTML) + 1;
      }
    </script>
  </head>
  <body>
    <h1>Count: <span id="count">0</span></h1>
    <button onclick="increment()">Increment</button>
  </body>
</html>
```

এখানে প্রতিবার **button** এ click করলে আমরা manual DOM manipulation করছি। JavaScript সরাসরি DOM এর সাথে কাজ করছে, যা বড় application এ performance সমস্যার সৃষ্টি করে। React এর মতো **Virtual DOM** না থাকায় প্রতিবার DOM পরিবর্তনের জন্য browser কে পুরো structure রি-রেন্ডার করতে হয়। এছাড়া DOM এর direct manipulation সময়সাপেক্ষ এবং memory-heavy হয়ে যায়।

#### Why React’s Approach is Better:

- **Performance**: React এর **Virtual DOM** শুধুমাত্র প্রয়োজনীয় অংশটুকু update করে, যেখানে traditional approach এ পুরো DOM structure কে পরিবর্তন করতে হয়।
- **Maintainability**: React এর **declarative syntax** এবং automatic DOM update এর কারণে complex UI গুলোও সহজে manage করা যায়।

---

### 3. Problems Without React

React ছাড়া modern web applications তৈরি করতে traditional DOM manipulation পদ্ধতি ব্যবহার করতে হয়, যা বড় বড় applications এর জন্য অনেক সমস্যা তৈরি করতে পারে।

#### 1) Manual DOM Manipulation এর জটিলতা

Traditional JavaScript দিয়ে DOM এর elements manually manipulate করতে গেলে আপনাকে প্রতিটি element এর জন্য DOM API (`getElementById`, `querySelector`) ব্যবহার করতে হয়, এবং প্রতিবার page এ কোনো পরিবর্তন আনতে হলে নতুন করে পুরো DOM এর সাথে interaction করতে হয়। এর ফলে UI complex হয়ে গেলে কোড অনেক বেশি জটিল এবং দুর্বল হয়ে পড়ে।

#### Example Without React (Dynamic List):

ধরুন, আপনি একটি **To-Do List** তৈরি করতে চান যেখানে user নতুন নতুন items যোগ করতে পারে:

```html
<!DOCTYPE html>
<html>
  <head>
    <script>
      function addItem() {
        const list = document.getElementById("list");
        const newItem = document.createElement("li");
        const inputValue = document.getElementById("input").value;
        newItem.textContent = inputValue;
        list.appendChild(newItem);
        document.getElementById("input").value = "";
      }
    </script>
  </head>
  <body>
    <h1>To-Do List</h1>
    <input type="text" id="input" placeholder="Enter new item" />
    <button onclick="addItem()">Add</button>
    <ul id="list"></ul>
  </body>
</html>
```

এখানে প্রতিবার user নতুন item যোগ করলে list এ একটি নতুন **`<li>`** element যোগ করতে হচ্ছে। JavaScript এর মাধ্যমে আমরা DOM এ সরাসরি manipulate করছি, যা বড় বা complex lists এর জন্য খুবই জটিল হয়ে পড়ে এবং performance সমস্যা তৈরি করতে পারে।

#### 2) Poor Code Reusability

Traditional JavaScript কোড reusability এর ক্ষেত্রে দুর্বল। যদি একই ধরনের UI element বারবার তৈরি করতে হয়, আপনাকে বারবার কোড লিখতে হবে, যা redundancy সৃষ্টি করে এবং bugs এর সম্ভাবনা বাড়ায়।

#### Example Without React (Navbar):

```html
<nav>
  <ul>
    <li>Home</li>
    <li>About</li>
    <li>Contact</li>
  </ul>
</nav>
```

এখানে আমরা একটি simple **Navbar** তৈরি করেছি। এখন যদি আরেকটি similar navbar তৈরি করতে হয়, তবে আপনাকে একই কোড আবার লিখতে হবে। Traditional JavaScript এ আপনি component-based architecture ব্যবহার করতে পারবেন না, যার ফলে UI element গুলোকে পুনরায় ব্যবহার করতে সমস্যা হয়।

#### 3) Complex State Management

Traditional JavaScript এ **state management** খুবই জটিল। যদি page এর বিভিন্ন element এর উপর ভিত্তি করে UI update করতে হয়, তবে আপনাকে বিভিন্ন DOM element এর সাথে synchronize করতে হবে। এটি বড় application এর ক্ষেত্রে অনেক জটিল হয়ে পড়ে।

#### Example (Without React State):

```html
<input type="text" id="name" placeholder="Enter your name" />
<button onclick="updateGreeting()">Greet</button>
<h1 id="greeting">Hello,</h1>

<script>
  function updateGreeting() {
    const name = document.getElementById("name").value;
    document.getElementById("greeting").innerHTML = "Hello, " + name;
  }
</script>
```

---

#### Solution with React:

React এর **state management** feature আপনাকে সহজে component এর state handle করতে দেয়, এবং UI এর পরিবর্তন স্বয়ংক্রিয়ভাবে synchronize হয়:

```jsx
import React, { useState } from "react";

function Greeting() {
  const [name, setName] = useState("");

  return (
    <div>
      <input
        type="text"
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Enter your name"
      />
      <h1>Hello, {name}!</h1>
    </div>
  );
}

export default Greeting;
```

এই উদাহরণে, user input অনুযায়ী greeting dynamically update হচ্ছে, এবং React এর **state** পরিবর্তন অনুযায়ী UI render হচ্ছে। JavaScript এর সরাসরি DOM manipulation এর প্রয়োজন নেই।

---

### 4. Conclusion

React একটি declarative, efficient, এবং flexible JavaScript library, যা modern web development এর জন্য অত্যন্ত উপযোগী। এটি UI development কে সহজতর করে, বিশেষত complex applications এর জন্য যেখানে dynamic content management প্রয়োজন।

React এর সবচেয়ে বড় সুবিধা হলো **component-based architecture** এবং **Virtual DOM**, যা UI management এবং performance সমস্যাগুলোকে অনেক সহজ করে তোলে। Traditional JavaScript এর তুলনায় React development আরও maintainable এবং reusable করে তোলে, যা large-scale applications এর জন্য বিশেষভাবে গুরুত্বপূর্ণ।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-01.1: Library vs Framework

### Table of Contents:

1. [What is a Library?](#what-is-a-library)
2. [What is a Framework?](#what-is-a-framework)
3. [Key Differences Between Library and Framework](#key-differences-between-library-and-framework)
4. [Examples of Popular Libraries and Frameworks](#examples-of-popular-libraries-and-frameworks)
5. [When to Use a Library vs. a Framework](#when-to-use-a-library-vs-a-framework)
6. [Conclusion](#conclusion)

---

### 1. What is a Library?

**Library** হলো এমন একটি code collection বা package, যা নির্দিষ্ট কাজ বা functionalities সম্পন্ন করার জন্য ব্যবহৃত হয়। এটি সাধারণত pre-written functions বা methods এর একটি সমাহার, যা developer দের একটি নির্দিষ্ট কাজ সহজে সম্পন্ন করতে সাহায্য করে। Library ব্যবহার করলে developer দের প্রয়োজনীয় function বা method call করে ব্যবহার করতে হয়, অর্থাৎ developer ই decide করে, কখন, কিভাবে, এবং কোথায় সেই code ব্যবহার হবে।

##### উদাহরণ:

JavaScript এর **React** একটি library, যা user interface তৈরি করতে ব্যবহৃত হয়। React developer দের components তৈরি এবং তাদের মধ্যে data pass করার জন্য functions এবং methods প্রদান করে, কিন্তু পুরো application structure বা control developer এর উপর থাকে।

---

### 2. What is a Framework?

**Framework** হলো একটি complete structure বা architecture, যা পুরো application এর জন্য একটি নির্দিষ্ট guideline এবং control প্রদান করে। Framework ব্যবহার করলে, developer দের নির্দিষ্ট rules এবং conventions অনুযায়ী code লিখতে হয়। এটি একটি predefined code structure প্রদান করে এবং application এর control অনেকাংশে framework এর উপর থাকে, যেখানে developer নির্দিষ্ট parts এ code লিখতে পারেন।

##### উদাহরণ:

JavaScript এর **Angular** একটি framework, যা একটি complete structure বা architecture প্রদান করে। Angular application তৈরি করার সময় developer দের Angular এর বিভিন্ন services, components, এবং modules ব্যবহার করতে হয়, এবং Angular application এর flow এবং lifecycle manage করে।

---

### 3. Key Differences Between Library and Framework

| **Aspect**      | **Library**                                              | **Framework**                                          |
| --------------- | -------------------------------------------------------- | ------------------------------------------------------ |
| **Control**     | Developer control করে কিভাবে এবং কোথায় code ব্যবহার হবে | Framework control করে application structure এবং flow   |
| **Flexibility** | Developer এর হাতে বেশি flexibility থাকে                  | Framework এর নির্দিষ্ট guideline অনুযায়ী কাজ করতে হয় |
| **Usage**       | নির্দিষ্ট কাজ সম্পন্ন করার জন্য library import করা হয়   | Framework application এর পুরো structure তৈরি করে       |
| **Examples**    | React, Lodash, jQuery                                    | Angular, Vue.js, Django                                |

#### Explanation:

- **Control**: Library ব্যবহার করলে developer control করে কিভাবে function call করা হবে। Framework এ control অনেকাংশে framework নিজেই করে, developer framework এর নির্দিষ্ট rules অনুযায়ী code লিখেন।
- **Flexibility**: Library এর ক্ষেত্রে developer ই নির্ধারণ করেন কিভাবে এবং কখন library এর code ব্যবহার করা হবে। Framework এর ক্ষেত্রে developer framework এর নির্দিষ্ট structure এবং guideline অনুসরণ করে code লিখেন।
- **Usage**: Library সাধারণত ছোট কাজগুলো (যেমন: data manipulation, DOM manipulation) সহজ করতে ব্যবহৃত হয়। Framework একটি পূর্ণাঙ্গ application তৈরি করার জন্য ব্যবহৃত হয়, যেখানে পুরো application structure predefined থাকে।

---

### 4. Examples of Popular Libraries and Frameworks

#### Libraries:

1. **React** (JavaScript)
2. **Lodash** (JavaScript)
3. **jQuery** (JavaScript)
4. **NumPy** (Python)
5. **Pandas** (Python)

#### Frameworks:

1. **Angular** (JavaScript)
2. **Vue.js** (JavaScript)
3. **Django** (Python)
4. **Laravel** (PHP)
5. **Spring** (Java)

React এর মতো library developer দের UI components তৈরির flexibility প্রদান করে, যেখানে Angular এর মতো framework একটি পূর্ণাঙ্গ structure এবং control প্রদান করে।

---

### 5. When to Use a Library vs. a Framework

#### When to Use a Library:

- যদি আপনার application এর একটি নির্দিষ্ট part এর জন্য code reusability এবং flexibility দরকার হয়।
- যখন আপনি কিছু specific functionality যেমন DOM manipulation (jQuery) বা data manipulation (Lodash, Pandas) করতে চান।
- যখন আপনি পুরো application structure নিজের মতো করে তৈরি করতে চান এবং তার উপর control রাখতে চান।

#### When to Use a Framework:

- যদি আপনি একটি complete application তৈরি করতে চান এবং predefined structure এবং architecture ব্যবহার করতে চান।
- যখন আপনি code organization এবং application structure নিয়ে সময় বাঁচাতে চান।
- যখন একটি large-scale application তৈরি করতে হবে এবং একটি scalable structure দরকার।

---

### 6. Conclusion

**Library** এবং **Framework** উভয়ই software development এর জন্য গুরুত্বপূর্ণ tools, তবে এদের কাজ এবং control এর ধরণ ভিন্ন।

- **Library** developer কে নির্দিষ্ট কাজ সম্পন্ন করার জন্য flexibility দেয় এবং developer control করে কিভাবে এবং কখন সেই library ব্যবহার হবে।
- **Framework** একটি পূর্ণাঙ্গ architecture বা structure প্রদান করে এবং developer কে সেই structure অনুযায়ী কাজ করতে হয়। Framework অনেক ক্ষেত্রে control ধরে রাখে এবং application এর flow manage করে।

React এর মতো libraries ছোট ছোট components তৈরি করতে সাহায্য করে, যেখানে Angular এর মতো frameworks পুরো application structure নির্ধারণ করে দেয়। আপনার application এর nature এবং requirement এর উপর ভিত্তি করে library বা framework বেছে নেওয়া উচিত।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-02: React Virtual DOM: What & Why

## সূচিপত্র
1. [শুরুর আগে - একটি গল্প](#শুরুর-আগে---একটি-গল্প)
2. [DOM কি? - মূল বিষয়টা বুঝি](#dom-কি---মূল-বিষয়টা-বুঝি)
3. [Real DOM এর সমস্যা কি?](#real-dom-এর-সমস্যা-কি)
4. [Virtual DOM কি? - সহজ ভাষায়](#virtual-dom-কি---সহজ-ভাষায়)
5. [Virtual DOM কিভাবে কাজ করে? - Step by Step](#virtual-dom-কিভাবে-কাজ-করে---step-by-step)
6. [একটি সম্পূর্ণ উদাহরণ দিয়ে বুঝি](#একটি-সম্পূর্ণ-উদাহরণ-দিয়ে-বুঝি)
7. [আরো সহজ উদাহরণ](#আরো-সহজ-উদাহরণ)
8. [কেন Virtual DOM দরকার?](#কেন-virtual-dom-দরকার)
9. [সচরাচর জিজ্ঞাসা](#সচরাচর-জিজ্ঞাসা)

---

## শুরুর আগে - একটি গল্প

মনে করুন আপনি একটি বইয়ের পাতায় কিছু লিখেছেন। এখন আপনার একটি শব্দ পরিবর্তন করতে হবে। 

**সাধারণ উপায়ে:** পুরো পাতাটা মুছে আবার নতুন করে সব কিছু লিখতে হবে। এটা অনেক সময় নেয় এবং কষ্টকর।

**স্মার্ট উপায়ে:** প্রথমে একটা draft পাতায় সব কিছু লিখে নিন। তারপর original পাতার সাথে compare করে দেখুন কি পরিবর্তন হয়েছে। শুধুমাত্র সেই পরিবর্তিত অংশটুকু original পাতায় update করুন।

Virtual DOM ঠিক এই স্মার্ট উপায়ের মতো কাজ করে!

---

## DOM কি? - মূল বিষয়টা বুঝি

### সহজ ভাষায় DOM
DOM মানে Document Object Model। এটা হল browser এ আপনার webpage টা কিভাবে তৈরি এবং organize হয়েছে তার একটা structure।

```html
<!-- আপনার HTML -->
<html>
  <body>
    <div>
      <h1>আমার ওয়েবসাইট</h1>
      <p>এটি একটি paragraph</p>
      <button>Click Me</button>
    </div>
  </body>
</html>
```

Browser এই HTML কে একটা tree structure এ convert করে:

```
html
  └── body
      └── div
          ├── h1 ("আমার ওয়েবসাইট")
          ├── p ("এটি একটি paragraph")  
          └── button ("Click Me")
```

এই tree structure টাই হল DOM।

### DOM এর বৈশিষ্ট্য
- Browser এ যা দেখেন, সেটাই DOM
- JavaScript দিয়ে DOM change করা যায়
- DOM change হলে webpage এ তৎক্ষণাত পরিবর্তন দেখা যায়

---

## Real DOM এর সমস্যা কি?

### সমস্যা ১: অনেক ধীর (Slow)
```javascript
// ধরুন আপনার 100টা list item আছে
const list = document.getElementById('myList');

// এক এক করে 100টা item change করতে হলে
for(let i = 0; i < 100; i++) {
  list.children[i].innerHTML = `Item ${i} - Updated`;
  // প্রতিবার browser পুরো page re-calculate করে!
}
```

**কি হচ্ছে এখানে?**
- প্রতিবার change এ browser পুরো page আবার calculate করে
- Layout পুনরায় তৈরি হয় (Reflow)
- Elements আবার paint হয় (Repaint)
- এই process 100 বার repeat হয়!

### সমস্যা ২: অপ্রয়োজনীয় Update
```javascript
// ধরুন আপনি একটা shopping cart আপডেট করছেন
function updateCart() {
  // Total amount পরিবর্তন হয়েছে
  document.getElementById('total').innerHTML = '৫০০ টাকা';
  
  // কিন্তু browser পুরো page check করে
  // যদিও শুধু একটা element পরিবর্তন হয়েছে
}
```

### সমস্যা ৩: Memory এর অপব্যবহার
Real DOM elements অনেক memory নেয় কারণ তাদের অনেক properties আছে।

---

## Virtual DOM কি? - সহজ ভাষায়

### মূল ধারণা
Virtual DOM হল Real DOM এর একটা **copy** যা JavaScript object হিসেবে computer এর memory তে থাকে। এটা browser এ দেখা যায় না, শুধু memory তে থাকে।

### সহজ তুলনা
```javascript
// Real DOM (Browser এ যেটা দেখেন)
<div>
  <h1>Hello World</h1>
  <button>Click</button>
</div>

// Virtual DOM (Memory তে JavaScript object হিসেবে)
{
  tag: 'div',
  children: [
    {
      tag: 'h1',
      text: 'Hello World'
    },
    {
      tag: 'button',
      text: 'Click'
    }
  ]
}
```

### Virtual DOM এর বৈশিষ্ট্য
- এটা JavaScript object
- Browser এ দেখা যায় না
- Memory তে থাকে
- অনেক দ্রুত create এবং modify করা যায়
- Real DOM এর exact copy

---

## Virtual DOM কিভাবে কাজ করে? - Step by Step

এখন সবচেয়ে গুরুত্বপূর্ণ অংশ - Virtual DOM কিভাবে কাজ করে তা step by step বুঝবো।

### Step 1: প্রথম রেন্ডার (Initial Render)

**আপনার React Component:**
```javascript
function MyComponent() {
  const [name, setName] = useState('রহিম');
  
  return (
    <div>
      <h1>নাম: {name}</h1>
      <button onClick={() => setName('করিম')}>
        নাম পরিবর্তন করুন
      </button>
    </div>
  );
}
```

**কি হয়:**

1️⃣ **React Virtual DOM tree তৈরি করে:**
```javascript
// Virtual DOM Tree (Memory তে)
{
  type: 'div',
  children: [
    {
      type: 'h1',
      text: 'নাম: রহিম'
    },
    {
      type: 'button',
      text: 'নাম পরিবর্তন করুন',
      onClick: [Function]
    }
  ]
}
```

2️⃣ **React এই Virtual DOM থেকে Real DOM তৈরি করে:**
```html
<!-- Browser এ যেটা দেখবেন -->
<div>
  <h1>নাম: রহিম</h1>
  <button>নাম পরিবর্তন করুন</button>
</div>
```

### Step 2: State Change হওয়া

**User button এ click করলে:**

1️⃣ **setName('করিম') call হয়**

2️⃣ **React বুঝে যায় state পরিবর্তন হয়েছে**

3️⃣ **React component function আবার call করে**

### Step 3: নতুন Virtual DOM তৈরি

**React নতুন Virtual DOM tree তৈরি করে:**
```javascript
// নতুন Virtual DOM Tree (Memory তে)
{
  type: 'div',
  children: [
    {
      type: 'h1',
      text: 'নাম: করিম'  // এখানে পরিবর্তন হয়েছে!
    },
    {
      type: 'button',
      text: 'নাম পরিবর্তন করুন',
      onClick: [Function]
    }
  ]
}
```

### Step 4: তুলনা করা (Diffing)

**React এখন দুইটা Virtual DOM tree তুলনা করে:**

```javascript
// পুরাতন Tree
{
  type: 'div',
  children: [
    {
      type: 'h1',
      text: 'নাম: রহিম'     // পুরাতন value
    },
    // ... বাকি সব same
  ]
}

// নতুন Tree  
{
  type: 'div',
  children: [
    {
      type: 'h1',
      text: 'নাম: করিম'     // নতুন value
    },
    // ... বাকি সব same
  ]
}
```

**React খুঁজে পায়:**
- `div` element same আছে ✓
- `button` element same আছে ✓  
- শুধু `h1` এর text পরিবর্তন হয়েছে ⚡

### Step 5: Real DOM Update করা (Reconciliation)

**React শুধুমাত্র পরিবর্তিত অংশ Real DOM এ update করে:**

```javascript
// React শুধু এই একটা line execute করে
document.querySelector('h1').textContent = 'নাম: করিম';

// সম্পূর্ণ page বা component আবার তৈরি করে না!
```

**Result:** Browser এ দেখবেন শুধু h1 এর text 'রহিম' থেকে 'করিম' হয়ে গেছে।

---

## একটি সম্পূর্ণ উদাহরণ দিয়ে বুঝি

চলুন একটা shopping cart এর example দিয়ে পুরো process টা দেখি:

### Initial State
```javascript
function ShoppingCart() {
  const [items, setItems] = useState([
    { id: 1, name: 'আম', price: 100, quantity: 2 },
    { id: 2, name: 'কলা', price: 50, quantity: 5 }
  ]);
  
  const total = items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
  
  return (
    <div>
      <h1>Shopping Cart</h1>
      <ul>
        {items.map(item => (
          <li key={item.id}>
            {item.name} - {item.price}৳ x {item.quantity} = {item.price * item.quantity}৳
          </li>
        ))}
      </ul>
      <h2>Total: {total}৳</h2>
    </div>
  );
}
```

### Step 1: প্রথম Virtual DOM
```javascript
// Memory তে Virtual DOM Tree
{
  type: 'div',
  children: [
    { type: 'h1', text: 'Shopping Cart' },
    {
      type: 'ul',
      children: [
        { type: 'li', text: 'আম - 100৳ x 2 = 200৳' },
        { type: 'li', text: 'কলা - 50৳ x 5 = 250৳' }
      ]
    },
    { type: 'h2', text: 'Total: 450৳' }
  ]
}
```

### Step 2: User আমের quantity বাড়ালো (2 থেকে 3)
```javascript
// State update
setItems(prevItems => 
  prevItems.map(item => 
    item.id === 1 ? { ...item, quantity: 3 } : item
  )
);
```

### Step 3: নতুন Virtual DOM
```javascript
// নতুন Virtual DOM Tree
{
  type: 'div',
  children: [
    { type: 'h1', text: 'Shopping Cart' },        // Same ✓
    {
      type: 'ul',
      children: [
        { type: 'li', text: 'আম - 100৳ x 3 = 300৳' }, // Changed ⚡
        { type: 'li', text: 'কলা - 50৳ x 5 = 250৳' }   // Same ✓
      ]
    },
    { type: 'h2', text: 'Total: 550৳' }           // Changed ⚡
  ]
}
```

### Step 4: React যা খুঁজে পেল
- `h1` → কোন পরিবর্তন নেই
- প্রথম `li` → text পরিবর্তন হয়েছে
- দ্বিতীয় `li` → কোন পরিবর্তন নেই  
- `h2` → text পরিবর্তন হয়েছে

### Step 5: Real DOM এ শুধু 2টা update
```javascript
// React শুধু এই 2টা operation করবে
document.querySelector('li:first-child').textContent = 'আম - 100৳ x 3 = 300৳';
document.querySelector('h2').textContent = 'Total: 550৳';
```

**ফলাফল:** পুরো page reload বা re-render না করে শুধু 2টা text update হল!

---

## আরো সহজ উদাহরণ

### Example 1: Simple Counter

```javascript
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
      <button onClick={() => setCount(count - 1)}>-</button>
    </div>
  );
}
```

**কি হয় button click এ:**

1. **State change:** `count` 0 থেকে 1 হয়
2. **Virtual DOM comparison:**
   - `div` → same
   - `p` text → "Count: 0" থেকে "Count: 1" 
   - দুইটা `button` → same
3. **Real DOM update:** শুধু `p` element এর text update

**Traditional way তে কি হতো:**
```javascript
// পুরো component আবার তৈরি হতো
document.innerHTML = `
  <div>
    <p>Count: 1</p>
    <button>+</button>  
    <button>-</button>
  </div>
`;
```

### Example 2: Show/Hide Content

```javascript
function App() {
  const [showContent, setShowContent] = useState(false);
  
  return (
    <div>
      <button onClick={() => setShowContent(!showContent)}>
        {showContent ? 'Hide' : 'Show'} Content
      </button>
      {showContent && <p>This is hidden content!</p>}
    </div>
  );
}
```

**Show button click করলে:**

**Virtual DOM changes:**
```javascript
// Before
{
  type: 'div',
  children: [
    { type: 'button', text: 'Show Content' }
    // p element নেই
  ]
}

// After  
{
  type: 'div',
  children: [
    { type: 'button', text: 'Hide Content' },  // text changed
    { type: 'p', text: 'This is hidden content!' }  // new element
  ]
}
```

**Real DOM updates:**
1. Button text update: "Show" → "Hide"
2. New p element add

---

## কেন Virtual DOM দরকার?

### 1. গতি (Performance)

**Virtual DOM ছাড়া:**
```javascript
// প্রতি update এ
document.getElementById('item1').innerHTML = 'New text 1';  // Browser recalculate
document.getElementById('item2').innerHTML = 'New text 2';  // Browser recalculate  
document.getElementById('item3').innerHTML = 'New text 3';  // Browser recalculate
// 3 বার browser calculation!
```

**Virtual DOM এর সাথে:**
```javascript
// React একসাথে সব changes batch করে
// একবারেই সব DOM updates করে
// 1 বার browser calculation!
```

### 2. সহজতা (Simplicity)

**Traditional JavaScript:**
```javascript
function updateUI() {
  // ম্যানুয়াল DOM manipulation
  const nameEl = document.getElementById('name');
  const emailEl = document.getElementById('email');
  
  if (user.name) {
    nameEl.style.display = 'block';
    nameEl.textContent = user.name;
  } else {
    nameEl.style.display = 'none';
  }
  
  // ... আরো অনেক manual work
}
```

**React এর সাথে:**
```javascript
function UserProfile({ user }) {
  return (
    <div>
      {user.name && <p>{user.name}</p>}
      {user.email && <p>{user.email}</p>}
    </div>
  );
}
// React automatically সব DOM updates handle করে!
```

### 3. Predictability (পূর্বাভাস)

Virtual DOM ensure করে যে:
- Same state = Same UI
- কোন unexpected DOM changes নেই
- UI bugs কম হয়

---

## সচরাচর জিজ্ঞাসা

### প্রশ্ন ১: Virtual DOM কি Real DOM থেকে সবসময় দ্রুত?

**উত্তর:** না! Simple applications এ Virtual DOM একটু slow হতে পারে। কিন্তু complex applications এ এটা অনেক fast।

**কেন?**
- Simple app: Virtual DOM extra step add করে
- Complex app: Virtual DOM অনেক unnecessary updates prevent করে

### প্রশ্ন ২: Virtual DOM memory বেশি নেয় না?

**উত্তর:** হ্যাঁ, কিছুটা memory বেশি নেয়। কিন্তু benefits এর তুলনায় এটা নগণ্য।

**বিবেচনা:**
- Virtual DOM: Lightweight JavaScript objects
- Real DOM: Heavy browser objects  
- Trade-off: একটু বেশি memory vs অনেক ভালো performance

### প্রশ্ন ৩: Virtual DOM ছাড়া React কাজ করে না?

**উত্তর:** React Virtual DOM এর উপর ভিত্তি করে তৈরি। Virtual DOM ছাড়া React হবে না।

### প্রশ্ন ৪: অন্য library গুলোতে Virtual DOM আছে?

**উত্তর:** হ্যাঁ! Vue.js, Preact সহ অনেক modern library তে Virtual DOM আছে।

### প্রশ্ন ৫: আমি কি Virtual DOM manually তৈরি করতে পারি?

**উত্তর:** হ্যাঁ, পারবেন! তবে এটা অনেক complex। React already optimized Virtual DOM provide করে।

**Simple example:**
```javascript
// Manual Virtual DOM (educational purpose)
function createElement(tag, props, ...children) {
  return { tag, props, children };
}

// Usage
const virtualElement = createElement('div', null,
  createElement('h1', null, 'Hello'),
  createElement('p', null, 'World')
);
```

---

## শেষ কথা

Virtual DOM একটি brilliant concept যা modern web development এ revolution এনেছে। 

**মূল বিষয়গুলো মনে রাখুন:**

1. **Virtual DOM = Real DOM এর JavaScript copy**
2. **কাজের ধাপ:**
   - State change হয়
   - নতুন Virtual DOM তৈরি হয়  
   - পুরাতনের সাথে compare হয়
   - শুধু changes Real DOM এ update হয়

3. **সুবিধা:**
   - দ্রুত performance
   - সহজ development  
   - কম bugs

4. **কখন উপকারী:**
   - Complex applications  
   - Frequent UI updates
   - Large component trees


<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-03: How to Install React (Step-by-Step Guide with Example Project)

### Table of Contents:

1. [Prerequisites](#prerequisites)
2. [Installing Node.js and npm](#installing-nodejs-and-npm)
3. [Creating a New React Project](#creating-a-new-react-project)
   - [Using Create React App (CRA)](#using-create-react-app)
   - [Folder Structure Overview with Real-life Example](#folder-structure-overview-with-real-life-example)
4. [package.json Explained](#packagejson-explained)
5. [Example Project: Simple To-Do List](#example-project-simple-to-do-list)
   - [Step 1: Setting Up the Project](#step-1-setting-up-the-project)
   - [Step 2: Creating the To-Do List Component](#step-2-creating-the-to-do-list-component)
   - [Step 3: Adding Interactivity](#step-3-adding-interactivity)
   - [Step 4: Running and Testing](#step-4-running-and-testing)
6. [Running the React Project](#running-the-react-project)
7. [Conclusion](#conclusion)

---

### 1. Prerequisites

React ইনস্টল করার আগে, আপনার সিস্টেমে **Node.js** এবং **npm** থাকতে হবে। এগুলো React এবং অন্যান্য JavaScript libraries পরিচালনার জন্য প্রয়োজনীয়। যদি Node.js এবং npm ইন্সটল করা না থাকে, তাহলে [Node.js অফিসিয়াল ওয়েবসাইট](https://nodejs.org/en/) থেকে ডাউনলোড করে ইনস্টল করুন।

---

### 2. Installing Node.js and npm

#### Step 1: Download Node.js

- [Node.js এর অফিসিয়াল ওয়েবসাইট](https://nodejs.org/en/) থেকে **LTS (Long-Term Support)** version ডাউনলোড করুন।
- ইনস্টল করার পর, Terminal বা Command Prompt খুলে নিচের কমান্ডগুলো দিয়ে যাচাই করুন:

```bash
node -v
npm -v
```

---

### 3. Creating a New React Project

React এর নতুন প্রজেক্ট তৈরি করতে **Create React App (CRA)** খুবই উপযোগী। এটি খুব সহজে একটি React প্রজেক্ট সেটআপ করতে সাহায্য করে।

#### Using Create React App (CRA)

**Step 1: Create React App ব্যবহার করে প্রজেক্ট তৈরি করা**

Terminal/Command Prompt এ নিচের কমান্ড লিখুন:

```bash
npx create-react-app my-app
```

এখানে **my-app** হলো আপনার প্রজেক্টের নাম। এটি ইনস্টল করে সমস্ত প্রয়োজনীয় dependencies যুক্ত করে।

**Step 2: Project ফোল্ডারে প্রবেশ করা**

```bash
cd my-app
```

---

### Folder Structure Overview with Real-life Example

React প্রজেক্ট তৈরি হলে নিচের মতো ফোল্ডার স্ট্রাকচার পাবেন:

#### Example of Folder Structure:

```
my-app/
├── node_modules/
├── public/
│   ├── index.html
│   └── favicon.ico
├── src/
│   ├── App.js
│   ├── App.css
│   ├── index.js
│   └── index.css
├── package.json
└── README.md
```

#### Folder Breakdown:

1. **node_modules/**: এখানে সমস্ত dependencies থাকে।
2. **public/**: public ফোল্ডারে **index.html** থাকে, যা ব্রাউজারে React app প্রদর্শন করে।
3. **src/**: এই ফোল্ডারে React এর মূল কোড থাকে (App.js, index.js, ইত্যাদি)।
4. **package.json**: প্রজেক্টের dependencies এবং scripts এখানে থাকে।

---

### 4. package.json Explained

**package.json** ফাইলটি আপনার প্রজেক্টের জন্য অত্যন্ত গুরুত্বপূর্ণ, যেখানে সমস্ত configuration এবং dependencies তালিকাভুক্ত থাকে।

#### Key Sections in package.json:

```json
{
  "name": "my-app",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "react-scripts": "5.0.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  }
}
```

- **dependencies**: আপনার প্রজেক্টে ইনস্টল হওয়া libraries।
- **scripts**: প্রজেক্ট চালানোর জন্য প্রয়োজনীয় স্ক্রিপ্ট, যেমন:
  - **npm start**: development server চালু করে।
  - **npm run build**: production build তৈরি করে।
  - **npm test**: testing চালায়।

---

### 5. Example Project: Simple To-Do List

এই অংশে আমরা একটি বাস্তব উদাহরণ দেব—**Simple To-Do List**। এটি খুবই সহজ, কিন্তু React এর ভিত্তিগত ধারণা বোঝার জন্য খুব কার্যকর।

#### Step 1: Setting Up the Project

Terminal এ নিচের কমান্ডগুলো দিয়ে প্রজেক্ট তৈরি করুন এবং **my-app** ফোল্ডারে প্রবেশ করুন:

```bash
npx create-react-app todo-app
cd todo-app
```

---

#### Step 2: Creating the To-Do List Component

**src/App.js** ফাইল খুলুন এবং নিচের কোডটি লিখুন:

```jsx
import React, { useState } from "react";

function App() {
  const [tasks, setTasks] = useState([]);
  const [newTask, setNewTask] = useState("");

  const handleAddTask = () => {
    setTasks([...tasks, newTask]);
    setNewTask("");
  };

  return (
    <div>
      <h1>To-Do List</h1>
      <input
        type="text"
        value={newTask}
        onChange={(e) => setNewTask(e.target.value)}
        placeholder="Add a new task"
      />
      <button onClick={handleAddTask}>Add Task</button>
      <ul>
        {tasks.map((task, index) => (
          <li key={index}>{task}</li>
        ))}
      </ul>
    </div>
  );
}

export default App;
```

#### Explanation:

1. **useState Hook**: আমরা **useState** ব্যবহার করছি task list এবং নতুন task handle করার জন্য।
2. **handleAddTask**: এটি নতুন task list এ যুক্ত করে এবং input field টি reset করে।
3. **map Function**: আমরা **map** function ব্যবহার করছি **tasks** array render করতে।

---

#### Step 3: Adding Interactivity

এখানে নতুন **task** input এ টাইপ করলে **Add Task** বাটন চাপলে task list এ নতুন item যুক্ত হয়।

#### Step 4: Running and Testing

**npm start** কমান্ড দিয়ে প্রজেক্ট চালান:

```bash
npm start
```

ব্রাউজারে **http://localhost:3000** এ গিয়ে আপনার To-Do List অ্যাপটি পরীক্ষা করুন।

---

### 6. Running the React Project

React প্রজেক্ট চালানোর জন্য **npm start** কমান্ড ব্যবহার করুন। এটি local development server চালু করবে এবং আপনি প্রজেক্টটি **http://localhost:3000** এ দেখতে পাবেন।

---

### 7. Conclusion

React এর মাধ্যমে একটি সহজ প্রজেক্ট তৈরি করা অত্যন্ত সহজ এবং দ্রুত। উপরের উদাহরণে আমরা **Simple To-Do List** প্রজেক্ট দেখিয়েছি, যেখানে আপনি একটি নতুন task যুক্ত করতে পারবেন এবং task list দেখতে পারবেন।

React environment setup করার পর, আপনি খুব সহজেই এমন আরও প্রজেক্ট তৈরি করতে পারবেন এবং React এর অন্যান্য feature ব্যবহার করতে পারবেন, যেমন state management এবং component rendering।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-03.1: React Install with Vite

### Table of Contents:

1. [Introduction to Vite](#introduction-to-vite)
2. [Why Use Vite for React?](#why-use-vite-for-react)
3. [Installing React with Vite](#installing-react-with-vite)
   - [Step 1: Installing Vite](#step-1-installing-vite)
   - [Step 2: Setting Up the React Project](#step-2-setting-up-the-react-project)
   - [Step 3: Running the Development Server](#step-3-running-the-development-server)
4. [Folder Structure Overview](#folder-structure-overview)
5. [Real-life Example Project](#real-life-example-project)
6. [Conclusion](#conclusion)

---

### 1. Introduction to Vite

**Vite** হলো একটি modern frontend build tool, যা দ্রুত development server এবং build process প্রদান করে। এটি মূলত **ESM (ECMAScript Modules)** এবং **Hot Module Replacement (HMR)** ব্যবহার করে দ্রুত development environment setup করতে সাহায্য করে। Vite বিশেষভাবে দ্রুত startup time এবং minimal configuration এর জন্য পরিচিত, যা React এর মতো frameworks এর সাথে ভালোভাবে কাজ করে।

---

### 2. Why Use Vite for React?

Vite React এর development environment setup করার জন্য দ্রুত এবং efficient একটি উপায়। এর কিছু প্রধান সুবিধা হলো:

- **Fast Startup**: Traditional bundlers যেমন Webpack এর তুলনায় Vite অনেক দ্রুত startup time প্রদান করে।
- **Hot Module Replacement (HMR)**: Vite এর মাধ্যমে দ্রুত code changes UI তে reflect হয়, যা development process কে আরও efficient করে তোলে।
- **Minimal Configuration**: Vite এর default configuration অনেক সহজ, এবং React এর জন্য এটি automatically সেটআপ করে।
- **Optimized Build**: Vite production build এর জন্য automatically optimized output তৈরি করে।

---

### 3. Installing React with Vite

Vite দিয়ে React setup করতে কয়েকটি ধাপে কাজ করতে হয়। নিচে step-by-step নির্দেশনা দেয়া হলো:

#### Step 1: Installing Vite

প্রথমে, **npm** বা **yarn** ব্যবহার করে Vite ইনস্টল করতে হবে। Terminal বা Command Prompt এ নিচের command লিখুন:

```bash
npm create vite@latest my-react-app
```

অথবা

```bash
yarn create vite my-react-app
```

**my-react-app** এর জায়গায় আপনার পছন্দমতো project এর নাম দিতে পারেন।

#### Step 2: Setting Up the React Project

Vite ইনস্টল করার পরে, Vite আপনাকে কিছু options দিবে। আপনি **React** এবং **JavaScript** (বা TypeScript) select করতে পারেন।

```bash
cd my-react-app
npm install
```

এখন, **cd my-react-app** command এর মাধ্যমে project এর ভেতরে যান এবং **npm install** command দিয়ে dependencies install করুন।

#### Step 3: Running the Development Server

Development server চালু করতে নিচের command লিখুন:

```bash
npm run dev
```

এটি আপনার local server চালু করবে এবং browser এ application preview করবে। Vite এর HMR feature এর কারণে, code এ কোনো পরিবর্তন হলে সাথে সাথে UI তে reflect হবে।

Output:

```
VITE vX.X.X  ready in 300 ms

  ➜  Local:   http://localhost:3000/
  ➜  Network: use --host to expose
```

এই URL এ গিয়ে আপনি আপনার React application দেখতে পাবেন।

---

### 4. Folder Structure Overview

Vite দিয়ে React setup করার পরে একটি সহজ এবং পরিচ্ছন্ন folder structure তৈরি হয়:

```
my-react-app
├── node_modules
├── public
├── src
│   ├── App.jsx
│   ├── main.jsx
│   └── index.css
├── .gitignore
├── index.html
├── package.json
├── vite.config.js
```

- **node_modules**: React এবং Other 3rd Party tools এখানে থাকে। এই Folder এ Touch করার কোন প্রয়োজন নেই। 
- **public**: এই Folder এ আমাদের Website এর Public Assets যেমন Images, Files, Videos etc এগুলা থাকে। 
- **src**: সমস্ত application এর মূল কোড এখানে থাকে। **App.jsx** এবং **main.jsx** হলো মূল React components এবং entry point। একটা React Application এর জন্য 95% সময় আমাদের এই Folder এই কাঁটাতে হবে। 
- **public**: Static files এর জন্য ব্যবহৃত হয়।
- **index.html**: Vite এর জন্য প্রধান HTML ফাইল। এই ফাইলে `<div id="root"></div>` root নামে যে div element থাকে, সেটিই আসলে আমাদের Application এর Container হিসেবে কাজ করে। কারন সব React Code এই root এর মধ্যেই render করা হয়।  
- **vite.config.js**: Vite এর configuration ফাইল। এটিও Touch করার প্রয়োজন হয় না। 

---

## Explanation of main.jsx File

### Table of Contents

1. **Code Overview**
2. **What is StrictMode?**
3. **How does createRoot Work?**
4. **Rendering Process with ReactDOM**
5. **Discussion on File Imports**

---

### 1. Code Overview

এই কোডটি একটি React Application এর Entry Point হিসেবে কাজ করে, যা মূলত ব্রাউজারে Render করা হয়। এখানে `React` এবং `ReactDOM` লাইব্রেরির কিছু ফাংশন ব্যবহার করা হয়েছে আমাদের Application-কে ব্রাউজারে দেখানোর জন্য।

### 2. What is StrictMode?

`StrictMode` হল React এর একটি Component যা আমাদের কোডের কিছু সাধারণ সমস্যা যেমন Deprecated API ব্যবহার করা বা কোনো অনাকাঙ্ক্ষিত Side-Effect ধরতে সাহায্য করে। এটি শুধুমাত্র Development Mode-এ কাজ করে, Production Mode-এ কোনো প্রভাব ফেলে না। নিচে আমরা `StrictMode` ব্যবহার করেছি Application-কে Render করার সময় যাতে Development Console-এ কোনো সমস্যা থাকলে সেটি দেখায়:

```jsx
<StrictMode>
  <App />
</StrictMode>
```

### 3. How does createRoot Work?

`createRoot` হল `React 18` এর একটি নতুন API, যা React Application-কে Render করার জন্য ব্যবহৃত হয়। এটি ReactDOM এর নতুন Method হিসেবে এসেছে, যা পুরোনো `ReactDOM.render` এর পরিবর্তে ব্যবহৃত হচ্ছে।

```javascript
createRoot(document.getElementById("root")).render(
  <StrictMode>
    <App />
  </StrictMode>
);
```

- `createRoot` প্রথমে HTML ডকুমেন্টে সেই Element খুঁজে বের করে যার `id` `'root'`।
- তারপর এটি `render` Method এর মাধ্যমে `<App />` Component-টি `StrictMode` এর মধ্যে Render করে। এতে করে, পুরো Application টি ঐ `root` Div-এর মধ্যে Render হয়।

### 4. Rendering Process with ReactDOM

আগে আমরা `ReactDOM.render` ব্যবহার করতাম, কিন্তু `React 18` থেকে, আমরা `ReactDOM.createRoot` এবং `.render()` Method ব্যবহার করি। এটি Rendering Performance উন্নত করে এবং নতুন কিছু Feature যেমন Concurrent Mode কে সমর্থন করে।

### 5. Discussion on File Imports

```javascript
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./index.css";
import App from "./App.jsx";
```

- **`StrictMode`**: এটি `react` লাইব্রেরি থেকে Import করা হয়।
- **`createRoot`**: এটি `react-dom/client` থেকে Import করা হয়।
- **`'./index.css'`**: Stylesheet Import করা হয়েছে, যা Application এর Style নির্ধারণ করে।
- **`App`**: `'./App.jsx'` থেকে আমাদের মূল Application Component Import করা হয়েছে, যা আমাদের Application এর প্রধান অংশ।

এইভাবে, কোডটি আমাদের React Application-কে সফলভাবে ব্রাউজারে Render করার জন্য প্রয়োজনীয় সবকিছু প্রস্তুত করে।

### 5. Real-life Example Project

ধরা যাক, আমরা একটি simple React component তৈরি করবো যেখানে "Hello, Vite!" প্রদর্শিত হবে।

#### Example Code:

**App.jsx**

```jsx
function App() {
  return (
    <div className="App">
      <h1>Hello, Vite!</h1>
    </div>
  );
}

export default App;
```

**main.jsx**

```jsx
import React from "react";
import ReactDOM from "react-dom";
import App from "./App";
import "./index.css";

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

এই কোড Vite environment এ দ্রুত render হবে এবং আপনি browser এ "Hello, Vite!" দেখতে পাবেন।

---

### 6. Conclusion

Vite দিয়ে React setup করা খুবই সহজ এবং efficient। এটি traditional bundlers এর তুলনায় দ্রুত এবং minimal configuration দিয়ে কাজ করে, যা modern React development এর জন্য আদর্শ। Vite এর মাধ্যমে আপনি খুব সহজেই একটি React application তৈরি করতে পারেন এবং দ্রুত development environment পেতে পারেন।

Vite এর speed এবং flexibility React এর modern development environment এর জন্য একটি বড় সুবিধা।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-04: React Render HTML

### Table of Contents:

1. [What Does Rendering HTML Mean in React?](#what-does-rendering-html-mean-in-react)
2. [How React Renders HTML](#how-react-renders-html)
   - [JSX Syntax](#jsx-syntax)
   - [ReactDOM.render()](#reactdomrender)
3. [Rendering Dynamic Content](#rendering-dynamic-content)
4. [Real-life Example of Rendering HTML](#real-life-example-of-rendering-html)
5. [React Virtual DOM and Rendering Efficiency](#react-virtual-dom-and-rendering-efficiency)
6. [Conclusion](#conclusion)

---

### 1. What Does Rendering HTML Mean in React?

**Rendering HTML** মানে হলো HTML elements বা components-কে web browser এ প্রদর্শন করা। সাধারণত traditional JavaScript দিয়ে DOM (Document Object Model) এর সাথে কাজ করা হয়, যেখানে `document.createElement()` বা `innerHTML` ব্যবহার করে HTML dynamically generate করা হয়। কিন্তু **React** এ, rendering process আরও streamlined এবং efficient, কারণ React এর মাধ্যমে আপনি HTML code **JSX (JavaScript XML)** syntax ব্যবহার করে লিখতে পারেন এবং virtual DOM এর মাধ্যমে efficiently render করতে পারেন।

React এর মূল কাজ হলো user interface তৈরি করা এবং সেই UI কে browser এর real DOM এ reflect করা। React এই কাজটি করে **ReactDOM** এর মাধ্যমে যা web page এ HTML render করে।

---

### 2. How React Renders HTML

#### JSX Syntax

**JSX (JavaScript XML)** হলো React এর special syntax যা HTML এর মতো দেখতে, কিন্তু এটি JavaScript এর মধ্যে embedded থাকে। JSX ব্যবহার করলে HTML elements এবং JavaScript একসাথে manage করা সহজ হয়। JSX এর মাধ্যমে আপনি HTML এর মতো structure লিখতে পারেন, যেটা পরে React component এ পরিবর্তিত হয়ে rendering হয়।

##### Example of JSX:

```jsx
const element = <h1>Hello, world!</h1>;
```

এটি দেখলে HTML এর মতো মনে হলেও এটি আসলে **JSX**। React এই JSX কে JavaScript এ convert করে এবং DOM এ render করে।

#### ReactDOM.render()

**ReactDOM.render()** method ব্যবহার করে React component বা JSX কে real DOM এ রেন্ডার করা হয়।

##### Syntax:

```jsx
ReactDOM.render(element, document.getElementById("root"));
```

এই example এ, **element** হলো যে HTML বা React component টি render করা হবে, এবং **'root'** হলো HTML এর id, যেখানে এই content inject হবে।

##### Example:

```jsx
import React from "react";
import ReactDOM from "react-dom";

const element = <h1>Hello, React!</h1>;

ReactDOM.render(element, document.getElementById("root"));
```

উপরের কোডটি **index.html** এর একটি **div** element এর মধ্যে render হবে যেটির id হবে "root":

```html
<div id="root"></div>
```

---

### 3. Rendering Dynamic Content

React এ শুধু static HTML নয়, বরং dynamic content render করা যায়। উদাহরণস্বরূপ, user input অনুযায়ী data dynamically update এবং render করা যায়।

##### Example of Rendering Dynamic Content:

```jsx
import React, { useState } from "react";
import ReactDOM from "react-dom";

function App() {
  const [name, setName] = useState("React");

  return (
    <div>
      <h1>Hello, {name}!</h1>
      <input
        type="text"
        value={name}
        onChange={(e) => setName(e.target.value)}
      />
    </div>
  );
}

ReactDOM.render(<App />, document.getElementById("root"));
```

#### Explanation:

1. **useState Hook**: আমরা **useState** hook ব্যবহার করে **name** নামক একটি state তৈরি করেছি।
2. **Dynamic Rendering**: যখন user input field এ কিছু লিখবে, সেই **name** value dynamically update হয়ে rendering হবে।

---

### 4. Real-life Example of Rendering HTML

ধরা যাক, আপনি একটি e-commerce website তৈরি করছেন যেখানে প্রতিবার নতুন product যোগ করলে সেই product টি dynamically render করতে হবে। React এর মাধ্যমে সহজেই এই কাজ করা যায়।

#### Example:

```jsx
import React, { useState } from "react";
import ReactDOM from "react-dom";

function ProductList() {
  const [products, setProducts] = useState(["Product 1", "Product 2"]);

  const addProduct = () => {
    setProducts([...products, `Product ${products.length + 1}`]);
  };

  return (
    <div>
      <h1>Product List</h1>
      <ul>
        {products.map((product, index) => (
          <li key={index}>{product}</li>
        ))}
      </ul>
      <button onClick={addProduct}>Add Product</button>
    </div>
  );
}

ReactDOM.render(<ProductList />, document.getElementById("root"));
```

#### Explanation:

1. **useState**: এখানে **products** নামক একটি state আছে যেটা একটি array ধরে। যখন নতুন product যোগ করা হয়, সেটা **addProduct** function এর মাধ্যমে **products** এ যুক্ত হয়।
2. **Dynamic Rendering**: প্রতিবার নতুন product যোগ করার পরে, **ProductList** component টিকে re-render করা হয় এবং updated product list দেখতে পাওয়া যায়।

---

### 5. React Virtual DOM and Rendering Efficiency

React এর HTML rendering এত efficient হওয়ার পেছনে বড় কারণ হলো এর **Virtual DOM**। যখন আপনি React component এ কোনো পরিবর্তন করেন, React পুরো DOM কে re-render করে না। এটি প্রথমে Virtual DOM এ changes apply করে এবং তারপর minimal changes real DOM এ implement করে। এর মাধ্যমে unnecessary re-rendering এড়ানো যায়, এবং UI দ্রুত আপডেট হয়।

---

### 6. Conclusion

React এর মাধ্যমে HTML rendering process অনেক সহজ এবং efficient হয়ে যায়, বিশেষ করে **JSX** এবং **ReactDOM** এর কারণে। আপনি শুধুমাত্র static content নয়, dynamic content ও খুব সহজে render করতে পারেন, এবং React এর **Virtual DOM** এর মাধ্যমে UI খুব দ্রুত এবং smooth ভাবে update হয়।

এইভাবে, React modern web applications এর জন্য একটি essential tool হয়ে উঠেছে, যা UI rendering কে সহজ করে এবং performance উন্নত করে।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-05: React JSX

### Table of Contents:

1. [What is JSX?](#what-is-jsx)
2. [Why JSX is Important](#why-jsx-is-important)
3. [JSX Syntax](#jsx-syntax)
   - [Embedding Expressions in JSX](#embedding-expressions-in-jsx)
   - [JSX Elements and Components](#jsx-elements-and-components)
4. [JSX vs HTML](#jsx-vs-html)
5. [Real-life Example of JSX](#real-life-example-of-jsx)
6. [Common JSX Mistakes and Best Practices](#common-jsx-mistakes-and-best-practices)
7. [Conclusion](#conclusion)

---

### 1. What is JSX?

**JSX (JavaScript XML)** হলো React এর একটি syntax extension, যা JavaScript এর ভেতরে HTML এর মতো structure লিখতে দেয়। যদিও JSX দেখতে HTML এর মতো, এটি আসলে একটি **JavaScript** এর বিশেষ syntax যা **React** এর মধ্যে ব্যবহার করা হয়। React এর সাথে কাজ করতে গেলে JSX শেখা অত্যন্ত গুরুত্বপূর্ণ, কারণ React এর মাধ্যমে UI তৈরি করার জন্য JSX অন্যতম প্রধান উপাদান।

##### Example of JSX:

```jsx
const element = <h1>Hello, World!</h1>;
```

উপরের কোডটিতে **<h1>Hello, World!</h1>** হলো JSX এর একটি উদাহরণ, যা পরবর্তীতে JavaScript কোডে পরিবর্তিত হয়ে DOM এ render হয়।

---

### 2. Why JSX is Important

JSX React এর একটি প্রধান অংশ, কারণ এটি HTML এর মতো syntax ব্যবহার করে **JavaScript** এর ভেতরে **UI components** তৈরির কাজকে সহজ করে। এর কিছু প্রধান সুবিধা হলো:

1. **Readable and Declarative**: JSX HTML এর মতো দেখতে হওয়ায় কোডটি অনেক বেশি readable এবং declarative হয়, যা development experience সহজ করে।
2. **Integration with JavaScript**: JSX এর মাধ্যমে সহজেই JavaScript expressions এবং logic UI এর সাথে integrate করা যায়।
3. **Faster Rendering**: React এর **Virtual DOM** এর সাথে মিলিত হয়ে JSX দ্রুত HTML render করে এবং performance বৃদ্ধি করে।

---

### 3. JSX Syntax

JSX এর syntax দেখতে HTML এর মতো, কিন্তু এর কিছু বিশেষ নিয়ম এবং functionality রয়েছে যা HTML এর চেয়ে আলাদা।

#### Embedding Expressions in JSX

JSX এর সবচেয়ে শক্তিশালী বৈশিষ্ট্য হলো এর মধ্যে **JavaScript expressions** embed করা যায়। JavaScript এর কোনো value JSX এ curly braces `{}` এর মধ্যে রেখে render করা যায়।

##### Example of Embedding JavaScript in JSX:

```jsx
const name = "React";
const element = <h1>Hello, {name}!</h1>;
```

এই উদাহরণে, **name** নামক JavaScript variable টি JSX এর মধ্যে রাখা হয়েছে। এর ফলে DOM এ **"Hello, React!"** render হবে।

#### JSX Elements and Components

JSX এর মাধ্যমে শুধুমাত্র HTML elements তৈরি করা যায় না, বরং React components কে JSX এর মধ্যে ব্যবহার করা যায়।

##### Example of JSX with Components:

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}!</h1>;
}

const element = <Welcome name="React" />;
```

এখানে **Welcome** হলো একটি React component যা JSX এর মাধ্যমে render হয়েছে। Component এর **props** ব্যবহার করে dynamic data render করা হচ্ছে।

---

### 4. JSX vs HTML

যদিও JSX HTML এর মতো দেখতে, এদের মধ্যে কিছু পার্থক্য রয়েছে। কিছু গুরুত্বপূর্ণ পার্থক্য নিচে উল্লেখ করা হলো:

1. **class vs className**: HTML এ **class** attribute ব্যবহার করা হয়, কিন্তু JSX এ **className** ব্যবহার করতে হয়, কারণ **class** হলো JavaScript এর reserved keyword।

   ```jsx
   <div className="container"></div>
   ```

2. **Self-closing Tags**: JSX এ প্রতিটি tag self-close করা প্রয়োজন, যদি তার কোনো closing tag না থাকে।

   ```jsx
   <img src="image.jpg" alt="Sample" />
   ```

3. **JSX attributes in camelCase**: HTML attributes, যেমন **onclick** বা **onchange** JSX এ camelCase এ লিখতে হয়।

   ```jsx
   <button onClick={handleClick}>Click Me</button>
   ```

---

### 5. Real-life Example of JSX

ধরা যাক, আপনি একটি **User Profile** component তৈরি করতে চান, যেখানে user's name, email, এবং profile picture থাকবে। React এর মাধ্যমে এটি সহজেই করা যায়।

#### Example:

```jsx
function UserProfile(props) {
  return (
    <div className="profile-card">
      <img src={props.avatar} alt="User Avatar" />
      <h2>{props.name}</h2>
      <p>Email: {props.email}</p>
    </div>
  );
}

const element = (
  <UserProfile
    avatar="https://example.com/avatar.jpg"
    name="John Doe"
    email="john.doe@example.com"
  />
);

ReactDOM.render(element, document.getElementById("root"));
```

#### Explanation:

1. **UserProfile Component**: এখানে **UserProfile** নামে একটি React component তৈরি করা হয়েছে, যা props হিসেবে user এর **name**, **email**, এবং **avatar** image গ্রহণ করে।
2. **Props Usage**: **props.name**, **props.email** ইত্যাদি JSX এর মধ্যে render হচ্ছে, যার ফলে component dynamic ভাবে ব্যবহার করা যায়।
3. **Rendering**: ReactDOM.render() method এর মাধ্যমে component কে DOM এ render করা হয়েছে।

---

### 6. Common JSX Mistakes and Best Practices

#### Mistake 1: Forgetting to Close Tags

JSX এ প্রতিটি element self-closing হওয়া উচিত যদি তার কোনো child না থাকে। উদাহরণস্বরূপ:

```jsx
// Incorrect
<input>

// Correct
<input />
```

#### Mistake 2: Returning Multiple Elements Without Wrapping

JSX এ multiple elements return করতে গেলে এগুলোকে একটি parent element এর মধ্যে রাখতে হয়। উদাহরণস্বরূপ:

```jsx
// Incorrect
return (
  <h1>Hello</h1>
  <p>World</p>
);

// Correct
return (
  <div>
    <h1>Hello</h1>
    <p>World</p>
  </div>
);
```

---

### 7. Conclusion

**JSX** হলো React এর প্রধান syntax যা JavaScript এর মধ্যে HTML elements এবং components তৈরি করতে সাহায্য করে। এটি declarative এবং readable syntax এর কারণে UI development সহজ করে। JSX এর মাধ্যমে আপনি শুধু static content নয়, dynamic JavaScript expressions এবং React components ব্যবহার করতে পারবেন।

JSX এর সঠিক ব্যবহার React এর core concepts বুঝতে সাহায্য করে এবং complex UI গুলোকে সহজে maintainable করে তোলে।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-06: React Components

### Table of Contents:

1. [What are React Components?](#what-are-react-components)
2. [Types of React Components](#types-of-react-components)
   - [Function Components](#function-components)
   - [Class Components](#class-components)
3. [Props in React Components](#props-in-react-components)
4. [State in React Components](#state-in-react-components)
5. [Lifecycle Methods in Class Components](#lifecycle-methods-in-class-components)
6. [Real-life Example of React Components](#real-life-example-of-react-components)
7. [Conclusion](#conclusion)

---

### 1. What are React Components?

**React components** হলো React এর মূল building blocks, যা UI কে ছোট ছোট অংশে ভাগ করে পুনরায় ব্যবহারযোগ্য করে তোলে। প্রতিটি React component একটি JavaScript function বা class যা **HTML-like** structure (JSX) return করে এবং UI এর বিভিন্ন অংশে প্রদর্শিত হয়। Components independent হওয়ার কারণে, একটি component তার নিজস্ব state এবং props ব্যবহার করে নির্দিষ্ট অংশের কাজ সম্পন্ন করে।

##### Example of a Simple React Component:

```jsx
function Welcome() {
  return <h1>Hello, React!</h1>;
}
```

এখানে, **Welcome** হলো একটি React function component যা **Hello, React!** text কে render করে। React components ব্যবহার করে আপনি complex UI গুলোকে ছোট ছোট reusable অংশে ভাগ করতে পারেন।

---

### 2. Types of React Components

React এ দুটি প্রধান ধরনের component আছে: **Function Components** এবং **Class Components**।

#### Function Components

**Function Components** হলো JavaScript functions যা JSX return করে। এগুলো React Hooks ব্যবহার করে state এবং lifecycle এর সাথে কাজ করতে পারে। Function components সাধারণত সহজ এবং lightweight হয়।

##### Example of Function Component:

```jsx
function Greeting(props) {
  return <h1>Hello, {props.name}!</h1>;
}
```

#### Class Components

**Class Components** হলো ES6 এর JavaScript classes যা React.Component থেকে extend করে। এগুলো state এবং lifecycle methods support করে। তবে function components এবং hooks এর আগমনের পর class components এর ব্যবহার কমে গেছে।

##### Example of Class Component:

```jsx
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}
```

---

### 3. Props in React Components

**Props** হলো component এর external data যা parent component থেকে pass করা হয়। এটি immutable, অর্থাৎ component এর ভিতর থেকে props modify করা যায় না। Props এর মাধ্যমে component গুলো dynamic data গ্রহণ করে এবং সেই অনুযায়ী render করতে পারে।

##### Example of Passing Props:

```jsx
function Greeting(props) {
  return <h1>Hello, {props.name}!</h1>;
}

const element = <Greeting name="John" />;
ReactDOM.render(element, document.getElementById("root"));
```

এখানে, **name** prop parent component থেকে **Greeting** component এ pass করা হয়েছে, যা UI তে dynamic data প্রদর্শন করছে।

---

### 4. State in React Components

**State** হলো component এর internal data, যা পরিবর্তনশীল এবং component এর behavior কে dynamically পরিবর্তন করতে পারে। Function components এ state handle করতে **useState Hook** এবং class components এ **this.state** ব্যবহার করা হয়। State dynamic data handle করে, যা user interaction এর উপর ভিত্তি করে পরিবর্তিত হয়।

##### Example of State in Function Component:

```jsx
import React, { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}
```

##### Example of State in Class Component:

```jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  render() {
    return (
      <div>
        <p>You clicked {this.state.count} times</p>
        <button onClick={() => this.setState({ count: this.state.count + 1 })}>
          Click me
        </button>
      </div>
    );
  }
}
```

---

### 5. Lifecycle Methods in Class Components

React class components এ **lifecycle methods** থাকে, যা component এর বিভিন্ন পর্যায়ে (mounting, updating, unmounting) কাজ করতে সাহায্য করে। কিছু গুরুত্বপূর্ণ lifecycle methods হলো:

- **componentDidMount**: component render হওয়ার পর একবার চালানো হয়।
- **componentDidUpdate**: component re-render হলে এটি চালানো হয়।
- **componentWillUnmount**: component destroy হওয়ার আগে চালানো হয়।

##### Example of componentDidMount:

```jsx
class Timer extends React.Component {
  componentDidMount() {
    this.timerID = setInterval(() => this.tick(), 1000);
  }

  tick() {
    console.log("Timer is ticking");
  }

  render() {
    return <h1>Timer Running</h1>;
  }
}
```

---

### 6. Real-life Example of React Components

ধরা যাক, আপনি একটি **User Profile** তৈরি করতে চান যেখানে user এর নাম, বয়স এবং address দেখানো হবে। এটি component ভিত্তিক ভাবে খুব সহজেই করা যায়।

#### Example:

```jsx
function UserProfile(props) {
  return (
    <div className="profile">
      <h2>{props.name}</h2>
      <p>Age: {props.age}</p>
      <p>Address: {props.address}</p>
    </div>
  );
}

const element = (
  <UserProfile name="John Doe" age="30" address="123 React Street" />
);

ReactDOM.render(element, document.getElementById("root"));
```

#### Explanation:

- **UserProfile Component**: এখানে একটি reusable React component তৈরি করা হয়েছে, যা props এর মাধ্যমে dynamic data render করছে।
- **Props**: User এর **name**, **age**, এবং **address** props আকারে **UserProfile** component এ পাঠানো হয়েছে।

---

### 7. Conclusion

React এর **components** modern web development এর cornerstone, কারণ এগুলো UI কে ছোট, reusable অংশে ভাগ করে, যেগুলো dynamic ভাবে কাজ করে। React components বিভিন্ন ধরণের data handle করতে পারে, যেমন props, state, এবং lifecycle methods এর মাধ্যমে complex UI তৈরি করতে পারে।

Function components এবং hooks আসার পর থেকে React এর ব্যবহার আরও সহজ এবং efficient হয়েছে, কিন্তু class components এর শক্তিশালী lifecycle methods এখনও বেশ উপযোগী।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-07: React Class Components

### Table of Contents:

1. [What is a React Class Component?](#what-is-a-react-class-component)
2. [Defining a React Class Component](#defining-a-react-class-component)
3. [React Class vs Function Components](#react-class-vs-function-components)
4. [State in Class Components](#state-in-class-components)
5. [Lifecycle Methods in Class Components](#lifecycle-methods-in-class-components)
6. [Props in Class Components](#props-in-class-components)
7. [Real-life Example of React Class Components](#real-life-example-of-react-class-components)
8. [Conclusion](#conclusion)

---

### 1. What is a React Class Component?

**React Class Components** হলো traditional React components যা ES6 এর JavaScript class এর মাধ্যমে তৈরি করা হয়। Class components ব্যবহার করে state management, lifecycle methods এবং complex functionality সহজে handle করা যায়। যদিও function components এবং React Hooks এর আগমনে class components এর ব্যবহার কমে গেছে, তবুও class components এখনও পুরোনো কোডবেস এবং কিছু complex scenarios তে ব্যবহৃত হয়।

Class components React.Component class থেকে extend করে এবং অবশ্যই **render()** method রাখতে হয়, যা JSX বা React elements return করে।

---

### 2. Defining a React Class Component

React class component define করতে গেলে, আপনাকে ES6 class ব্যবহার করতে হবে, যা **React.Component** class থেকে inherit করে। নিচে একটি React class component এর উদাহরণ দেয়া হলো:

##### Example of Class Component:

```jsx
import React, { Component } from "react";

class Welcome extends Component {
  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}

export default Welcome;
```

#### Explanation:

1. **Welcome Component**: এখানে **Welcome** নামে একটি React class component তৈরি করা হয়েছে, যা **React.Component** থেকে extend করা হয়েছে।
2. **render() Method**: প্রত্যেক React class component এর মধ্যে **render()** method থাকতে হবে, যেখানে JSX বা React elements return করা হবে।
3. **props**: Class components এর মধ্যে **props** **this.props** ব্যবহার করে access করতে হয়।

---

### 3. React Class vs Function Components

React এর শুরুতে class components ব্যবহার করা হতো, কিন্তু function components এবং React Hooks আসার পর থেকে function components বেশি জনপ্রিয়। নিচে দুই ধরনের component এর পার্থক্য দেয়া হলো:

#### Function Components:

- **Simpler**: Function components সহজ এবং lightweight।
- **Hooks**: React Hooks এর মাধ্যমে function components state এবং lifecycle methods manage করতে পারে।
- **Less Boilerplate**: Function components এ class components এর মতো boilerplate কোড লিখতে হয় না।

#### Class Components:

- **State and Lifecycle**: Class components এ state এবং lifecycle methods প্রাকৃতিকভাবে আছে।
- **Legacy Code**: পুরোনো React কোডবেসে এখনও class components ব্যবহার করা হয়।
- **Complex Features**: কিছু complex feature class components এ বেশি সহজে handle করা যায়।

---

### 4. State in Class Components

**State** হলো class component এর internal data, যা dynamic ভাবে পরিবর্তিত হতে পারে এবং component এর UI কে update করতে পারে। Class components এ **this.state** এবং **this.setState()** ব্যবহার করে state manage করা হয়।

##### Example of State in Class Component:

```jsx
import React, { Component } from "react";

class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}

export default Counter;
```

#### Explanation:

1. **this.state**: এখানে **count** নামক একটি state তৈরি করা হয়েছে।
2. **this.setState()**: state update করতে **this.setState()** method ব্যবহার করা হয়েছে।
3. **render()**: state এর পরিবর্তন অনুযায়ী component re-render হয় এবং updated data UI তে প্রদর্শিত হয়।

---

### 5. Lifecycle Methods in Class Components

React class components এর একটি গুরুত্বপূর্ণ feature হলো **lifecycle methods**। এই methods component এর lifecycle এর বিভিন্ন পর্যায়ে (mounting, updating, unmounting) execute হয়।

#### Common Lifecycle Methods:

1. **componentDidMount**: Component render হওয়ার পর এটি একবার execute হয়।
2. **componentDidUpdate**: Component re-render হলে execute হয়।
3. **componentWillUnmount**: Component destroy হওয়ার আগে execute হয়।

##### Example of Lifecycle Method:

```jsx
import React, { Component } from "react";

class Timer extends Component {
  componentDidMount() {
    this.timerID = setInterval(() => this.tick(), 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    console.log("Timer ticking");
  }

  render() {
    return <h1>Timer is running</h1>;
  }
}

export default Timer;
```

#### Explanation:

1. **componentDidMount**: Timer শুরু করার জন্য **setInterval** এখানে ব্যবহার করা হয়েছে, যা component render হওয়ার পর চালু হয়।
2. **componentWillUnmount**: Component destroy হওয়ার আগে **clearInterval** ব্যবহার করে timer বন্ধ করা হয়েছে।

---

### 6. Props in Class Components

**Props** হলো external data যা parent component থেকে class component এ pass করা হয়। Class components এ props **this.props** ব্যবহার করে access করা হয়।

##### Example of Props in Class Component:

```jsx
import React, { Component } from "react";

class Welcome extends Component {
  render() {
    return <h1>Welcome, {this.props.name}!</h1>;
  }
}

export default Welcome;
```

#### Explanation:

1. **this.props**: এখানে **name** prop pass করা হয়েছে, যা **this.props.name** ব্যবহার করে UI তে প্রদর্শিত হচ্ছে।

---

### 7. Real-life Example of React Class Components

ধরা যাক, আপনি একটি **User Profile** class component তৈরি করতে চান, যেখানে user এর নাম এবং বয়স dynamic ভাবে প্রদর্শিত হবে এবং সেই তথ্য পরিবর্তিত হবে।

#### Example:

```jsx
import React, { Component } from "react";

class UserProfile extends Component {
  constructor(props) {
    super(props);
    this.state = { age: 25 };
  }

  incrementAge = () => {
    this.setState({ age: this.state.age + 1 });
  };

  render() {
    return (
      <div>
        <h2>{this.props.name}</h2>
        <p>Age: {this.state.age}</p>
        <button onClick={this.incrementAge}>Increase Age</button>
      </div>
    );
  }
}

export default UserProfile;
```

#### Explanation:

1. **UserProfile Component**: এখানে **UserProfile** একটি class component যা user এর নাম এবং বয়স প্রদর্শন করছে।
2. **Props and State**: User এর নাম **props** এর মাধ্যমে pass করা হয়েছে এবং বয়স **state** এর মাধ্যমে handle করা হচ্ছে।
3. **Increment Function**: **this.setState()** method ব্যবহার করে user এর বয়স বাড়ানো হচ্ছে।

---

### 8. Conclusion

React class components modern web development এর cornerstone, বিশেষ করে state management এবং lifecycle methods handle করার ক্ষেত্রে। যদিও function components এবং React Hooks আসার পরে class components এর ব্যবহার কিছুটা কমেছে, তবুও তারা পুরনো কোডবেস এবং complex applications এর জন্য এখনও গুরুত্বপূর্ণ। Class components এর মাধ্যমে React এর powerful features যেমন state, props, এবং lifecycle methods handle করা সম্ভব হয়।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-07.1: Lifecycle Methods in Class Components

### Table of Contents:

1. [What are Lifecycle Methods?](#what-are-lifecycle-methods)
2. [Phases of Component Lifecycle](#phases-of-component-lifecycle)
3. [Lifecycle Methods in Each Phase](#lifecycle-methods-in-each-phase)
   - [Mounting Phase](#mounting-phase)
   - [Updating Phase](#updating-phase)
   - [Unmounting Phase](#unmounting-phase)
4. [Real-life Example of Lifecycle Methods](#real-life-example-of-lifecycle-methods)
5. [Best Practices for Using Lifecycle Methods](#best-practices-for-using-lifecycle-methods)
6. [Conclusion](#conclusion)

---

### 1. What are Lifecycle Methods?

React এর class components এ **lifecycle methods** এমন কিছু বিশেষ method, যা component এর বিভিন্ন পর্যায়ে execute হয়। Component এর initialization থেকে শুরু করে update এবং destruction পর্যন্ত প্রতিটি ধাপে এই methods গুলো ব্যবহার করে component এর behavior control করা যায়। **Lifecycle methods** component render, update, এবং unmount হওয়ার সময় নির্দিষ্ট কাজ পরিচালনা করতে সাহায্য করে, যেমন: data fetching, DOM manipulation, cleanup, ইত্যাদি।

---

### 2. Phases of Component Lifecycle

React component এর lifecycle মূলত তিনটি ধাপে বিভক্ত:

1. **Mounting**: Component DOM এ প্রথমবার যুক্ত হওয়ার সময়।
2. **Updating**: Component এর props বা state পরিবর্তিত হলে।
3. **Unmounting**: Component যখন DOM থেকে remove হয়।

---

### 3. Lifecycle Methods in Each Phase

#### Mounting Phase

Mounting phase এ component তৈরি হয় এবং DOM এ প্রথমবার render হয়। এই সময়ে নিচের lifecycle methods গুলো sequentially call হয়:

1. **constructor()**
2. **getDerivedStateFromProps()**
3. **render()**
4. **componentDidMount()**

##### Explanation of Each Method:

- **constructor(props)**: Component এর initial state এবং props set করার জন্য constructor method ব্যবহার করা হয়। এটি lifecycle এর প্রথম method এবং **this.state** initialize করার জন্য এটি গুরুত্বপূর্ণ।

  ```javascript
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }
  ```

- **getDerivedStateFromProps(props, state)**: এটি একটি static method যা props এর উপর ভিত্তি করে state update করার জন্য ব্যবহৃত হয়। এটি rendering এর ঠিক আগে call হয় এবং state return করে।

  ```javascript
  static getDerivedStateFromProps(props, state) {
    if (props.reset) {
      return { count: 0 };
    }
    return null;
  }
  ```

- **render()**: render() method component এর UI define করে এবং JSX return করে। এটি mandatory method এবং এটি re-rendering trigger করে।

  ```javascript
  render() {
    return <h1>Count: {this.state.count}</h1>;
  }
  ```

- **componentDidMount()**: component প্রথমবার render হওয়ার পরে **componentDidMount** execute হয়। এটি API call বা DOM manipulation এর জন্য উপযুক্ত।

  ```javascript
  componentDidMount() {
    console.log("Component mounted!");
  }
  ```

---

#### Updating Phase

Updating phase এ component এর props বা state পরিবর্তিত হলে component re-render হয়। এই সময়ে sequentially নিচের lifecycle methods গুলো call হয়:

1. **getDerivedStateFromProps()**
2. **shouldComponentUpdate()**
3. **render()**
4. **getSnapshotBeforeUpdate()**
5. **componentDidUpdate()**

##### Explanation of Each Method:

- **shouldComponentUpdate(nextProps, nextState)**: এই method return করে true বা false, যা নির্ধারণ করে component re-render হবে কি না। এটি performance optimization এর জন্য উপযুক্ত।

  ```javascript
  shouldComponentUpdate(nextProps, nextState) {
    return nextState.count !== this.state.count;
  }
  ```

- **getSnapshotBeforeUpdate(prevProps, prevState)**: DOM update হওয়ার আগে component এর পূর্বের অবস্থার snapshot নিতে ব্যবহৃত হয়। এটি scrolling position, DOM updates track করতে ব্যবহৃত হয়।

  ```javascript
  getSnapshotBeforeUpdate(prevProps, prevState) {
    if (prevState.count < this.state.count) {
      return "Count increased";
    }
    return null;
  }
  ```

- **componentDidUpdate(prevProps, prevState, snapshot)**: Component update হওয়ার পরে execute হয় এবং **getSnapshotBeforeUpdate** এর return value receive করে।

  ```javascript
  componentDidUpdate(prevProps, prevState, snapshot) {
    if (snapshot) {
      console.log(snapshot);
    }
  }
  ```

---

#### Unmounting Phase

Unmounting phase এ component যখন DOM থেকে remove হওয়ার সময়, এই method টি call হয়:

- **componentWillUnmount()**: Component unmount হওয়ার আগে এই method execute হয়। এটি cleanup এর জন্য, যেমন: timers, subscriptions, event listeners remove করতে ব্যবহৃত হয়।

  ```javascript
  componentWillUnmount() {
    console.log("Component will unmount!");
  }
  ```

---

### 4. Real-life Example of Lifecycle Methods

ধরা যাক, আমরা একটি **Timer** component তৈরি করতে চাচ্ছি যা প্রতি সেকেন্ডে update হবে এবং component unmount হলে timer বন্ধ হবে।

##### Example:

```javascript
import React, { Component } from "react";

class Timer extends Component {
  constructor(props) {
    super(props);
    this.state = { seconds: 0 };
  }

  componentDidMount() {
    this.timerID = setInterval(() => {
      this.setState((prevState) => ({ seconds: prevState.seconds + 1 }));
    }, 1000);
  }

  componentDidUpdate() {
    console.log("Timer updated:", this.state.seconds);
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
    console.log("Timer cleared");
  }

  render() {
    return <h1>Seconds: {this.state.seconds}</h1>;
  }
}

export default Timer;
```

**Explanation**:

1. **componentDidMount**: এখানে interval set করা হয়েছে এবং timer প্রতি সেকেন্ডে update হচ্ছে।
2. **componentDidUpdate**: Timer এর প্রতি update console এ log করা হচ্ছে।
3. **componentWillUnmount**: Component unmount হওয়ার আগে interval clear করা হচ্ছে।

---

### 5. Best Practices for Using Lifecycle Methods

1. **Avoid Excessive use of componentDidUpdate**: Unnecessary re-renders এড়ানোর জন্য **componentDidUpdate** এ conditionals ব্যবহার করুন।
2. **Perform Cleanup in componentWillUnmount**: Memory leak এড়াতে cleanup নিশ্চিত করুন।
3. **Avoid Direct DOM Manipulation**: React এর built-in state এবং props ব্যবহার করুন, সরাসরি DOM access না করাই ভালো।

---

### 6. Conclusion

React এর class components এ **lifecycle methods** component এর initialization, update, এবং destruction phases কে manage করতে সাহায্য করে। Proper use of these lifecycle methods allows developers to control the behavior of components effectively, manage resources, and optimize performance, making React applications more robust and efficient.

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-07.2: Props in Class Components

### Table of Contents:

1. [What are Props?](#what-are-props)
2. [Why Use Props in Class Components?](#why-use-props-in-class-components)
3. [How to Access Props in Class Components](#how-to-access-props-in-class-components)
4. [Passing Props to Class Components](#passing-props-to-class-components)
5. [Default Props](#default-props)
6. [Prop Types for Validation](#prop-types-for-validation)
7. [Real-life Example of Props Usage](#real-life-example-of-props-usage)
8. [Conclusion](#conclusion)

---

### 1. What are Props?

**Props** বা "properties" হলো React এ data passing করার একটি পদ্ধতি, যা parent component থেকে child component এ data পাঠাতে ব্যবহৃত হয়। Props হলো immutable, অর্থাৎ, child component এ props এর মান পরিবর্তন করা যায় না। এটি component এর behavior customize করতে এবং dynamic content প্রদর্শন করতে সাহায্য করে।

---

### 2. Why Use Props in Class Components?

Props ব্যবহার করে:

- Parent component থেকে data child component এ পাঠানো যায়।
- Dynamic এবং reusable components তৈরি করা যায়।
- Component কে configurable এবং flexible করে তোলা সম্ভব হয়, যা কোডের reusability বাড়ায়।

---

### 3. How to Access Props in Class Components

Class components এ props access করতে `this.props` ব্যবহার করা হয়।

##### Example:

```javascript
class Greeting extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}
```

**Explanation**:

- এখানে **this.props.name** এর মাধ্যমে props এ পাঠানো `name` property access করা হচ্ছে।

---

### 4. Passing Props to Class Components

Parent component থেকে child component এ props পাঠানোর জন্য component attribute হিসেবে data pass করতে হয়।

##### Example:

```javascript
class App extends React.Component {
  render() {
    return <Greeting name="John" age={25} />;
  }
}

class Greeting extends React.Component {
  render() {
    return (
      <div>
        <h1>Hello, {this.props.name}!</h1>
        <p>Your age is {this.props.age}.</p>
      </div>
    );
  }
}

ReactDOM.render(<App />, document.getElementById("root"));
```

**Explanation**:

- **name** এবং **age** props হিসেবে **Greeting** component এ pass করা হয়েছে, এবং **this.props.name** ও **this.props.age** এর মাধ্যমে access করা হয়েছে।

**Output**:

```
Hello, John!
Your age is 25.
```

---

### 5. Default Props

React এ **default props** সেট করে দেয়া যায়, যা component এ props না পাঠালে default value হিসেবে ব্যবহৃত হবে।

##### Example:

```javascript
class Greeting extends React.Component {
  static defaultProps = {
    name: "Guest",
  };

  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}

ReactDOM.render(<Greeting />, document.getElementById("root"));
```

**Explanation**:

- এখানে **name** prop না পাঠালে default value হিসেবে "Guest" দেখাবে।

**Output**:

```
Hello, Guest!
```

---

### 6. Prop Types for Validation

React এ prop types ব্যবহার করে props validation করা যায়, যা সাহায্য করে সঠিক ধরনের data component এ pass হচ্ছে কি না তা নিশ্চিত করতে।

##### Example:

```javascript
import PropTypes from "prop-types";

class Greeting extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}

Greeting.propTypes = {
  name: PropTypes.string.isRequired,
};

ReactDOM.render(<Greeting name="John" />, document.getElementById("root"));
```

**Explanation**:

- **PropTypes** ব্যবহার করে props এর type নিশ্চিত করা হয়েছে। এখানে **name** একটি string এবং এটি অবশ্যই প্রয়োজন।

---

### 7. Real-life Example of Props Usage

ধরা যাক, আমরা একটি simple profile component তৈরি করতে চাই, যেখানে user এর নাম এবং তার কাজ দেখানো হবে।

##### Example:

```javascript
class Profile extends React.Component {
  render() {
    return (
      <div>
        <h1>Name: {this.props.name}</h1>
        <p>Profession: {this.props.profession}</p>
      </div>
    );
  }
}

class App extends React.Component {
  render() {
    return (
      <div>
        <Profile name="Alice" profession="Engineer" />
        <Profile name="Bob" profession="Designer" />
      </div>
    );
  }
}

ReactDOM.render(<App />, document.getElementById("root"));
```

**Explanation**:

- **App** component থেকে **Profile** component এ **name** এবং **profession** props হিসেবে pass করা হয়েছে। প্রতিটি **Profile** component এ আলাদা আলাদা data pass করে বিভিন্ন content render করা হচ্ছে।

**Output**:

```
Name: Alice
Profession: Engineer

Name: Bob
Profession: Designer
```

---

### 8. Conclusion

React এর class components এ **props** ব্যবহার করলে data সহজে parent থেকে child component এ pass করা যায়। এটি component কে flexible এবং reusable করে তোলে, কারণ parent component dynamic data পাঠিয়ে component এর behavior customize করতে পারে। **Default props** এবং **prop types validation** ব্যবহার করে props এর type এবং মান নিশ্চিত করা যায়।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-08: Props in Functional Components

### Table of Contents:

1. [What are Props in React?](#what-are-props-in-react)
2. [Why are Props Important?](#why-are-props-important)
3. [How to Pass Props in React](#how-to-pass-props-in-react)
4. [Accessing Props in Components](#accessing-props-in-components)
5. [Default Props](#default-props)
6. [Props vs State](#props-vs-state)
7. [Real-life Example of Props](#real-life-example-of-props)
8. [Conclusion](#conclusion)

---

### 1. What are Props in React?

**Props** হলো React components এর external data যা parent component থেকে child component এ pass করা হয়। React এর **props** system component গুলোর মধ্যে data share এবং dynamic UI তৈরি করার অন্যতম প্রধান উপায়। **Props** immutable, অর্থাৎ component এর ভেতর থেকে props পরিবর্তন করা যায় না, বরং এটি শুধুমাত্র read-only data হিসেবে কাজ করে।

Props এর মাধ্যমে React components reusability বাড়ানো যায়, কারণ parent component থেকে child component এ বিভিন্ন data পাঠানো যায় এবং সেই অনুযায়ী render করা যায়।

##### Example of Props:

```jsx
function Greeting(props) {
  return <h1>Hello, {props.name}!</h1>;
}
```

এখানে **props.name** এর মাধ্যমে **name** নামক external data component এ dynamically প্রদর্শিত হচ্ছে।

---

### 2. Why are Props Important?

Props React এ **reusable** এবং **dynamic** component তৈরি করার জন্য অত্যন্ত গুরুত্বপূর্ণ। এগুলো parent-child component গুলোর মধ্যে data communication এর কাজ করে। Parent component থেকে props pass করলে, child component সেই props data ব্যবহার করে dynamic content তৈরি করতে পারে।

#### Key Reasons Props are Important:

- **Reusability**: Props ব্যবহার করে একই component কে বিভিন্ন data দিয়ে পুনরায় ব্যবহার করা যায়।
- **Dynamic Rendering**: Props এর মাধ্যমে dynamic data handle করা যায়, যা UI কে ব্যবহারকারীর action অনুযায়ী পরিবর্তিত করতে পারে।
- **Unidirectional Data Flow**: React এর props system parent থেকে child component এ data flow নিশ্চিত করে।

---

### 3. How to Pass Props in React

React component এ props pass করতে গেলে JSX attributes এর মতো syntax ব্যবহার করতে হয়। Parent component থেকে child component এ props pass করা খুবই সহজ এবং নিচের উদাহরণে তা দেখানো হয়েছে।

##### Example of Passing Props:

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}!</h1>;
}

const element = <Welcome name="John" />;
ReactDOM.render(element, document.getElementById("root"));
```

#### Explanation:

1. **Parent Component**: Parent component থেকে **name="John"** props হিসেবে pass করা হয়েছে।
2. **Child Component**: Child component (Welcome) **props.name** এর মাধ্যমে সেই data access করছে এবং JSX এর মধ্যে render করছে।

---

### 4. Accessing Props in Components

**Props** কে class component এবং function component দুটিতেই ব্যবহার করা যায়, কিন্তু দুটো component এ props access করার পদ্ধতি কিছুটা আলাদা।

#### Accessing Props in Function Components:

Function components এ **props** function এর argument হিসেবে access করা হয়।

##### Example:

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}!</h1>;
}
```

#### Accessing Props in Class Components:

Class components এ **this.props** ব্যবহার করে props access করা হয়।

##### Example:

```jsx
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}
```

---

### 5. Default Props

কিছু ক্ষেত্রে, component এ কোনো props pass না হলে default value set করা দরকার হতে পারে। এই ক্ষেত্রে React এর **defaultProps** feature ব্যবহার করা হয়।

##### Example of Default Props:

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}!</h1>;
}

Welcome.defaultProps = {
  name: "Guest",
};
```

#### Explanation:

এখানে **name** props pass না করা হলে, **'Guest'** default হিসেবে render হবে।

---

### 6. Props vs State

**Props** এবং **State** উভয়ই component এর data manage করতে ব্যবহৃত হয়, কিন্তু এদের মধ্যে কিছু গুরুত্বপূর্ণ পার্থক্য রয়েছে:

| **Props**                      | **State**                              |
| ------------------------------ | -------------------------------------- |
| Immutable                      | Mutable                                |
| Parent component থেকে pass হয় | Component এর ভেতরে declare করা হয়     |
| Read-only                      | Component এর ভেতর থেকে update করা যায় |
| Unidirectional data flow করে   | Component এর behavior handle করে       |

#### Key Differences:

- **Props** parent থেকে child component এ data pass করার জন্য ব্যবহৃত হয়।
- **State** component এর internal data যা dynamic এবং component এর behavior পরিবর্তন করতে সাহায্য করে।

---

### 7. Real-life Example of Props

ধরা যাক, আপনি একটি **Product Card** component তৈরি করতে চান, যেখানে product এর image, নাম, এবং মূল্য থাকবে। Props ব্যবহার করে parent component থেকে এই data child component এ pass করা হবে।

#### Example:

```jsx
function ProductCard(props) {
  return (
    <div className="product-card">
      <img src={props.image} alt={props.name} />
      <h2>{props.name}</h2>
      <p>Price: ${props.price}</p>
    </div>
  );
}

const product = {
  name: "Laptop",
  price: 1200,
  image: "https://example.com/laptop.jpg",
};

ReactDOM.render(
  <ProductCard
    name={product.name}
    price={product.price}
    image={product.image}
  />,
  document.getElementById("root")
);
```

#### Explanation:

1. **ProductCard Component**: এখানে **ProductCard** নামে একটি component তৈরি করা হয়েছে, যেখানে props এর মাধ্যমে **name**, **price**, এবং **image** pass করা হয়েছে।
2. **Parent Component**: Parent component থেকে product এর সমস্ত data props হিসেবে **ProductCard** component এ pass করা হচ্ছে।
3. **Rendering**: Product এর নাম, মূল্য এবং ছবি dynamic ভাবে render হচ্ছে।

---

### 8. Conclusion

React এর **Props** হলো component গুলোর মধ্যে data flow এবং communication এর অন্যতম প্রধান উপাদান। এটি component কে dynamic ভাবে render করতে এবং reusability বাড়াতে সাহায্য করে। Props immutable হওয়ায় component এর ভিতরে এটি পরিবর্তন করা যায় না, যা predictable এবং stable component তৈরি করতে সহায়ক।

Props এবং state একসাথে ব্যবহার করে complex এবং interactive UI তৈরি করা সম্ভব হয়।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-09: React State & Lifecycle in Class Components

### Table of Contents:

1. [What is State in React Class Components?](#what-is-state-in-react-class-components)
2. [What is Lifecycle in React Class Components?](#what-is-lifecycle-in-react-class-components)
3. [Managing State in Class Components](#managing-state-in-class-components)
   - [Setting Initial State](#setting-initial-state)
   - [Updating State with setState](#updating-state-with-setstate)
4. [React Class Component Lifecycle Phases](#react-class-component-lifecycle-phases)
   - [Mounting Phase](#mounting-phase)
   - [Updating Phase](#updating-phase)
   - [Unmounting Phase](#unmounting-phase)
5. [Common Lifecycle Methods](#common-lifecycle-methods)
   - [componentDidMount](#componentdidmount)
   - [componentDidUpdate](#componentdidupdate)
   - [componentWillUnmount](#componentwillunmount)
6. [Real-life Example: Timer with State and Lifecycle](#real-life-example-timer-with-state-and-lifecycle)
7. [Conclusion](#conclusion)

---

### 1. What is State in React Class Components?

**State** হলো React class component এর internal data, যা component এর behavior এবং appearance পরিবর্তনের জন্য dynamically manage করা হয়। Class components এ **state** এর মাধ্যমে component এ পরিবর্তন আসলে UI সেই অনুযায়ী update হয়। State এমন একটি JavaScript object যা component এর ভেতরে থাকে এবং component এর data বা UI control করতে সাহায্য করে।

##### Example of State:

```jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  render() {
    return <h1>Count: {this.state.count}</h1>;
  }
}
```

---

### 2. What is Lifecycle in React Class Components?

**Component lifecycle** হলো React component এর বিভিন্ন পর্যায় যা component এর creation থেকে destruction পর্যন্ত চলে। একটি React class component মূলত তিনটি ধাপে থাকে:

1. **Mounting**: Component DOM এ প্রথমবার insert হওয়ার সময়।
2. **Updating**: Component এর props বা state পরিবর্তিত হলে।
3. **Unmounting**: Component DOM থেকে remove হওয়ার সময়।

React এর lifecycle methods এই বিভিন্ন ধাপগুলোতে component এর behavior পরিচালনা করে। এই methods component এর বিভিন্ন পর্যায়ে execute হয়, যেমন component যখন render হয় বা destroy হয়।

---

### 3. Managing State in Class Components

#### Setting Initial State

Class component এর **constructor()** method এর মাধ্যমে initial state set করা হয়। **this.state** এর মাধ্যমে state এর initial value নির্ধারণ করা হয়।

##### Example of Initial State:

```jsx
class Greeting extends React.Component {
  constructor(props) {
    super(props);
    this.state = { message: "Hello, World!" };
  }

  render() {
    return <h1>{this.state.message}</h1>;
  }
}
```

#### Updating State with setState

State কে পরিবর্তন করতে হলে **this.setState()** method ব্যবহার করা হয়। এটি asynchronous ভাবে কাজ করে এবং state এর পরিবর্তন অনুযায়ী component re-render করে।

##### Example of Updating State:

```jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <h1>Count: {this.state.count}</h1>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}
```

#### Explanation:

1. **this.state**: Initial state set করার জন্য **this.state** ব্যবহার করা হয়েছে।
2. **this.setState()**: state update করার জন্য **this.setState()** method ব্যবহার করা হয়েছে এবং count increment করা হচ্ছে।

---

### 4. React Class Component Lifecycle Phases

React class component lifecycle তিনটি ধাপে বিভক্ত:

#### Mounting Phase

এই phase এ component DOM এ প্রথমবার insert হয়। কিছু common lifecycle methods হলো:

- **constructor()**
- **componentDidMount()**

#### Updating Phase

Component এর state বা props পরিবর্তিত হলে component update হয়। এই phase এ কিছু common lifecycle methods হলো:

- **shouldComponentUpdate()**
- **componentDidUpdate()**

#### Unmounting Phase

Component যখন DOM থেকে remove হয়, তখন এই phase শুরু হয়। একটি common lifecycle method হলো:

- **componentWillUnmount()**

---

### 5. Common Lifecycle Methods

#### componentDidMount

**componentDidMount** lifecycle method টি তখন execute হয় যখন component DOM এ প্রথমবার render হয়। এটি সাধারণত API calls বা external resources load করার জন্য ব্যবহার করা হয়।

##### Example:

```jsx
class Timer extends React.Component {
  componentDidMount() {
    this.timerID = setInterval(() => this.tick(), 1000);
  }

  tick() {
    console.log("Timer is running");
  }

  render() {
    return <h1>Timer Started</h1>;
  }
}
```

#### componentDidUpdate

**componentDidUpdate** method টি component update হওয়ার পরে execute হয়। এটি props বা state এর পরিবর্তন অনুযায়ী কাজ করতে পারে।

##### Example:

```jsx
class Counter extends React.Component {
  componentDidUpdate(prevProps, prevState) {
    if (this.state.count !== prevState.count) {
      console.log("Count updated");
    }
  }

  render() {
    return <h1>Updated Count: {this.state.count}</h1>;
  }
}
```

#### componentWillUnmount

**componentWillUnmount** method component destroy হওয়ার আগে execute হয়। এটি component এর resources (যেমন timers, subscriptions) clear করতে ব্যবহার করা হয়।

##### Example:

```jsx
class Timer extends React.Component {
  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  render() {
    return <h1>Timer Stopped</h1>;
  }
}
```

---

### 6. Real-life Example: Timer with State and Lifecycle

ধরা যাক, আপনি একটি timer component তৈরি করতে চান, যেখানে প্রতি সেকেন্ডে timer increment হবে এবং component destroy হলে timer বন্ধ হবে।

##### Example:

```jsx
class Timer extends React.Component {
  constructor(props) {
    super(props);
    this.state = { seconds: 0 };
  }

  componentDidMount() {
    this.timerID = setInterval(() => this.tick(), 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    this.setState({ seconds: this.state.seconds + 1 });
  }

  render() {
    return (
      <div>
        <h1>Timer: {this.state.seconds} seconds</h1>
      </div>
    );
  }
}

export default Timer;
```

#### Explanation:

1. **State Management**: Timer component এর state initial value হিসাবে 0 set করা হয়েছে।
2. **Lifecycle Methods**: **componentDidMount** method এর মাধ্যমে timer শুরু করা হয়েছে এবং **componentWillUnmount** method এর মাধ্যমে timer clear করা হয়েছে।
3. **State Update**: **this.setState()** method এর মাধ্যমে প্রতি সেকেন্ডে state update হচ্ছে এবং seconds value বাড়ানো হচ্ছে।

---

### 7. Conclusion

React class components এর **state** এবং **lifecycle methods** React এর অন্যতম প্রধান features, যা dynamic এবং interactive UI তৈরি করতে সাহায্য করে। **State** component এর internal data manage করতে সাহায্য করে, যেখানে **lifecycle methods** component এর lifecycle এর বিভিন্ন পর্যায়ে বিভিন্ন কাজ পরিচালনা করে।

State এবং lifecycle methods ব্যবহার করে আপনি complex functionality handle করতে পারেন, যেমন asynchronous operations (API calls), timers, এবং resource management। Class components এ state এবং lifecycle একসাথে কাজ করে component behavior এবং rendering process কে নিয়ন্ত্রণ করে, যা একটি powerful tool React developers এর জন্য।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-9.1: React State in Functional Components

## You will learn:

1. useState দিয়ে কিভাবে একটি state ভ্যারিয়েবল তৈরি করা যায়
2. useState হুক কোন দুইটি ভ্যারিয়েবল রিটার্ন করে
3. কিভাবে একাধিক state ভ্যারিয়েবল তৈরি করতে হয়
4. state কে কেন Local বলা হয়

## Table of Contents:

1. [State: A Component's Memory](#state-a-components-memory)

## State: A Component's Memory

- React এ State হল এমন একটা উপায় যার মাধ্যমে কম্পোনেন্ট তার তথ্য সংরক্ষণ করতে পারে যা সময়ের সাথে পরিবর্তিত হতে পারে। এটি কম্পোনেন্টের মেমোরি হিসেবে কাজ করে। উদাহরণস্বরূপ, যদি আপনার একটি to-do list অ্যাপ থাকে, তাহলে সেই কাজগুলোর তালিকা State এ সংরক্ষিত হয় এবং যখনই তালিকায় কোনো পরিবর্তন ঘটে, স্ক্রিনে সেই পরিবর্তন দেখানো হয়।

State হল কম্পোনেন্টের ভেতরের ডেটা যা user এর action বা অন্যান্য ফ্যাক্টরের উপর নির্ভর করে পরিবর্তিত হতে পারে। এটি আপনার অ্যাপকে dynamic এবং interactive করতে সাহায্য করে। State ছাড়া কম্পোনেন্টগুলোর আচার-ব্যবহার static হয়ে যেত এবং তারা কোনো user interaction এর প্রতিক্রিয়া জানাতে পারত না। State ব্যবহার করে আপনি আপনার অ্যাপের ডেটা এবং UI কে রিয়েল-টাইমে আপডেট রাখতে পারেন, যা user experience কে আরও ভালো করে তোলে।

কম্পোনেন্টগুলিকে প্রায়ই কোনো interaction এর ফলস্বরূপ স্ক্রিনে যা দেখানো হচ্ছে তা পরিবর্তন করতে হয়। ফর্মে টাইপ করা input field আপডেট করা উচিত, image carousel-এ "next" বাটনে ক্লিক করা হলে প্রদর্শিত ছবি পরিবর্তিত হওয়া উচিত, "buy" বাটনে ক্লিক করলে প্রোডাক্টটি shopping cart এ যুক্ত হওয়া উচিত। কম্পোনেন্টগুলোকে কিছু বিষয় "মনে রাখতে" হয়: বর্তমান input value, বর্তমান image, shopping cart। React এ, এই ধরনের কম্পোনেন্ট-নির্দিষ্ট মেমোরি কে state বলা হয়।

- ইন্টারেকশনের ফলে প্রায়ই কম্পোনেন্ট কে স্ক্রিনে যা আছে তা পরিবর্তন করতে হয়। ফর্মে টাইপ করলে ইনপুট ফিল্ড আপডেট হয়ে যাওয়া উচিত, ছবির ক্যারোসেল এর “next” এ ক্লিক করলে ডিসপ্লের ছবি বদলানো উচিত, “buy” এ ক্লিক করলে প্রোডাক্ট শপিং কার্ট এ যাওয়া উচিত। কম্পোনেন্ট এর কিছু জিনিস মনে রাখা উচিত, যেমন: বর্তমান ইনপুট ভ্যালু, বর্তমান ছবি, শপিং কার্ট। **React এর এমন কম্পোনেন্ট-ভিত্তিক মেমোরি কে state বলে।**

## যখন সাধারণ ভ্যারিয়েবল যথেষ্ট নয়



## When a regular variable isn’t enough

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-10: React Events

### Table of Contents:

1. [What are Events in React?](#what-are-events-in-react)
2. [How Events Work in React](#how-events-work-in-react)
3. [Handling Events in React](#handling-events-in-react)
4. [Event Handling in Functional and Class Components](#event-handling-in-functional-and-class-components)
5. [Passing Arguments to Event Handlers](#passing-arguments-to-event-handlers)
6. [Common React Event Types](#common-react-event-types)
   - [Click Events](#click-events)
   - [Form Events](#form-events)
   - [Keyboard Events](#keyboard-events)
7. [Real-life Example: Form Handling with Events](#real-life-example-form-handling-with-events)
8. [Conclusion](#conclusion)

---

### 1. What are Events in React?

**Events** React এ এমন কার্যকলাপ যেগুলো ব্যবহারকারী UI এর সাথে ইন্টারেক্ট করলে ট্রিগার হয়। উদাহরণস্বরূপ, button এ click করা, input field এ টাইপ করা, form submit করা — এসবই events। React events web browsers এর native DOM events এর উপর ভিত্তি করে কাজ করে, কিন্তু React events **camelCase** এ লেখা হয় এবং inline **JavaScript functions** বা **function references** এর মাধ্যমে handle করা হয়।

---

### 2. How Events Work in React

React এ event handling এর process কিছুটা আলাদা। Traditional DOM এর events যেমন `onclick`, `onchange` এগুলো lowercase এ লেখা হয়, কিন্তু React এ event attributes গুলো **camelCase** এ লিখতে হয় যেমন `onClick`, `onChange` ইত্যাদি। React events **synthetic events** নামে পরিচিত, যা native browser events এর উপর ভিত্তি করে তৈরি।

Synthetic events cross-browser compatibility নিশ্চিত করে এবং React এর Virtual DOM এর সাথে efficiently কাজ করে।

---

### 3. Handling Events in React

React এ events handle করতে হলে inline function অথবা function reference ব্যবহার করা হয়। একটি React event handling এর উদাহরণ নিচে দেখানো হলো।

##### Example of Event Handling:

```jsx
function ButtonClick() {
  const handleClick = () => {
    alert("Button was clicked!");
  };

  return <button onClick={handleClick}>Click Me</button>;
}
```

#### Explanation:

- **handleClick function**: এই function টি button এ click হলে execute হবে।
- **onClick event**: **onClick** event attribute এর মাধ্যমে **handleClick** function button এ click করার সাথে সাথে ট্রিগার হয়।

---

### 4. Event Handling in Functional and Class Components

React এ event handling class components এবং functional components এ কিছুটা আলাদা পদ্ধতিতে করা হয়। Functional components এ সরাসরি function declare করা হয়, যেখানে class components এ event handlers typically class methods এর মাধ্যমে handle করা হয়।

#### Event Handling in Functional Components:

```jsx
function Greeting() {
  const handleClick = () => {
    console.log("Hello!");
  };

  return <button onClick={handleClick}>Greet</button>;
}
```

#### Event Handling in Class Components:

```jsx
class Greeting extends React.Component {
  handleClick = () => {
    console.log("Hello!");
  };

  render() {
    return <button onClick={this.handleClick}>Greet</button>;
  }
}
```

#### Key Differences:

- **Functional Components**: সরাসরি function declaration এর মাধ্যমে events handle করা হয়।
- **Class Components**: **this** keyword ব্যবহার করে class methods এর মাধ্যমে events handle করা হয়।

---

### 5. Passing Arguments to Event Handlers

React এ event handlers এ arguments pass করা সম্ভব। React এর events automatically **event object** কে প্রথম argument হিসেবে pass করে, তবে আপনি custom arguments pass করতে চাইলে inline function বা arrow function ব্যবহার করতে পারেন।

##### Example of Passing Arguments:

```jsx
function ButtonClick() {
  const handleClick = (message) => {
    alert(message);
  };

  return (
    <button onClick={() => handleClick("Button was clicked!")}>Click Me</button>
  );
}
```

#### Explanation:

- **Arrow Function**: Inline arrow function ব্যবহার করে custom message pass করা হয়েছে।

---

### 6. Common React Event Types

React এ বিভিন্ন ধরনের events আছে, যেগুলো UI এর বিভিন্ন element এর সাথে ব্যবহার করা যায়। নিচে কিছু common event types এর উদাহরণ দেয়া হলো:

#### Click Events

Click event হল এমন একটি event যা button, link, বা যেকোনো clickable element এ ঘটে।

##### Example:

```jsx
<button onClick={() => alert("Button clicked!")}>Click Me</button>
```

#### Form Events

Form elements এর জন্য যেমন **input**, **select**, **textarea** — এগুলোতে **onChange**, **onSubmit** events ব্যবহার করা হয়।

##### Example:

```jsx
function Form() {
  const handleChange = (event) => {
    console.log(event.target.value);
  };

  return <input type="text" onChange={handleChange} placeholder="Type here" />;
}
```

#### Keyboard Events

Keyboard events ব্যবহার করে keyboard interaction handle করা যায়, যেমন key press করা।

##### Example:

```jsx
function KeyPress() {
  const handleKeyPress = (event) => {
    console.log(`Key pressed: ${event.key}`);
  };

  return <input type="text" onKeyPress={handleKeyPress} />;
}
```

---

### 7. Real-life Example: Form Handling with Events

ধরা যাক, আপনি একটি simple form তৈরি করতে চান যেখানে user এর নাম এবং email input field থাকবে এবং submit button এর মাধ্যমে form data handle করা হবে।

##### Example:

```jsx
import React, { useState } from "react";

function SimpleForm() {
  const [formData, setFormData] = useState({ name: "", email: "" });

  const handleChange = (event) => {
    const { name, value } = event.target;
    setFormData((prevData) => ({
      ...prevData,
      [name]: value,
    }));
  };

  const handleSubmit = (event) => {
    event.preventDefault();
    console.log("Form Submitted: ", formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Name:</label>
        <input
          type="text"
          name="name"
          value={formData.name}
          onChange={handleChange}
        />
      </div>
      <div>
        <label>Email:</label>
        <input
          type="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
        />
      </div>
      <button type="submit">Submit</button>
    </form>
  );
}

export default SimpleForm;
```

#### Explanation:

1. **useState Hook**: **useState** hook ব্যবহার করে form এর **name** এবং **email** state management করা হচ্ছে।
2. **handleChange function**: Input field এ কোন পরিবর্তন আসলে সেই data **handleChange** function এর মাধ্যমে state এ store হচ্ছে।
3. **handleSubmit function**: Form submit করার সময় **handleSubmit** function prevent করে browser এর default behavior এবং data console এ দেখানো হচ্ছে।

---

### 8. Conclusion

React এর ইভেন্ট সিস্টেম developer দের dynamic এবং interactive user interfaces তৈরি করতে সাহায্য করে। React এর **synthetic events** ব্রাউজারের বিভিন্ন incompatibility সমস্যা থেকে মুক্তি দেয় এবং একটি unified event handling system প্রদান করে। ইভেন্টগুলোর মাধ্যমে ব্যবহারকারীর actions যেমন **button click**, **keyboard input**, **form submission** ইত্যাদি handle করা হয়।

React এর **functional components** এবং **class components** উভয় ক্ষেত্রেই ইভেন্ট সহজে handle করা যায়। **Props** এর মাধ্যমে ফাংশনগুলো dynamic ভাবে ব্যবহার করা হয় এবং **state management** এর মাধ্যমে UI তে পরিবর্তন আনা হয়।

React এ ইভেন্ট handling এর সুবিধা হলো:

- ইভেন্টগুলো **camelCase** ফর্মেটে লেখা হয় এবং inline function বা reference ফাংশনের মাধ্যমে সহজেই ব্যবহার করা যায়।
- Cross-browser compatibility নিশ্চিত হয় এবং performance উন্নত হয়।

React ইভেন্টগুলো সম্পর্কে ভালো ধারণা থাকলে, interactive এবং responsive web applications তৈরি করা অনেক সহজ হয়ে যায়।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-11: React Conditional Rendering

### Table of Contents:

1. [What is Conditional Rendering?](#what-is-conditional-rendering)
2. [Importance of Conditional Rendering](#importance-of-conditional-rendering)
3. [Different Ways to Implement Conditional Rendering](#different-ways-to-implement-conditional-rendering)
   - [Using if/else Statements](#using-ifelse-statements)
   - [Using Ternary Operators](#using-ternary-operators)
   - [Using Logical && Operator](#using-logical--operator)
   - [Using Switch Statements](#using-switch-statements)
4. [Real-life Example of Conditional Rendering](#real-life-example-of-conditional-rendering)
5. [Best Practices for Conditional Rendering](#best-practices-for-conditional-rendering)
6. [Conclusion](#conclusion)

---

### 1. What is Conditional Rendering?

React এ **Conditional Rendering** মানে হলো component গুলো নির্দিষ্ট শর্তের (conditions) ভিত্তিতে UI তে render হয়। অর্থাৎ, শর্ত অনুযায়ী একটি component UI তে প্রদর্শিত হবে, না হলে অন্য কিছু দেখানো হবে। উদাহরণস্বরূপ, user login করা থাকলে তার profile দেখা যাবে, আর না থাকলে login form দেখানো হবে।

---

### 2. Importance of Conditional Rendering

React এ **Conditional Rendering** এর গুরুত্ব অনেক। এটি আমাদের dynamic এবং responsive UI তৈরি করতে সাহায্য করে। Web application এ user এর interaction, data এবং state এর উপর ভিত্তি করে UI বিভিন্ন ভাবে পরিবর্তন করা প্রয়োজন হয়। এই dynamic পরিবর্তনগুলি Conditional Rendering এর মাধ্যমে সহজেই সম্ভব।

উদাহরণস্বরূপ, একটি e-commerce site এ user logged in থাকলে তার order history দেখানো হয়, আর logged in না থাকলে তাকে login করতে বলা হয়। এছাড়াও, যদি কোনো API call থেকে data fetch করতে সময় লাগে, তখন loader দেখানো হয় এবং data পাওয়ার পর result দেখানো হয়।

---

### 3. Different Ways to Implement Conditional Rendering

#### Using if/else Statements

Traditional **if/else** statement ব্যবহার করে React এ সহজেই conditional rendering করা যায়। তবে এই statements JSX এর মধ্যে ব্যবহার করা সম্ভব নয়, তাই function এর ভেতরে রাখতে হয়।

##### Example:

```jsx
function Greeting(props) {
  if (props.isLoggedIn) {
    return <h1>Welcome back!</h1>;
  } else {
    return <h1>Please sign up.</h1>;
  }
}

ReactDOM.render(
  <Greeting isLoggedIn={true} />,
  document.getElementById("root")
);
```

#### Breakdown:

- **if/else Statement**: এখানে **props.isLoggedIn** এর মান চেক করা হচ্ছে। যদি true হয়, তাহলে "Welcome back!" দেখানো হচ্ছে। না হলে "Please sign up."।
- Output:
  - যদি **isLoggedIn** true হয়: **"Welcome back!"**
  - যদি **isLoggedIn** false হয়: **"Please sign up."**

#### Using Ternary Operators

**Ternary operator** React এ conditional rendering এর জন্য সবচেয়ে সংক্ষিপ্ত উপায়। এটি একই কোড আরও ছোট করে লিখতে সাহায্য করে।

##### Example:

```jsx
function Greeting(props) {
  return (
    <div>
      {props.isLoggedIn ? <h1>Welcome back!</h1> : <h1>Please sign up.</h1>}
    </div>
  );
}

ReactDOM.render(
  <Greeting isLoggedIn={false} />,
  document.getElementById("root")
);
```

#### Breakdown:

- **Ternary Operator**: এক লাইনে condition check করে "Welcome back!" বা "Please sign up." দেখানো হচ্ছে।
- Output:
  - যদি **isLoggedIn** true হয়: **"Welcome back!"**
  - যদি **isLoggedIn** false হয়: **"Please sign up."**

#### Using Logical && Operator

**Logical && operator** React এ এমন শর্ত ব্যবহারের জন্য উপযুক্ত যেখানে কোনো শর্ত true হলে শুধুমাত্র একটি অংশ render হবে।

##### Example:

```jsx
function Greeting(props) {
  return <div>{props.isLoggedIn && <h1>Welcome back!</h1>}</div>;
}

ReactDOM.render(
  <Greeting isLoggedIn={true} />,
  document.getElementById("root")
);
```

#### Breakdown:

- **Logical && operator**: এখানে **props.isLoggedIn** true হলে "Welcome back!" দেখানো হচ্ছে। যদি false হয়, কিছুই render হবে না।
- Output:
  - যদি **isLoggedIn** true হয়: **"Welcome back!"**
  - যদি **isLoggedIn** false হয়: **(কিছুই দেখাবে না)**

#### Using Switch Statements

যখন একাধিক শর্ত থাকে, তখন **switch statement** ব্যবহার করা হয়। এটি বড় বড় conditions সহজে handle করতে সাহায্য করে।

##### Example:

```jsx
function Greeting(props) {
  switch (props.status) {
    case "guest":
      return <h1>Welcome, Guest!</h1>;
    case "user":
      return <h1>Welcome back!</h1>;
    case "admin":
      return <h1>Welcome, Admin!</h1>;
    default:
      return <h1>Hello!</h1>;
  }
}

ReactDOM.render(<Greeting status="admin" />, document.getElementById("root"));
```

#### Breakdown:

- **Switch Statement**: এখানে **props.status** চেক করে বিভিন্ন greeting message দেখানো হচ্ছে। যেমন, guest এর জন্য "Welcome, Guest!" এবং admin এর জন্য "Welcome, Admin!"।
- Output:
  - **status** "admin" হলে: **"Welcome, Admin!"**
  - **status** "guest" হলে: **"Welcome, Guest!"**
  - অন্য কোনো status থাকলে: **"Hello!"**

---

### 4. Real-life Example of Conditional Rendering

একটি বাস্তব উদাহরণে ধরুন, একটি **E-commerce Dashboard** রয়েছে, যেখানে user logged in থাকলে তার নাম এবং recent order গুলো দেখানো হবে, আর logged in না থাকলে তাকে login করতে বলবে।

##### Example:

```jsx
function UserDashboard(props) {
  if (props.isLoggedIn) {
    return (
      <div>
        <h1>Welcome back, {props.userName}!</h1>
        <p>Here are your recent orders:</p>
        {/* Order details */}
      </div>
    );
  } else {
    return (
      <div>
        <h1>Please log in to view your dashboard.</h1>
        <button onClick={props.onLogin}>Login</button>
      </div>
    );
  }
}

ReactDOM.render(
  <UserDashboard
    isLoggedIn={false}
    userName="John"
    onLogin={() => alert("Logging in...")}
  />,
  document.getElementById("root")
);
```

#### Breakdown:

- **isLoggedIn চেক করা হচ্ছে**: যদি user logged in থাকে, তার নাম এবং order details দেখানো হবে। আর না থাকলে login button দেখানো হবে।
- **Output**:
  - যদি **isLoggedIn = true** হয়, তাহলে দেখাবে:
    ```
    Welcome back, John!
    Here are your recent orders.
    ```
  - যদি **isLoggedIn = false** হয়, তাহলে দেখাবে:
    ```
    Please log in to view your dashboard.
    [Login Button]
    ```

---

### 5. Best Practices for Conditional Rendering

1. **Simple Logic ব্যবহার করুন**: Complex conditional rendering এর জন্য কোডকে যতটা সম্ভব সহজ রাখা উচিত। ছোট শর্তগুলির জন্য **ternary operator** এবং **&& operator** ব্যবহার করতে পারেন। উদাহরণস্বরূপ, একটি খুব ছোট condition এর জন্য একাধিক **if/else** না করে **ternary operator** ব্যবহার করতে পারেন।
2. **Nested JSX এড়িয়ে চলুন**: Nested JSX অনেক ক্ষেত্রে পড়তে এবং বোঝাতে জটিল হয়ে যায়। এর চেয়ে ভালো উপায় হলো subcomponents তৈরি করা।

3. **Switch Statement ব্যবহার করুন**: যখন একাধিক শর্ত রয়েছে, তখন **switch statement** ব্যবহার করলে কোড সহজ এবং পরিষ্কার হয়।

---

### 6. Conclusion

React এর **Conditional Rendering** একটি শক্তিশালী ফিচার, যা UI কে dynamic এবং responsive করতে সাহায্য করে। এই পদ্ধতিতে আপনি user এর state বা props এর উপর ভিত্তি করে UI এর বিভিন্ন অংশকে পরিবর্তন করতে পারেন। React এ conditional rendering এর বিভিন্ন পদ্ধতি রয়েছে, যেমন **if/else**, **ternary operators**, **&& operator**, এবং **switch statement**। প্রতিটি পদ্ধতি situation অনুযায়ী উপযোগী, তবে সবসময় কোডকে সহজ এবং পরিষ্কার রাখার চেষ্টা করা উচিত।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-11.1: React List & Keys 

## Table of Contents
1. [Introduction to Lists & Keys](#introduction-to-lists--keys)
2. [Why Use Lists & Keys in React?](#why-use-lists--keys-in-react)
3. [Rendering Lists with the `map()` Function](#rendering-lists-with-the-map-function)
4. [Understanding Keys in React](#understanding-keys-in-react)
5. [Examples - Beginner to Advanced](#examples---beginner-to-advanced)
6. [Best Practices for Lists & Keys](#best-practices-for-lists--keys)

---

### 1. 📘 Introduction to Lists & Keys

React এ **Lists** এবং **Keys** concepts component এর মধ্যে data render করতে ব্যবহৃত হয়। Lists React কে multiple similar data items manage করতে সাহায্য করে, যেখানে Keys React কে প্রতিটি item কে track এবং update করতে সহায়ক।

---

### 2. 🧐 Why Use Lists & Keys in React?

React এ lists এবং keys ব্যবহার করলে dynamic এবং efficient data rendering সহজ হয়। কিছু গুরুত্বপূর্ণ কারণ হলো:
- **Dynamic Data Handling**: Lists ব্যবহার করে dynamic content সহজে display করা যায়।
- **Optimized Rendering**: Keys এর মাধ্যমে React component update এবং re-render efficiently manage করতে পারে।

---

### 3. 🔄 Rendering Lists with the `map()` Function

React এ list rendering করতে `map()` ফাংশন ব্যবহার করা হয়। এটি একটি নতুন array return করে এবং array এর প্রতিটি element কে React element এ রূপান্তর করে।

```javascript
const items = ["Apple", "Banana", "Cherry"];

function ItemList() {
  return (
    <ul>
      {items.map((item) => (
        <li>{item}</li>
      ))}
    </ul>
  );
}
```

---

### 4. 🗝️ Understanding Keys in React

Keys React এর জন্য unique identifiers যা list items এর re-rendering efficiency বাড়াতে সাহায্য করে। Keys unique এবং stable হওয়া উচিত, যেন React সহজে items track করতে পারে।

---

### 5. 📖 Examples - Beginner to Advanced

---

#### Example 1: Basic List Rendering with Keys (Beginner)

এই উদাহরণে, একটি simple list render করা হয়েছে এবং প্রতিটি item এর জন্য unique key ব্যবহার করা হয়েছে।

```javascript
import React from 'react';

const fruits = [
  { id: 1, name: "Apple" },
  { id: 2, name: "Banana" },
  { id: 3, name: "Cherry" },
];

function FruitList() {
  return (
    <ul>
      {fruits.map((fruit) => (
        <li key={fruit.id}>{fruit.name}</li>
      ))}
    </ul>
  );
}

export default FruitList;
```

**Explanation**:
- `fruits` array এর প্রতিটি item কে `id` attribute এর মাধ্যমে key হিসেবে দেওয়া হয়েছে।
- Key ব্যবহার করে React efficiently items track করতে পারে এবং unnecessary re-renders এড়াতে পারে।

---

#### Example 2: Dynamic List with Conditional Rendering (Intermediate)

Dynamic data এবং conditional rendering এর জন্য নিচের উদাহরণটি দেখা যাক।

```javascript
import React from 'react';

const products = [
  { id: 101, name: "Laptop", price: 999.99, isAvailable: true },
  { id: 102, name: "Smartphone", price: 699.99, isAvailable: false },
  { id: 103, name: "Tablet", price: 499.99, isAvailable: true },
];

function ProductList() {
  return (
    <ul>
      {products.map((product) => (
        <li key={product.id}>
          <h3>{product.name}</h3>
          <p>Price: ${product.price}</p>
          <p>
            {product.isAvailable ? (
              <span style={{ color: 'green' }}>In Stock</span>
            ) : (
              <span style={{ color: 'red' }}>Out of Stock</span>
            )}
          </p>
        </li>
      ))}
    </ul>
  );
}

export default ProductList;
```

**Explanation**:
1. **Nested Data**: `products` array এর প্রতিটি item এ name, price, এবং availability status রয়েছে।
2. **Conditional Rendering**: Availability এর উপর ভিত্তি করে stock status green অথবা red color এ দেখানো হয়েছে।
3. **Unique Key**: `id` কে key হিসেবে ব্যবহার করা হয়েছে, যা React কে items efficiently track করতে সাহায্য করে।

---

#### Example 3: List Rendering from API Data (Advanced)

ধরুন, আমাদের কাছে একটি external API থেকে data আসছে যা আমরা list এ render করব।

```javascript
import React, { useEffect, useState } from 'react';

function UserList() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetch("https://jsonplaceholder.typicode.com/users")
      .then(response => response.json())
      .then(data => setUsers(data))
      .catch(error => console.error("Error fetching data:", error));
  }, []);

  return (
    <div>
      <h2>User List</h2>
      <ul>
        {users.map((user) => (
          <li key={user.id}>
            <h3>{user.name}</h3>
            <p>Email: {user.email}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}

export default UserList;
```

**Explanation**:
1. **Data Fetching**: API থেকে data fetch করে `users` state এ সংরক্ষণ করা হয়েছে।
2. **Unique Keys with API Data**: API থেকে আসা data এর `id` কে unique key হিসেবে ব্যবহার করা হয়েছে।
3. **Real-Time Update**: Data fetch হওয়ার পর `users` state update হয় এবং UI তে list render হয়।

---

### 6. ✅ Best Practices for Lists & Keys

1. **Use Unique and Stable Keys**: প্রতিটি item এর জন্য unique `id` ব্যবহার করা উচিত।
2. **Avoid Using Array Index**: Index কে key হিসেবে ব্যবহার না করা ভালো, কারণ এটি list এর order পরিবর্তনের সময় সমস্যা তৈরি করতে পারে।
3. **Use `map()` for Lists**: `map()` ফাংশন ব্যবহার করে lists render করা React এ একটি common practice।
4. **Avoid Inline Key Generation Functions**: Inline functions performance কমিয়ে দিতে পারে, তাই avoid করা উচিত।

---

### সংক্ষেপে

React এ Lists এবং Keys application এর efficiency এবং manageability বাড়ায়। Keys এর মাধ্যমে React effectively items track এবং unnecessary re-renders এড়াতে পারে। Properly managed lists এবং keys ব্যবহার করলে React application এর performance এবং maintainability অনেক সহজ হয়ে যায়। 

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-11.2: 📋 React Form Handling - Controlled vs Uncontrolled Components

## Table of Contents
1. [Introduction to Form Handling in React](#introduction-to-form-handling-in-react)
2. [What are Controlled Components?](#what-are-controlled-components)
3. [What are Uncontrolled Components?](#what-are-uncontrolled-components)
4. [Controlled vs Uncontrolled Components - Key Differences](#controlled-vs-uncontrolled-components---key-differences)
5. [Examples of Controlled and Uncontrolled Components](#examples-of-controlled-and-uncontrolled-components)
6. [Best Practices in Form Handling](#best-practices-in-form-handling)

---

### 1. 📘 Introduction to Form Handling in React

React এ form handling user input সংগ্রহ এবং data প্রসেস করার একটি গুরুত্বপূর্ণ অংশ। React এ form handling প্রধানত দুটি উপায়ে করা যায়:
- **Controlled Components**: যেখানে form এর data React এর state দ্বারা নিয়ন্ত্রিত হয়।
- **Uncontrolled Components**: যেখানে form এর data সরাসরি DOM এর মাধ্যমে access করা হয়।

প্রতিটি পদ্ধতির নিজস্ব সুবিধা এবং ব্যবহার ক্ষেত্র রয়েছে, যা ভিন্ন পরিস্থিতিতে উপযুক্ত। Controlled এবং Uncontrolled Components এর পার্থক্য বোঝা React এ form handling আরও কার্যকরভাবে পরিচালনা করতে সাহায্য করে।

---

### 2. 📝 What are Controlled Components?

**Controlled Components** হলো এমন একটি React component যেখানে form এর values গুলো সম্পূর্ণভাবে React এর state দ্বারা নিয়ন্ত্রিত হয়। প্রতিটি input field এর মান React এর state এ সংরক্ষণ করা হয় এবং এই state এর উপর ভিত্তি করে UI এবং data সম্পূর্ণরূপে synchronized থাকে। 

#### Key Points:
- Form values React এর state এ সংরক্ষিত থাকে।
- প্রতিটি পরিবর্তনের জন্য একটি `onChange` event trigger হয় যা state update করে।
- এই পদ্ধতিতে React UI এবং data কে সম্পূর্ণরূপে synchronized রাখে।

#### Example: Controlled Component

```javascript
import React, { useState } from 'react';

function ControlledForm() {
  const [name, setName] = useState('');

  const handleChange = (event) => {
    setName(event.target.value);
  };

  const handleSubmit = (event) => {
    event.preventDefault();
    console.log("Submitted name:", name);
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Name:
        <input type="text" value={name} onChange={handleChange} />
      </label>
      <button type="submit">Submit</button>
    </form>
  );
}

export default ControlledForm;
```

**ব্যাখ্যা**:
- `name` state variable form input এর বর্তমান মান সংরক্ষণ করে।
- `handleChange` ফাংশনের মাধ্যমে প্রতিবার input field এ পরিবর্তন ঘটলে `name` state update হয়।
- `value={name}` attribute input এর মান React এর state এর সাথে সংযুক্ত করে, যা এই component কে একটি Controlled Component এ পরিণত করে।

---

### 3. 🔍 What are Uncontrolled Components?

**Uncontrolled Components** এমন একটি পদ্ধতি যেখানে form এর values সরাসরি DOM থেকে access করা হয় `ref` ব্যবহার করে। এই পদ্ধতিতে data React এর state এ সংরক্ষণ না করে সরাসরি DOM থেকে সংগ্রহ করা হয় এবং এটি traditional HTML form এর মতো কাজ করে।

#### Key Points:
- Form values React এর state এ সংরক্ষণ না করে সরাসরি DOM থেকে access করা হয়।
- Input fields এর জন্য `ref` attribute ব্যবহার করে values access করা হয়।
- সাধারণ forms অথবা third-party libraries এর ক্ষেত্রে Uncontrolled Components দ্রুত এবং সহজ।

#### Example: Uncontrolled Component

```javascript
import React, { useRef } from 'react';

function UncontrolledForm() {
  const nameRef = useRef();

  const handleSubmit = (event) => {
    event.preventDefault();
    console.log("Submitted name:", nameRef.current.value);
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Name:
        <input type="text" ref={nameRef} />
      </label>
      <button type="submit">Submit</button>
    </form>
  );
}

export default UncontrolledForm;
```

**ব্যাখ্যা**:
- `nameRef` তৈরি করে `ref` attribute এর মাধ্যমে input field এর মান সরাসরি DOM থেকে access করা হয়েছে।
- এখানে কোনো `onChange` handler এর প্রয়োজন নেই, বরং `nameRef.current.value` এর মাধ্যমে input field এর মান সরাসরি পড়া হচ্ছে।

---

### 4. 🔄 Controlled vs Uncontrolled Components - Key Differences

| বৈশিষ্ট্য                   | Controlled Components                              | Uncontrolled Components                           |
|-----------------------------|----------------------------------------------------|--------------------------------------------------|
| **Data Handling**           | React এর state দ্বারা নিয়ন্ত্রিত                      | সরাসরি DOM থেকে access করা হয়                     |
| **Control Over Input**      | React এর মাধ্যমে পূর্ণ নিয়ন্ত্রণ থাকে                 | DOM এর মাধ্যমে নিয়ন্ত্রিত                             |
| **Real-time Validation**    | সহজে করা যায় কারণ data সরাসরি state এ থাকে          | কঠিন কারণ values `ref` এর মাধ্যমে access করতে হয়     |
| **Use Case**                | Dynamic এবং complex forms                           | Simple forms অথবা third-party libraries এর সাথে ব্যবহৃত |
| **Performance**             | সামান্য ধীর কারণ state ব্যবস্থাপনা দরকার                | দ্রুত, কারণ state এর প্রয়োজন হয় না এবং সরাসরি DOM access করা যায় |

---

### 5. 📖 Examples of Controlled and Uncontrolled Components

---

#### Example 1: Controlled Component with Multiple Inputs

এখানে একটি form রয়েছে যেখানে multiple input fields আছে (name এবং email), এবং প্রতিটি input field এর মান React এর state দ্বারা নিয়ন্ত্রিত।

```javascript
import React, { useState } from 'react';

function ControlledMultiInputForm() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
  });

  const handleChange = (event) => {
    const { name, value } = event.target;
    setFormData((prevData) => ({
      ...prevData,
      [name]: value,
    }));
  };

  const handleSubmit = (event) => {
    event.preventDefault();
    console.log("Form Data:", formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Name:
        <input type="text" name="name" value={formData.name} onChange={handleChange} />
      </label>
      <label>
        Email:
        <input type="email" name="email" value={formData.email} onChange={handleChange} />
      </label>
      <button type="submit">Submit</button>
    </form>
  );
}

export default ControlledMultiInputForm;
```

**ব্যাখ্যা**:
- `formData` state এ `name` এবং `email` values আলাদাভাবে সংরক্ষণ করা হয়েছে।
- `handleChange` ফাংশন dynamically state update করতে সাহায্য করে এবং প্রতিটি input এর মান state এর সাথে synchronized থাকে।

---

#### Example 2: Uncontrolled Component with Multiple Inputs

এখানে multiple input fields এর মান সরাসরি DOM থেকে access করা হয়েছে `ref` attribute ব্যবহার করে।

```javascript
import React, { useRef } from 'react';

function UncontrolledMultiInputForm() {
  const nameRef = useRef();
  const emailRef = useRef();

  const handleSubmit = (event) => {
    event.preventDefault();
    console.log("Submitted Name:", nameRef.current.value);
    console.log("Submitted Email:", emailRef.current.value);
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Name:
        <input type="text" ref={nameRef} />
      </label>
      <label>
        Email:
        <input type="email" ref={emailRef} />
      </label>
      <button type="submit">Submit</button>
    </form>
  );
}

export default UncontrolledMultiInputForm;
```

**ব্যাখ্যা**:
- `nameRef` এবং `emailRef` ব্যবহার করে DOM থেকে সরাসরি input values access করা হয়েছে।
- Uncontrolled Components দ্রুত এবং সহজ কারণ এখানে state update করার প্রয়োজন নেই।

---

### 6. ✅ Best Practices in Form Handling

1. **Complex Forms এর জন্য Controlled Components ব্যবহার করুন**: Dynamic forms যেখানে validation এবং real-time updates দরকার সেক্ষেত্রে controlled components কার্যকর।
2. **Simple Forms এর জন্য Uncontrolled Components ব্যবহার করুন**: ছোট এবং সহজ forms এর ক্ষেত্রে uncontrolled components দ্রুত এবং সহজ পদ্ধতি।
3. **Separate Components for Better Management**: বড় forms এর ক্ষেত্রে প্রতিটি input field কে আলাদা component হিসেবে consider করা উত্তম।
4. **Avoid Mixing Controlled and Uncontrolled Approaches**: একই ফর্মে controlled এবং uncontrolled পদ্ধতি একসাথে ব্যবহার না করাই ভালো, কারণ এতে অপ্রত্যাশিত behavior হতে পারে।

---

### Summary

React এ **Controlled Components** state ব্যবহার করে form data manage করে, যেখানে **Uncontrolled Components** সরাসরি DOM থেকে data access করে। Complex এবং dynamic forms এর জন্য controlled components উপযুক্ত, তবে simple forms এর ক্ষেত্রে uncontrolled components দ্রুত এবং efficient। Controlled এবং Uncontrolled পদ্ধতির পার্থক্যগুলো বুঝে উপযুক্ত পদ্ধতি বেছে নেয়া form handling কে আরো কার্যকর এবং দক্ষ করে। 😊

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-11.3: 📋 React Lifting State Up

## Table of Contents
1. [Introduction to Lifting State Up](#introduction-to-lifting-state-up)
2. [Why Use Lifting State Up?](#why-use-lifting-state-up)
3. [How Lifting State Up Works in React](#how-lifting-state-up-works-in-react)
4. [Examples - Beginner to Advanced](#examples---beginner-to-advanced)
    - [Example 1: Synchronized Temperature Inputs (Beginner)](#example-1-synchronized-temperature-inputs-beginner)
    - [Example 2: Shopping Cart Quantity Sync (Intermediate)](#example-2-shopping-cart-quantity-sync-intermediate)
    - [Example 3: Form Input Sync with Validation (Advanced)](#example-3-form-input-sync-with-validation-advanced)
5. [Best Practices for Lifting State Up](#best-practices-for-lifting-state-up)

---

### 1. 📘 Introduction to Lifting State Up

**Lifting State Up** হলো একটি React প্যাটার্ন যেখানে state কে component tree এর একটি higher level এ নিয়ে যাওয়া হয়, যাতে একাধিক child component সেই state access করতে পারে। যখন একাধিক component একই data share করতে চায় বা একটি component এর পরিবর্তন অন্য component এ reflect করতে চায়, তখন state কে parent বা common ancestor component এ move করা হয়। এই প্রক্রিয়াকে lifting state up বলা হয়।

#### State Lifting এর মূল ধারণা:
- **Centralized State Management**: State কে common ancestor component এ নিয়ে যাওয়া, যা child component গুলোর মধ্যে data consistency এবং synchronization নিশ্চিত করে।
- **Component Communication**: Lifting state up parent-child component এর মধ্যে data passing কে সহজ করে।

---

### 2. 🧐 Why Use Lifting State Up?

React এ lifting state up ব্যবহারের প্রধান কারণ হলো **data synchronization** এবং **consistent UI**। নিচে কিছু গুরুত্বপূর্ণ কারণ উল্লেখ করা হলো:

1. **Consistent Data Across Components**: যখন একাধিক component একই data ব্যবহার করে, তখন lifting state up এর মাধ্যমে তাদের মধ্যে synchronized data রাখা যায়।
2. **Improves Data Flow**: Component গুলোর মধ্যে props এর মাধ্যমে data pass করে data flow সরল করা যায়।
3. **Centralized State Management**: একই data এর জন্য বিভিন্ন component এ আলাদা state ব্যবহারের পরিবর্তে এক স্থানে state রাখা সহজ ও maintainable করে তোলে।
4. **Easier Data Sharing**: একাধিক component এ data flow এবং synchronization সহজ হয়ে যায়।

---

### 3. 🔍 How Lifting State Up Works in React

#### Steps for Lifting State Up:
1. **Identify Shared State**: প্রথমে দেখে নিন কোন state একাধিক component এ ব্যবহার হবে।
2. **Move State to Parent Component**: Shared state কে parent component এ নিয়ে আসুন, যেটি common ancestor হিসেবে কাজ করবে।
3. **Pass State and Update Function as Props**: Parent component এর state এবং update function কে child component এ props হিসেবে pass করুন।
4. **Use Props in Child Components**: Child component এ parent থেকে আসা state এবং update function ব্যবহার করুন।

---

### 4. 📖 Examples - Beginner to Advanced

---

#### Example 1: Synchronized Temperature Inputs (Beginner)

ধরুন, আমাদের একটি temperature converter আছে যেখানে Celsius এবং Fahrenheit এর মধ্যে conversion হবে। এখানে দুটি input field থাকবে, যেকোনো একটিতে পরিবর্তন করলে অন্যটি automatically update হবে। আমরা lifting state up এর মাধ্যমে temperature data এবং conversion logic centralize করব।

##### Step 1: TemperatureInput Component

```javascript
import React from 'react';

function TemperatureInput({ scale, temperature, onTemperatureChange }) {
  const scaleNames = { c: "Celsius", f: "Fahrenheit" };

  const handleChange = (event) => {
    onTemperatureChange(event.target.value);
  };

  return (
    <div>
      <label>Enter temperature in {scaleNames[scale]}:</label>
      <input value={temperature} onChange={handleChange} />
    </div>
  );
}

export default TemperatureInput;
```

**Explanation**:
- `TemperatureInput` একটি reusable component যা `scale` (Celsius বা Fahrenheit), `temperature` (temperature value), এবং `onTemperatureChange` (temperature update function) props হিসেবে গ্রহণ করে।
- `handleChange` function এর মাধ্যমে temperature পরিবর্তন হলে `onTemperatureChange` function call করা হয়।

##### Step 2: Temperature Conversion Functions

```javascript
function toCelsius(fahrenheit) {
  return (fahrenheit - 32) * 5 / 9;
}

function toFahrenheit(celsius) {
  return (celsius * 9 / 5) + 32;
}

export { toCelsius, toFahrenheit };
```

**Explanation**:
- `toCelsius` এবং `toFahrenheit` function ব্যবহার করে Fahrenheit থেকে Celsius এবং Celsius থেকে Fahrenheit এ temperature conversion করা হয়।

##### Step 3: TemperatureCalculator Parent Component

```javascript
import React, { useState } from 'react';
import TemperatureInput from './TemperatureInput';
import { toCelsius, toFahrenheit } from './conversions';

function TemperatureCalculator() {
  const [temperature, setTemperature] = useState("");
  const [scale, setScale] = useState("c");

  const handleCelsiusChange = (temp) => {
    setTemperature(temp);
    setScale("c");
  };

  const handleFahrenheitChange = (temp) => {
    setTemperature(temp);
    setScale("f");
  };

  const celsius = scale === "f" ? toCelsius(temperature) : temperature;
  const fahrenheit = scale === "c" ? toFahrenheit(temperature) : temperature;

  return (
    <div>
      <TemperatureInput
        scale="c"
        temperature={celsius}
        onTemperatureChange={handleCelsiusChange}
      />
      <TemperatureInput
        scale="f"
        temperature={fahrenheit}
        onTemperatureChange={handleFahrenheitChange}
      />
    </div>
  );
}

export default TemperatureCalculator;
```

**Explanation**:
1. **Lifting State Up**: `temperature` এবং `scale` state কে common parent component `TemperatureCalculator` এ initialize করা হয়েছে।
2. **Passing Props**: `TemperatureInput` component গুলিতে `temperature`, `scale`, এবং `onTemperatureChange` props হিসেবে pass করা হয়েছে।
3. **Data Synchronization**: `TemperatureInput` এর মাধ্যমে input temperature change করলে `handleCelsiusChange` বা `handleFahrenheitChange` function call হয়, যা updated temperature value এবং scale set করে। State change হলে parent component `TemperatureCalculator` re-render হয় এবং অন্য input field এ updated value display করে।

---

#### Example 2: Shopping Cart Quantity Sync (Intermediate)

ধরুন, একটি shopping cart এ item quantity update করার জন্য একটি input field এবং total quantity display করার জন্য একটি component আছে। State lift করে আমরা quantity update এবং display একসাথে sync করব।

##### Step 1: QuantityInput Component

```javascript
import React from 'react';

function QuantityInput({ quantity, onQuantityChange }) {
  return (
    <input
      type="number"
      value={quantity}
      onChange={(e) => onQuantityChange(parseInt(e.target.value) || 0)}
    />
  );
}

export default QuantityInput;
```

**Explanation**:
- `QuantityInput` একটি input component যা user এর quantity input গ্রহণ করে এবং `onQuantityChange` function call করে parent component এ quantity পাঠায়।

##### Step 2: CartDisplay Component

```javascript
import React from 'react';

function CartDisplay({ quantity }) {
  return <p>Total Quantity: {quantity}</p>;
}

export default CartDisplay;
```

**Explanation**:
- `CartDisplay` component শুধু total quantity display করে। Quantity value props হিসেবে parent component থেকে পাঠানো হয়।

##### Step 3: ShoppingCart Parent Component

```javascript
import React, { useState } from 'react';
import QuantityInput from './QuantityInput';
import CartDisplay from './CartDisplay';

function ShoppingCart() {
  const [quantity, setQuantity] = useState(0);

  return (
    <div>
      <QuantityInput quantity={quantity} onQuantityChange={setQuantity} />
      <CartDisplay quantity={quantity} />
    </div>
  );
}

export default ShoppingCart;
```

**Explanation**:
1. **Lifting State Up**: `quantity` state কে `ShoppingCart` component এ lift করা হয়েছে।
2. **Passing Props**: `QuantityInput` এবং `CartDisplay` component গুলিতে `quantity` state এবং `setQuantity` function pass করা হয়েছে।
3. **State Synchronization**: User quantity update করলে `setQuantity` call হয়, যা updated quantity `CartDisplay` component এ automatically reflect করে।

---

#### Example 3: Form Input Sync with Validation (Advanced)

ধরুন, আমাদের একটি multi-field form আছে যেখানে বিভিন্ন input field এর মধ্যে data synchronization এবং validation দরকার।

##### Step 1: FormInput Component

```javascript
import React from 'react';

function FormInput({ label, value, onChange, error }) {
  return (
    <div>
      <label>{label}</label>
      <input value={value} onChange={onChange} />
      {error && <p style={{ color: 'red' }}>{error}</p>}
    </div>
  );
}

export default FormInput;
```

**Explanation**:
- `FormInput` একটি reusable component যা `label`, `value`, `onChange`, এবং `error` props গ্রহণ করে।
- Error থাকলে এটি error message display করে।

##### Step 2: Parent Form Component with Validation

```javascript
import React, { useState } from 'react';
import FormInput from './Form

Input';

function Form() {
  const [username, setUsername] = useState("");
  const [email, setEmail] = useState("");
  const [errors, setErrors] = useState({ username: "", email: "" });

  const handleUsernameChange = (e) => {
    const value = e.target.value;
    setUsername(value);
    setErrors((prevErrors) => ({
      ...prevErrors,
      username: value.length < 3 ? "Username must be at least 3 characters." : ""
    }));
  };

  const handleEmailChange = (e) => {
    const value = e.target.value;
    setEmail(value);
    setErrors((prevErrors) => ({
      ...prevErrors,
      email: value.includes("@") ? "" : "Email must include @."
    }));
  };

  return (
    <div>
      <FormInput
        label="Username"
        value={username}
        onChange={handleUsernameChange}
        error={errors.username}
      />
      <FormInput
        label="Email"
        value={email}
        onChange={handleEmailChange}
        error={errors.email}
      />
    </div>
  );
}

export default Form;
```

**Explanation**:
1. **Lifting State Up**: `username`, `email`, এবং `errors` state কে parent component `Form` এ lift করা হয়েছে।
2. **Passing Props for Synchronization and Validation**: `FormInput` component গুলিতে value, onChange function, এবং error message props হিসেবে pass করা হয়েছে।
3. **Real-Time Validation**: User input change করলে validation check হয় এবং error message update হয়। Updated value এবং error message `FormInput` এ synchronize হয়ে যায়।

---

### 5. ✅ Best Practices for Lifting State Up

1. **Identify Shared Data**: প্রথমে দেখে নিন কোন data একাধিক component এ প্রয়োজন।
2. **Avoid Unnecessary Lifting**: শুধুমাত্র প্রয়োজনীয় data lift করুন, কারণ অতিরিক্ত state lift করলে code structure unnecessarily complex হয়ে যেতে পারে।
3. **Pass Only Required Props**: Child component এ শুধুমাত্র প্রয়োজনীয় props pass করুন, যাতে component গুলোর মধ্যে সরল data flow বজায় থাকে।
4. **Keep Components Modular**: একাধিক component এর মধ্যে state management সহজ করতে child component গুলোকে modular রাখুন।

---

### Summary

React এ **Lifting State Up** একটি গুরুত্বপূর্ণ pattern যা component গুলোর মধ্যে data sync এবং consistent UI তৈরি করতে সহায়ক। Properly managed lifted state একটি React application এর data flow সহজ করে এবং component গুলোর মধ্যে data sharing structure পরিষ্কার এবং maintainable রাখতে সাহায্য করে। 

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-12: 📋 React Inheritance

## Table of Contents

- [Introduction to React Inheritance](#introduction-to-react-inheritance)
- [Why React Prefers Composition Over Inheritance](#why-react-prefers-composition-over-inheritance)
- [Understanding the Limitations of Inheritance in React](#understanding-the-limitations-of-inheritance-in-react)
- [Alternatives to Inheritance in React](#alternatives-to-inheritance-in-react)
- [Real-life Examples of Composition vs. Inheritance](#real-life-examples-of-composition-vs-inheritance)
- [Best Practices](#best-practices)

---

### 📘 Introduction to React Inheritance

React এ **Inheritance** concept টি বেশিরভাগ ক্ষেত্রে discouraged করা হয়। Inheritance অর্থাৎ parent-child class relationship traditional Object-Oriented Programming (OOP) এ সাধারণ ব্যাপার, যেখানে parent class এর properties বা methods child class এর দ্বারা inherit করা হয়।

React এর design philosophy অনুযায়ী component composition (composition over inheritance) কে encourage করা হয়। এতে component গুলো nested আকারে সাজানো যায় এবং data share করার জন্য props ও context ব্যবহার করা যায়।

React এর composition প্যাটার্ন, অর্থাৎ component এর মধ্যে component রাখা, code structure কে আরও modular, flexible এবং reusable করে তোলে।

---

### 🧐 Why React Prefers Composition Over Inheritance

React এর ক্ষেত্রে composition কে inheritance এর উপরে প্রাধান্য দেয়ার কারণ গুলো হলো:

1. **Code Reusability**: Composition ব্যবহার করে, component গুলোকে সহজে reuse করা যায় এবং বিভিন্ন layout এ বিভিন্ন component nesting করা সম্ভব।
2. **Loose Coupling**: Composition এ component গুলো parent-child relationship এর strict binding এ আবদ্ধ থাকে না, ফলে তারা more flexible এবং reusable হয়।
3. **Easy Debugging**: Composition structure কমপ্লেক্স হলে debugging এবং maintenance সহজ হয়।
4. **Flexible Structure**: React এর ক্ষেত্রে component গুলোর মধ্যে বিভিন্ন structure তৈরি করতে composition বেশি কার্যকর এবং customization সহজ হয়।

---

### 🔍 Understanding the Limitations of Inheritance in React

React এ inheritance এর কিছু গুরুত্বপূর্ণ limitation রয়েছে, যার কারণে এটি discouraged:

1. **Complex Structure**: Inheritance ব্যবহার করলে component গুলো tightly-coupled হয় এবং component tree structure complex হয়ে যায়।
2. **Less Flexibility**: Inheritance এ component গুলো parent class এর উপর অনেকটাই নির্ভরশীল হয়ে পড়ে, যা independent এবং reusable component তৈরি করা কঠিন করে তোলে।
3. **Prop Management Complexity**: Inheritance ব্যবহারে prop management জটিল হয়ে যায় এবং data flow control করা কঠিন হয়।
4. **Limited Use Cases**: React এর ক্ষেত্রে inheritance প্রায়শই প্রয়োজন হয় না কারণ composition এবং context data share করা অনেক বেশি flexible এবং maintainable।

---

### 🛠️ Alternatives to Inheritance in React

React এ inheritance এর পরিবর্তে composition এবং context ব্যবহার করে code structure এবং data share করা সহজ করা যায়। নিচে inheritance এর কিছু কার্যকর বিকল্প তুলে ধরা হলো:

#### 1. **Component Composition**

React এর ক্ষেত্রে component composition বেশ কার্যকর। Component composition এ, এক বা একাধিক component nested আকারে অন্য component এর মধ্যে render হয়। Composition দ্বারা UI structure সহজেই modular এবং reusable রাখা যায়।

**Example of Composition**:

```javascript
function Header() {
  return <header>Header</header>;
}

function Footer() {
  return <footer>Footer</footer>;
}

function Layout({ children }) {
  return (
    <div>
      <Header />
      {children}
      <Footer />
    </div>
  );
}

function App() {
  return (
    <Layout>
      <main>Main Content</main>
    </Layout>
  );
}
```

**Explanation**:

- `Header` এবং `Footer` component গুলো `Layout` component এর মধ্যে composition হিসেবে ব্যবহৃত হয়েছে।
- `Layout` component এ `children` prop ব্যবহার করে main content inject করা হয়েছে।
- এটি inheritance এর বদলে composition ব্যবহার করে reusable UI structure তৈরি করে।

#### 2. **Higher-Order Components (HOCs)**

**Higher-Order Components (HOCs)** হলো এমন একটি প্যাটার্ন যা একটি component কে নতুন behavior যোগ করতে বা enhance করতে সাহায্য করে। এটি component গুলোর মধ্যে reusable logic share করতে কার্যকর।

**Example of HOC**:

```javascript
import React from "react";

function withLogger(WrappedComponent) {
  return function EnhancedComponent(props) {
    console.log("Rendering:", WrappedComponent.name);
    return <WrappedComponent {...props} />;
  };
}

function MyComponent() {
  return <div>Hello, World!</div>;
}

const EnhancedComponent = withLogger(MyComponent);
```

**Explanation**:

- `withLogger` HOC `MyComponent` কে enhanced করে।
- HOCs এর মাধ্যমে inheritance ছাড়াই reusable behavior বিভিন্ন component এ যোগ করা সম্ভব।

#### 3. **Render Props**

Render props প্যাটার্নের মাধ্যমে parent component তার data এবং behavior child component এ props হিসেবে pass করতে পারে। এটি composition এবং reusable logic share করার জন্য একটি জনপ্রিয় পদ্ধতি।

**Example of Render Props**:

```javascript
import React, { useState } from "react";

function Counter({ render }) {
  const [count, setCount] = useState(0);
  return render(count, () => setCount(count + 1));
}

function App() {
  return (
    <Counter
      render={(count, increment) => (
        <div>
          <p>Count: {count}</p>
          <button onClick={increment}>Increment</button>
        </div>
      )}
    />
  );
}
```

**Explanation**:

- `Counter` component তার behavior `render` props এর মাধ্যমে child component এ pass করেছে।
- Render props inheritance এর পরিবর্তে data এবং logic share করার জন্য একটি কার্যকর পদ্ধতি।

---

### 📖 Real-life Examples of Composition vs. Inheritance

নিচে composition এবং inheritance এর মধ্যে তুলনা করার জন্য দুটি বাস্তব উদাহরণ রয়েছে।

#### Example 1: Authentication Layout (Using Composition)

ধরুন, আমাদের একটি application আছে যেখানে login এবং logout layout প্রয়োজন। Composition ব্যবহার করে এই layout তৈরি করা খুবই সহজ।

```javascript
function Header() {
  return <header>Header</header>;
}

function Footer() {
  return <footer>Footer</footer>;
}

function AuthLayout({ children }) {
  return (
    <div>
      <Header />
      {children}
      <Footer />
    </div>
  );
}

function Login() {
  return (
    <AuthLayout>
      <div>Login Form</div>
    </AuthLayout>
  );
}

function Logout() {
  return (
    <AuthLayout>
      <div>Logout Confirmation</div>
    </AuthLayout>
  );
}
```

**Explanation**:

- `AuthLayout` component composition ব্যবহার করে common `Header` এবং `Footer` সংরক্ষণ করেছে।
- `Login` এবং `Logout` component গুলো `AuthLayout` কে reuse করে এবং এর মধ্যে content inject করেছে।

#### Example 2: Applying Permissions (Using HOC Instead of Inheritance)

একটি application এ permission check করার জন্য inheritance এর পরিবর্তে HOC ব্যবহার করা যেতে পারে, যা component এর behavior enhance করতে সাহায্য করবে।

```javascript
function withPermissionCheck(WrappedComponent) {
  return function EnhancedComponent(props) {
    const hasPermission = /* permission logic */;
    if (!hasPermission) return <div>Access Denied</div>;
    return <WrappedComponent {...props} />;
  };
}

function Dashboard() {
  return <div>Dashboard Content</div>;
}

const ProtectedDashboard = withPermissionCheck(Dashboard);
```

**Explanation**:

- `withPermissionCheck` HOC `Dashboard` component এর জন্য permission check করে এবং `Dashboard` কে enhanced করে।
- HOC inheritance এর পরিবর্তে behavior enhance করার জন্য একটি কার্যকর পদ্ধতি প্রদান করে।

---

### ✅ Best Practices

React এ inheritance এর পরিবর্তে composition এবং অন্যান্য pattern ব্যবহার করার সময় কিছু Best Practices অনুসরণ করা উচিত।

1. **Use Composition Over Inheritance**: React এর ক্ষেত্রে component nesting এবং props এর মাধ্যমে data pass করা inheritance এর চেয়ে বেশি কার্যকর।
2. **Implement HOCs for Reusable Behavior**: একই behavior বা feature প্রয়োজন হলে HOC ব্যবহার করুন, যা inheritance এর জটিলতা ছাড়াই সহজে কাজ করতে সাহায্য করবে।
3. **Use Render Props for Shared Logic**: Component গুলোর মধ্যে logic share করতে render props ব্যবহার করতে পারেন যা composition এর flexibility প্রদান করে।
4. **Avoid Tight Coupling**: Component গুলোকে loosely coupled রাখতে composition পদ্ধতি ব্যবহার করুন, যা code structure পরিষ্কার এবং maintainable রাখবে।

---

React এ inheritance এর পরিবর্তে composition এবং context, HOCs, এবং render props ব্যবহার করে code structure আরও modular এবং reusable করা যায়। Proper usage এবং best practices অনুসরণ করে composition এবং অন্যান্য প্যাটার্ন ব্যবহারে React application আরও maintainable এবং flexible হয়ে ওঠে।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-12.1: React Composition ⚛️

## Table of Contents

- [Introduction to Composition in React](#introduction-to-composition-in-react)
- [Why Use Composition in React?](#why-use-composition-in-react)
- [Implementing Composition in React](#implementing-composition-in-react)
- [Common Patterns of Composition](#common-patterns-of-composition)
  - [1. Children Props](#1-children-props)
  - [2. Props for Dynamic Content](#2-props-for-dynamic-content)
  - [3. Specialized Components](#3-specialized-components)
- [Real-life Examples of Composition](#real-life-examples-of-composition)
- [Best Practices for Composition in React](#best-practices-for-composition-in-react)

---

### 📘 Introduction to Composition in React

**Composition** হলো React এর একটি powerful pattern যা component গুলোকে nested structure এ সাজিয়ে parent-child relationship তৈরি করতে সাহায্য করে। এটি component গুলোর মধ্যে code এবং behavior reuse করতে এবং UI structure কে আরো modular, maintainable এবং flexible করতে ব্যবহৃত হয়। Composition এর মাধ্যমে এক component এর মধ্যে অন্য component pass করে complex UI তৈরি করা সহজ হয়।

React এর design philosophy অনুযায়ী, composition কে inheritance এর উপরে প্রাধান্য দেওয়া হয়। Composition parent component এর জন্য child component কে customize এবং re-use করার সুবিধা দেয়, যা inheritance এর তুলনায় বেশ কার্যকর।

---

### 🧐 Why Use Composition in React?

React এ composition ব্যবহারের কিছু গুরুত্বপূর্ণ কারণ রয়েছে:

1. **Code Reusability**: Composition ব্যবহার করে component গুলিকে reusable করা যায়, ফলে বারবার একই component তৈরি করতে হয় না।
2. **Flexible and Modular Structure**: Component গুলিকে nested structure এ সাজানো যায়, যা UI structure কে আরও modular এবং flexible করে তোলে।
3. **Loose Coupling**: Composition এর মাধ্যমে component গুলো loosely coupled থাকে এবং inheritance এর মতো tightly coupled হয় না।
4. **Enhanced Readability**: Composition প্যাটার্নে component গুলোর structure পরিষ্কার এবং পড়তে সহজ হয়, যা debugging এবং maintenance সহজ করে।

---

### 🔍 Implementing Composition in React

Composition implement করার জন্য React এ বিভিন্ন পদ্ধতি রয়েছে, যার মধ্যে `children` props, named props, এবং specialized components সবচেয়ে বেশি ব্যবহৃত হয়। নিচে composition এর বিভিন্ন implementation approach আলোচনা করা হয়েছে।

---

### 📂 Common Patterns of Composition

#### 1. Children Props

React এ **`children` props** সবচেয়ে সাধারণ composition প্যাটার্ন, যেখানে parent component তার child component কে `children` props হিসেবে render করে। এর মাধ্যমে parent component এর মধ্যে অন্য component inject করা যায়।

**Example of Children Props**:

```javascript
function Card({ children }) {
  return <div className="card">{children}</div>;
}

function App() {
  return (
    <Card>
      <h2>Card Title</h2>
      <p>This is a card description.</p>
    </Card>
  );
}
```

**Explanation**:

- `Card` component `children` props এর মাধ্যমে nested content inject করার জন্য একটি container হিসাবে কাজ করে।
- `App` component এ `Card` component এর মধ্যে `h2` এবং `p` elements `children` props হিসেবে pass করা হয়েছে।
- `children` props ব্যবহার করে component structure কে flexible রাখা সম্ভব হয়।

#### 2. Props for Dynamic Content

কখনো কখনো `children` props যথেষ্ট নয় এবং component এ নির্দিষ্ট content dynamically inject করতে হয়। এজন্য, props ব্যবহার করে specific content inject করা হয়, যা composition কে আরও dynamic এবং customizable করে তোলে।

**Example of Dynamic Props**:

```javascript
function Dialog({ title, content }) {
  return (
    <div className="dialog">
      <h2>{title}</h2>
      <p>{content}</p>
    </div>
  );
}

function App() {
  return (
    <div>
      <Dialog title="Welcome" content="This is a welcome message." />
      <Dialog title="Goodbye" content="Thank you for visiting!" />
    </div>
  );
}
```

**Explanation**:

- `Dialog` component `title` এবং `content` props গ্রহণ করে, যা component কে বিভিন্ন context এ re-use করতে সাহায্য করে।
- `App` component এ `Dialog` component কে বিভিন্ন content দিয়ে render করা হয়েছে, যা component structure কে flexible করে।

#### 3. Specialized Components

Composition এ **Specialized Components** তৈরি করতে context-specific বা layout-specific components ব্যবহার করা যায়। এতে parent component অন্যান্য component কে section বা slot আকারে pass করে, এবং structure অনুযায়ী customize করা যায়।

**Example of Specialized Components**:

```javascript
function Layout({ header, sidebar, content }) {
  return (
    <div className="layout">
      <header>{header}</header>
      <aside>{sidebar}</aside>
      <main>{content}</main>
    </div>
  );
}

function App() {
  return (
    <Layout
      header={<h1>Website Header</h1>}
      sidebar={<p>Sidebar Content</p>}
      content={<p>Main Content Area</p>}
    />
  );
}
```

**Explanation**:

- `Layout` component এ `header`, `sidebar`, এবং `content` props গ্রহণ করা হয়েছে, যা layout এর বিভিন্ন অংশে বিভিন্ন content inject করতে সহায়ক।
- `App` component এ `Layout` component এর মধ্যে বিভিন্ন অংশে নির্দিষ্ট content pass করা হয়েছে, যা composition কে structured এবং readable করে।

---

### 📖 Real-life Examples of Composition

#### Example 1: Modal Component with Composition

একটি modal component তৈরি করা হয়েছে যা বিভিন্ন context এ বিভিন্ন content inject করতে composition ব্যবহার করেছে।

```javascript
function Modal({ title, children }) {
  return (
    <div className="modal">
      <h2>{title}</h2>
      <div className="modal-content">{children}</div>
    </div>
  );
}

function App() {
  return (
    <div>
      <Modal title="Confirmation">
        <p>Are you sure you want to proceed?</p>
        <button>Yes</button>
        <button>No</button>
      </Modal>
      <Modal title="Notification">
        <p>You have a new message.</p>
      </Modal>
    </div>
  );
}
```

**Explanation**:

1. **Modal Component**: `Modal` component `title` এবং `children` props ব্যবহার করে content display করে।
2. **App Component**: `App` component এ `Modal` component এর মধ্যে বিভিন্ন context অনুযায়ী content inject করা হয়েছে।
3. **Output**: Composition ব্যবহার করে `Modal` component কে বিভিন্ন layout এ content display করতে flexible রাখা হয়েছে।

#### Example 2: Navbar Layout with Composition

ধরুন, আমাদের একটি application আছে যেখানে Navbar এর বিভিন্ন section আছে। Composition ব্যবহার করে এই layout তৈরি করা সহজ।

```javascript
function Navbar({ logo, menu, profile }) {
  return (
    <nav className="navbar">
      <div className="navbar-logo">{logo}</div>
      <div className="navbar-menu">{menu}</div>
      <div className="navbar-profile">{profile}</div>
    </nav>
  );
}

function App() {
  return (
    <Navbar
      logo={<img src="logo.png" alt="Logo" />}
      menu={
        <ul>
          <li>Home</li>
          <li>About</li>
          <li>Contact</li>
        </ul>
      }
      profile={<button>Login</button>}
    />
  );
}
```

**Explanation**:

1. **Navbar Component**: `Navbar` component `logo`, `menu`, এবং `profile` props গ্রহণ করে।
2. **App Component**: `App` component এ `Navbar` component এর মধ্যে বিভিন্ন section এ content inject করা হয়েছে।
3. **Output**: Composition ব্যবহার করে `Navbar` component কে flexible এবং reusable রাখা হয়েছে।

---

### ✅ Best Practices for Composition in React

Composition ব্যবহার করার সময় কিছু Best Practices অনুসরণ করা উচিত:

1. **Use Composition Over Inheritance**: React এ inheritance এর পরিবর্তে composition ব্যবহার করুন, যা component structure কে simple এবং flexible রাখে।
2. **Avoid Nested Composition if Possible**: অতিরিক্ত nested composition structure জটিল করে তোলে, তাই nesting কম রাখার চেষ্টা করুন।
3. **Use Meaningful Names for Props**: Composition এর জন্য meaningful এবং descriptive props নাম ব্যবহার করুন, যা component এর বিভিন্ন অংশের কাজ বুঝতে সাহায্য করে।
4. **Use `children` for Flexible Structure**: `children` props ব্যবহার করে nested structure তৈরি করুন, যা content inject করা সহজ করে।

---

React এ Composition প্যাটার্ন component গুলোর structure কে modular এবং reusable করতে সাহায্য করে। Proper usage এবং best practices অনুসরণ করে Composition ব্যবহার করলে React application গুলো আরো maintainable এবং flexible হয়ে ওঠে।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-12.2: 📋 React Inheritance vs Composition - Detailed Example with Tight Coupling Explanation

### Introduction

React এ Composition এবং Inheritance এর মধ্যে পার্থক্য বোঝার জন্য আমরা আবার একটি উদাহরণ তৈরি করব এবং দেখব কেন composition এ **Tight Coupling** থাকে না, অথচ inheritance structure অনেক সময় component গুলোর মধ্যে tight coupling তৈরি করে।

### Tight Coupling vs Loose Coupling

- **Tight Coupling**: যখন একটি component বা class অন্য component বা class এর উপর সম্পূর্ণ নির্ভরশীল হয় এবং কোন পরিবর্তন করতে গেলে তার সাথে অন্যান্য component গুলোতেও পরিবর্তন আনতে হয়, তখন আমরা বলি এই component গুলো tightly coupled।
- **Loose Coupling**: Loose coupling মানে component গুলো একে অপরের উপর সরাসরি নির্ভরশীল নয়। এক component পরিবর্তন করলে অন্য component এর structure এ পরিবর্তন করতে হয় না। React এ composition ব্যবহার করে এই loose coupling সহজেই অর্জন করা সম্ভব হয়।

---

## Example: Inheritance vs Composition

ধরুন, আমাদের একটি `Notification` component তৈরি করতে হবে যা বিভিন্ন ধরনের notification display করতে পারে, যেমন:

1. Success Notification
2. Error Notification
3. Warning Notification

আমরা এই component দু'ভাবে implement করব: প্রথমে inheritance ব্যবহার করে এবং পরে composition ব্যবহার করে। এর মাধ্যমে আমরা composition এর flexibility এবং inheritance এর tight coupling এর পার্থক্য বুঝতে পারব।

---

### Using Inheritance (Tight Coupling Example)

Inheritance structure এ, আমরা একটি `Notification` base class তৈরি করব এবং বিভিন্ন ধরনের notification এর জন্য subclass তৈরি করব।

```javascript
import React from "react";

// Base Notification Class
class Notification extends React.Component {
  renderIcon() {
    return <span>🔔</span>; // Default icon
  }

  renderMessage() {
    return <p>Notification message</p>;
  }

  render() {
    return (
      <div className="notification">
        {this.renderIcon()}
        {this.renderMessage()}
      </div>
    );
  }
}

// Success Notification (Subclass)
class SuccessNotification extends Notification {
  renderIcon() {
    return <span>✅</span>; // Success icon
  }

  renderMessage() {
    return <p>Success! Your operation completed successfully.</p>;
  }
}

// Error Notification (Subclass)
class ErrorNotification extends Notification {
  renderIcon() {
    return <span>❌</span>; // Error icon
  }

  renderMessage() {
    return <p>Error! Something went wrong.</p>;
  }
}

function App() {
  return (
    <div>
      <SuccessNotification />
      <ErrorNotification />
    </div>
  );
}

export default App;
```

**Explanation**:

1. **Base Class**: `Notification` base class তৈরি করা হয়েছে, যেখানে default icon এবং message রয়েছে।
2. **Subclasses**: `SuccessNotification` এবং `ErrorNotification` দুটি subclass, যা `Notification` class থেকে extend করেছে। এই subclass গুলোতে `renderIcon` এবং `renderMessage` method override করা হয়েছে।
3. **Tight Coupling**: এখানে subclasses গুলো base class `Notification` এর উপর সম্পূর্ণ নির্ভরশীল। যদি `Notification` class এর structure পরিবর্তন করা হয় (যেমন নতুন element বা styling যুক্ত করা হয়), তাহলে `SuccessNotification` এবং `ErrorNotification` সহ সকল subclass এও এই পরিবর্তন গুলো করতে হবে।

#### Limitations of Inheritance (Tight Coupling)

- **Fixed Structure**: `Notification` এর subclasses গুলোর structure base class এর উপর নির্ভরশীল। একটি নতুন ধরনের notification যুক্ত করতে হলে আবার একটি নতুন subclass তৈরি করতে হবে।
- **Limited Flexibility**: Subclass গুলো tightly coupled থাকার কারণে, component গুলোকে easily customize বা change করা কঠিন।
- **Dependency on Base Class**: `Notification` class পরিবর্তন করলে সকল subclass এ সেই পরিবর্তন প্রভাবিত হয়। একে আমরা tight coupling বলি কারণ subclass গুলো সরাসরি base class এর উপর নির্ভরশীল।

---

### Using Composition (Loose Coupling Example)

Composition ব্যবহার করে, আমরা `Notification` component কে flexible এবং loosely coupled রাখব। এই ক্ষেত্রে `Notification` component এক ধরনের layout/container হিসেবে কাজ করবে, যেখানে বিভিন্ন content dynamically inject করা যাবে।

```javascript
import React from "react";

// Base Notification Component using Composition
function Notification({ icon, message }) {
  return (
    <div className="notification">
      <span>{icon}</span>
      <p>{message}</p>
    </div>
  );
}

// Success Notification Component
function SuccessNotification() {
  return (
    <Notification
      icon="✅"
      message="Success! Your operation completed successfully."
    />
  );
}

// Error Notification Component
function ErrorNotification() {
  return <Notification icon="❌" message="Error! Something went wrong." />;
}

function App() {
  return (
    <div>
      <SuccessNotification />
      <ErrorNotification />
    </div>
  );
}

export default App;
```

**Explanation**:

1. **Base Component**: `Notification` component একটি generic layout তৈরি করেছে, যা `icon` এবং `message` props গ্রহণ করে। এর ফলে component টি নির্দিষ্ট কোন content এর উপর নির্ভরশীল নয়।
2. **Dynamic Content**: `SuccessNotification` এবং `ErrorNotification` component গুলো আলাদা আলাদা content pass করে `Notification` component কে customize করেছে।
3. **Loose Coupling**: এখানে `Notification` component এর উপর নির্ভরশীলতা কম, কারণ `SuccessNotification` এবং `ErrorNotification` component গুলো আলাদাভাবে content pass করে customize হয়েছে। `Notification` component এর structure পরিবর্তন করলেও child component গুলো unaffected থাকবে।

---

### Why Composition is Better than Inheritance in React

1. **Loose Coupling**:

   - **Composition**: Composition এর মাধ্যমে component গুলোর মধ্যে loose coupling থাকে। `Notification` component অন্য component এর উপর নির্ভরশীল নয়, বরং `icon` এবং `message` props এর মাধ্যমে dynamically content pass করা যায়।
   - **Inheritance**: Inheritance structure এ subclass গুলো tightly coupled থাকে, কারণ তারা base class এর properties এবং methods directly inherit করে। Base class এ পরিবর্তন করলে subclass গুলোকেও সেই পরিবর্তন মেনে চলতে হয়।

2. **Flexibility and Reusability**:

   - **Composition**: Composition ব্যবহার করে `Notification` component reusable এবং flexible হয়েছে। আমরা সহজেই নতুন ধরনের notification (যেমন Warning বা Info) তৈরি করতে পারি, যা inheritance structure এ subclass তৈরি করার প্রয়োজনীয়তা কমিয়ে দেয়।
   - **Inheritance**: Inheritance structure এ প্রত্যেকটি নতুন ধরনের notification এর জন্য আলাদা subclass তৈরি করতে হয়। এতে code duplication বাড়ে এবং flexibility কমে যায়।

3. **Maintainable and Clear Structure**:

   - **Composition**: Composition structure inheritance এর তুলনায় অনেক পরিষ্কার এবং সহজে বোঝা যায়। Composition structure predictable এবং changes implement করা সহজ।
   - **Inheritance**: Inheritance এ subclass structure জটিল হয়ে যায় এবং base class পরিবর্তন করলে সকল subclass এ সেই পরিবর্তন করতে হয়। এটি code structure কে জটিল এবং less maintainable করে তোলে।

4. **Avoids Code Duplication**:
   - **Composition**: Composition structure এ আমরা একই `Notification` component কে বিভিন্ন content দিয়ে re-use করতে পারি, যা code duplication কমায়।
   - **Inheritance**: Inheritance structure এ একই ধরনের structure বা layout এর জন্য বিভিন্ন subclass তৈরি করতে হয়, যা code duplication বাড়ায়।

---

### Summary

React এ Composition এর মাধ্যমে component structure কে flexible এবং loosely coupled রাখা সম্ভব হয়। Composition inheritance এর তুলনায় অনেক বেশি maintainable এবং reusable structure তৈরি করতে সাহায্য করে, কারণ component গুলো একে অপরের উপর সরাসরি নির্ভরশীল থাকে না। Properly implemented composition structure component গুলোকে modular, clean এবং React এর declarative nature এর সাথে সামঞ্জস্যপূর্ণ করে তোলে।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-13: React Higher Order Components (HOC)

### Table of Contents

1. [🌟 What is a Higher Order Component (HOC)?](#what-is-a-higher-order-component-hoc)
2. [🧐 Why Use Higher Order Components?](#why-use-higher-order-components)
3. [⚙️ How HOCs Work](#how-hocs-work)
4. [🚀 Implementing HOCs in React](#implementing-hocs-in-react)
5. [🔍 Examples of Higher Order Components](#examples-of-higher-order-components)
6. [✅ Best Practices for HOCs](#best-practices-for-hocs)

---

### 1. 🌟 What is a Higher Order Component (HOC)?

A **Higher Order Component (HOC)** হলো React এ ব্যবহৃত একটি advanced technique যা একটি component কে অন্য একটি function এর মাধ্যমে wrap করে এবং নতুন একটি component return করে। এটি মূলত একটি **JavaScript function** যা একটি **React component** কে argument হিসেবে গ্রহণ করে এবং সেই component এর উপর ভিত্তি করে নতুন component return করে। HOC component গুলোকে reusable এবং dynamically configurable করে তোলে।

উদাহরণ হিসেবে ভাবুন, আমাদের একটি basic component আছে যেটা কিছু data render করে, কিন্তু আমরা সেই component এ একটি loading indicator যোগ করতে চাই। এ ক্ষেত্রে, একটি HOC তৈরি করে আমরা loading feature টি main component এ যুক্ত করতে পারি, যা component এর মূল structure কে পরিবর্তন না করেই সেই কাজটি করবে।

HOC এর কাজ হলো:

- Component কে enhance করা
- নতুন functionality যোগ করা
- Component কে reusable এবং flexible করে তোলা

**Example Structure**:

```javascript
const EnhancedComponent = higherOrderComponent(OriginalComponent);
```

এই কোডে, `higherOrderComponent` নামক একটি function আছে, যা `OriginalComponent` কে গ্রহণ করে এবং সেটির উপর কিছু নির্দিষ্ট কাজ করে নতুন `EnhancedComponent` তৈরি করে।

### 2. 🧐 Why Use Higher Order Components?

React এ HOC ব্যবহার করার কিছু গুরুত্বপূর্ণ কারণ রয়েছে, যা component এর পুনঃব্যবহারযোগ্যতা এবং modularity বাড়াতে সহায়তা করে।

#### a. **Code Reuse**

একই functionality বা logic যদি বিভিন্ন component এ প্রয়োজন হয়, তখন HOC ব্যবহার করে সেই logic কে reusable করা যায়। যেমন ধরুন, আমাদের প্রায় সব component এ একটি loading feature দরকার, তাহলে একটি HOC তৈরি করে সেই loading feature কে অন্যান্য component এ add করা সম্ভব।

#### b. **Separation of Concerns**

HOCs component থেকে নির্দিষ্ট কাজ আলাদা করে, যাকে **Separation of Concerns** বলা হয়। এতে মূল component এর logic কমplex না হয় এবং readability বাড়ে। ধরুন, authentication check করার জন্য একটি HOC ব্যবহার করা হয়েছে। এতে মূল component এর কোড সহজ থাকে এবং authentication logic আলাদা থাকে।

#### c. **Conditional Rendering**

কিছু নির্দিষ্ট পরিস্থিতিতে component এর behavior বা props পরিবর্তন করতে হলে HOC অত্যন্ত কার্যকরী। HOCs component এর মধ্যে বিশেষ feature conditionally যোগ করার জন্য আদর্শ।

#### d. **Enhancement without Modification**

HOC ব্যবহার করলে মূল component এর structure বা functionality পরিবর্তন না করেই নতুন feature যোগ করা যায়। এটি React এর **Pure Functions** এর ধারণার উপর ভিত্তি করে কাজ করে, যার ফলে মূল component এর উপর কোনো প্রভাব ফেলে না।

### 3. ⚙️ How HOCs Work

Higher Order Component একটি function এর মত কাজ করে, যেখানে একটি component কে argument হিসেবে নেওয়া হয় এবং এটি নতুন একটি component return করে। এটি props এবং state এর উপর নির্ভর করে মূল component কে enhance করে।

#### Example Code Structure

```javascript
function withExtraFunctionality(WrappedComponent) {
  return function EnhancedComponent(props) {
    // কিছু extra কাজ করা হচ্ছে
    return <WrappedComponent {...props} />;
  };
}
```

**Explanation**:

- `withExtraFunctionality` নামক function টির মধ্যে `WrappedComponent` component গ্রহণ করা হয়েছে।
- `EnhancedComponent` নামে নতুন একটি component return করা হয়েছে, যা মূল component কে enhance করে।
- `{...props}` ব্যবহার করে মূল component এর props retain করা হয়েছে, ফলে enhanced component সব props access করতে পারে।

### 4. 🚀 Implementing HOCs in React

React এ HOC তৈরি করার জন্য আমাদের একটি function তৈরি করতে হয়, যা একটি component কে গ্রহণ করে এবং একটি নতুন component return করে। HOC ব্যবহার করে আমরা code reusability এবং component behavior পরিবর্তন করতে পারি।

#### Implementing a Loading Indicator HOC

```javascript
import React from "react";

function withLoadingIndicator(WrappedComponent) {
  return function EnhancedComponent({ isLoading, ...props }) {
    if (isLoading) return <p>Loading...</p>;
    return <WrappedComponent {...props} />;
  };
}
```

**Explanation**:

1. **HOC Definition**: `withLoadingIndicator` নামক HOC তৈরি করা হয়েছে। এটি `WrappedComponent` কে গ্রহণ করে এবং নতুন component return করে।
2. **Conditional Rendering**: `isLoading` prop check করা হয়। `isLoading` true হলে "Loading..." মেসেজ দেখায়।
3. **Main Component Render**: `isLoading` false হলে মূল `WrappedComponent` render হয়।

এখন আমরা এই `withLoadingIndicator` HOC কে বিভিন্ন component এ ব্যবহার করতে পারি, এবং প্রয়োজন অনুযায়ী loading feature যুক্ত করতে পারি।

### 5. 🔍 Examples of Higher Order Components

#### Example 1: Loading Indicator with HOC

```javascript
import React from "react";

function withLoadingIndicator(WrappedComponent) {
  return function EnhancedComponent({ isLoading, ...props }) {
    if (isLoading) return <p>Loading...</p>;
    return <WrappedComponent {...props} />;
  };
}

function DataDisplay({ data }) {
  return <div>Data: {data}</div>;
}

const DataDisplayWithLoading = withLoadingIndicator(DataDisplay);

// Usage in App
function App() {
  return <DataDisplayWithLoading isLoading={true} data="Some Data" />;
}
```

**Detailed Explanation**:

1. **withLoadingIndicator HOC**: এখানে একটি HOC তৈরি করা হয়েছে যা `isLoading` prop গ্রহণ করে। যদি `isLoading` true হয়, তবে এটি একটি "Loading..." মেসেজ প্রদর্শন করে।
2. **DataDisplay Component**: এটি একটি সাধারণ component, যা `data` props থেকে একটি simple message render করে।
3. **Enhanced Component**: `DataDisplayWithLoading` নামে নতুন component তৈরি করা হয়েছে, যা `DataDisplay` কে `withLoadingIndicator` এর মাধ্যমে enhanced করেছে।
4. **Usage**: যখন `isLoading={true}` পাস করা হয়, তখন "Loading..." প্রদর্শিত হয়। আর `isLoading` false হলে `DataDisplay` component এর content প্রদর্শিত হয়।

#### Example 2: Authorization HOC

```javascript
import React from "react";

function withAuthorization(WrappedComponent) {
  return function EnhancedComponent({ isAuthenticated, ...props }) {
    if (!isAuthenticated)
      return <p>You are not authorized to view this content.</p>;
    return <WrappedComponent {...props} />;
  };
}

function SecretContent() {
  return <div>Secret Content: Only for authorized users!</div>;
}

const AuthorizedContent = withAuthorization(SecretContent);

// Usage in App
function App() {
  return <AuthorizedContent isAuthenticated={false} />;
}
```

**Detailed Explanation**:

1. **withAuthorization HOC**: এই HOC authentication check করার জন্য ব্যবহৃত হচ্ছে। এটি `isAuthenticated` prop গ্রহণ করে। যদি `isAuthenticated` false হয়, তবে "You are not authorized to view this content" মেসেজ দেখায়।
2. **SecretContent Component**: এটি একটি সাধারণ component, যা authorized users এর জন্য গোপনীয় content প্রদর্শন করে।
3. **Enhanced Component**: `AuthorizedContent` নামে একটি নতুন component তৈরি হয়েছে, যা `SecretContent` কে `withAuthorization` HOC এর মাধ্যমে enhance করেছে।
4. **Usage**: যখন `isAuthenticated={false}` পাস করা হয়, তখন user কে "You are not authorized..." মেসেজ দেখানো হয়। আর `isAuthenticated` true হলে মূল content দেখানো হয়।

### 6. ✅ Best Practices for HOCs

1. **Descriptive Naming**: HOC গুলোর নাম meaningful হওয়া উচিত যেন বুঝা যায় HOC টির কাজ কি, যেমন `withLoadingIndicator`, `withAuthorization` ইত্যাদি।
2. **Don’t Overuse HOCs**: HOC গুলো অতিরিক্ত ব্যবহার করা উচিত নয়। একই কাজ সম্ভব হলে composition বা custom hooks ব্যবহার করা যায়।
3. **Props Management**: HOC এ `props` pass করার সময় নিশ্চিত হোন যে wrapped component এর সব props ঠিকঠাকভাবে pass হচ্ছে। `{...props}` ব্যবহার করলে সব props wrapped component এ চলে যাবে।
4. **Static Method Copy**: HOCs ব্যবহার করার সময় static methods হারিয়ে যেতে পারে। `hoist-non-react-statics` library ব্যবহার করে static methods এবং properties সংরক্ষণ করা যায়।
5. **Avoid Side Effects**: HOCs pure function হওয়া উচিত, অর্থাৎ এর মধ্যে এমন কোনো কাজ করা উচিত নয় যা wrapped component এর বাইরের কোনো value বা state পরিবর্তন করে।

---

React এ **Higher Order Components (HOC)** একটি শক্তিশালী টুল যা component গুলোকে reusable এবং modular ভাবে তৈরি করতে সাহায্য করে। এটি component এর behavior পরিবর্তন না করেই বিভিন্ন feature যোগ করতে এবং logic আলাদা করতে সহায়ক। HOC এর সঠিক ব্যবহার application কে modular, flexible, এবং maintainable করে তোলে। 😄

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>


# Chapter-13.1: A Real-World Example of HOC

## Problem Scenario:
আপনার একটি অ্যাপে দুইটি ফিচার আছে:
1. একটি button, যা click করলে count বাড়বে।
2. একটি element, যেটি hover করলে count বাড়বে।

এই দু’টি feature এ কিছু common logic আছে:
- Count পরিচালনা করা।
- State management করা।

প্রতিটি component এ একই logic বারবার না লিখে **HOC ব্যবহার করে** এই সমস্যার সমাধান করা হবে।

---

## Steps to Solve Using HOC:
1. একটি **HOC তৈরি করা হবে** যা count increment এবং state management পরিচালনা করবে।
2. দুটি আলাদা component (CounterButton এবং HoverCounter) তৈরি করা হবে।
3. এই component গুলোতে HOC ব্যবহার করে logic পুনরায় ব্যবহারযোগ্য করা হবে।

---

## Step-by-Step Code with Explanation

---

### Step 1: Basic Components তৈরি করা

#### Component 1: CounterButton Component
```javascript
function CounterButton({ count, incrementCount }) {
  return (
    <button onClick={incrementCount}>
      Button Clicked {count} times
    </button>
  );
}

export default CounterButton;
```

#### Component 2: HoverCounter Component
```javascript
function HoverCounter({ count, incrementCount }) {
  return (
    <h2 onMouseOver={incrementCount}>
      Hovered {count} times
    </h2>
  );
}

export default HoverCounter;
```

---

### Step 2: Higher Order Component তৈরি করা

```javascript
import React, { useState } from 'react';

function withCounter(WrappedComponent) {
  return function EnhancedComponent(props) {
    const [count, setCount] = useState(0);

    const incrementCount = () => {
      setCount(count + 1);
    };

    return (
      <WrappedComponent
        count={count}
        incrementCount={incrementCount}
        {...props}
      />
    );
  };
}

export default withCounter;
```

#### ব্যাখ্যা:
1. **HOC Function**:
   - `withCounter` একটি HOC যা একটি component (`WrappedComponent`) কে enhance করে।
   - এটি count এবং increment logic handle করে।

2. **State Management**:
   - `useState` ব্যবহার করে `count` state তৈরি করা হয়েছে।
   - `incrementCount` function count বাড়ানোর জন্য তৈরি করা হয়েছে।

3. **Props Passing**:
   - `count` এবং `incrementCount` props হিসেবে `WrappedComponent` এ পাঠানো হয়েছে।
   - Original props গুলো HOC এর মাধ্যমে maintain করতে `...props` ব্যবহার করা হয়েছে।

---

### Step 3: HOC ব্যবহার করে Enhanced Components তৈরি করা

#### Enhanced CounterButton
```javascript
import CounterButton from './CounterButton';
import withCounter from './withCounter';

const EnhancedCounterButton = withCounter(CounterButton);

export default EnhancedCounterButton;
```

#### Enhanced HoverCounter
```javascript
import HoverCounter from './HoverCounter';
import withCounter from './withCounter';

const EnhancedHoverCounter = withCounter(HoverCounter);

export default EnhancedHoverCounter;
```

---

### Step 4: App Component এ Enhanced Components ব্যবহার করা

```javascript
import React from 'react';
import EnhancedCounterButton from './EnhancedCounterButton';
import EnhancedHoverCounter from './EnhancedHoverCounter';

function App() {
  return (
    <div>
      <EnhancedCounterButton />
      <EnhancedHoverCounter />
    </div>
  );
}

export default App;
```

---

## How the HOC Simplifies the Code

### HOC এর কারণে কী সুবিধা হলো:
1. **Code Reusability**:
   - `withCounter` HOC তৈরি করার পর `count` এবং `incrementCount` logic বারবার লিখতে হয়নি।
   - CounterButton এবং HoverCounter উভয়ের জন্য একই HOC ব্যবহার করা হয়েছে।

2. **Separation of Concerns**:
   - HOC state management এবং counting logic পরিচালনা করছে।
   - মূল components (CounterButton এবং HoverCounter) শুধুমাত্র UI এবং event handle করছে।

3. **Consistency in Logic**:
   - যেকোনো component এ count এবং increment logic একইরকম থাকবে কারণ HOC logic centralize করেছে।

---

### HOC ছাড়া কী অসুবিধা হতো:
1. **Duplicate Logic**:
   - প্রতিটি component এ `useState` এবং `incrementCount` বারবার লিখতে হতো।
   - এর ফলে code redundancy এবং maintenance সমস্যা হতো।

2. **Difficult Maintenance**:
   - Future এ logic পরিবর্তন করতে হলে প্রতিটি component এ individually পরিবর্তন করতে হতো।

---

### Detailed Step-by-Step Workflow

1. **WrappedComponent**:
   - HOC এর ভিতরে `WrappedComponent` হলো মূল component যা enhance করা হয়।
   - উদাহরণ: CounterButton বা HoverCounter।

2. **Props Passing**:
   - HOC এর মাধ্যমে `count` এবং `incrementCount` props `WrappedComponent` এ পাঠানো হয়।
   - Original props retain করতে `...props` ব্যবহার করা হয়।

3. **Reusable Logic**:
   - Count এবং increment logic একবার HOC এ লিখলেই এটি যেকোনো component এ প্রয়োগ করা যায়।

4. **Enhanced Components**:
   - HOC এর মাধ্যমে Enhanced Components (EnhancedCounterButton এবং EnhancedHoverCounter) তৈরি করা হয়, যা মূল component এর behavior extend করে।

---

### Final Output:

- **EnhancedCounterButton**:
  - Button click করলে count বাড়ে।
  - Output: `Button Clicked 1 times`.

- **EnhancedHoverCounter**:
  - Element hover করলে count বাড়ে।
  - Output: `Hovered 1 times`.

---


<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>


# Chapter-14: React Render Props

## Problem Scenario:
ধরি আমাদের একটা অ্যাপ দরকার যে অ্যাপে এমন দুটি counter feature দরকার:
1. একটি button click করলে count বাড়বে।
2. একটি element hover করলে count বাড়বে।

এই দুটি counter feature একই **logic** (count management) ব্যবহার করে। কিন্তু যদি প্রতিটি component-এ একই logic বারবার লিখতে হয়, তাহলে code redundancy এবং maintenance সমস্যা দেখা দেবে। 

---

## Solution Using Render Props:
Render Props প্যাটার্ন ব্যবহার করে **common logic share করা যায়**। আমরা একবার counting logic তৈরি করব এবং তা বিভিন্ন UI components-এ প্রয়োগ করব। 

---

## What is Render Props?

React এ **Render Props** একটি pattern যেখানে component একটি **function** কে prop হিসেবে গ্রহণ করে এবং সেই function কে call করে component এর output তৈরি করে। এটি component এর মধ্যে reusable logic share করতে ব্যবহৃত হয়।

---

## Implementation of Render Props with Counter

### Step-by-Step Code and Explanation:

---

### Step 1: Create a `Counter` Component with Render Props

#### Counter.js
```javascript
import React, { useState } from 'react';

function Counter({ render }) {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(count + 1);
  };

  return <div>{render({ count, increment })}</div>;
}

export default Counter;
```

#### Explanation:
1. **State Management**:
   - `useState` দিয়ে `count` এবং `increment` function handle করা হয়েছে।
   - `count` এর মান `0` দিয়ে শুরু হয় এবং `increment` call করলে count বাড়ে।

2. **Render Props**:
   - `Counter` component একটি **function** (render prop) গ্রহণ করে যা `count` এবং `increment` props পায়।
   - এই render function `count` এবং `increment` এর উপর ভিত্তি করে UI তৈরি করে।

---

### Step 2: Create UI Components for Click and Hover Counters

#### ClickCounter.js
```javascript
function ClickCounter({ count, increment }) {
  return (
    <button onClick={increment}>
      Button Clicked {count} times
    </button>
  );
}

export default ClickCounter;
```

#### Explanation:
- **UI Rendering**:
  - `ClickCounter` একটি button render করে।
  - Button এ click করলে `increment` function call হয় এবং `count` update হয়।

---

#### HoverCounter.js
```javascript
function HoverCounter({ count, increment }) {
  return (
    <h2 onMouseOver={increment}>
      Hovered {count} times
    </h2>
  );
}

export default HoverCounter;
```

#### Explanation:
- **UI Rendering**:
  - `HoverCounter` একটি heading render করে।
  - Heading এ hover করলে `increment` function call হয় এবং `count` update হয়।

---

### Step 3: Use the `Counter` Component to Share Logic

#### App.js
```javascript
import React from 'react';
import Counter from './Counter';
import ClickCounter from './ClickCounter';
import HoverCounter from './HoverCounter';

function App() {
  return (
    <div>
      <h1>React Render Props Example</h1>

      {/* Click Counter */}
      <Counter
        render={({ count, increment }) => (
          <ClickCounter count={count} increment={increment} />
        )}
      />

      {/* Hover Counter */}
      <Counter
        render={({ count, increment }) => (
          <HoverCounter count={count} increment={increment} />
        )}
      />
    </div>
  );
}

export default App;
```

---

## How Render Props Solves the Problem

### Without Render Props (Problem):
1. **Duplicate Logic**:
   - `ClickCounter` এবং `HoverCounter` এর জন্য `count` এবং `increment` logic বারবার লিখতে হতো।
2. **Difficult Maintenance**:
   - Future এ logic পরিবর্তন করতে হলে প্রতিটি component এ পরিবর্তন করতে হতো।

---

### With Render Props (Solution):
1. **Shared Logic**:
   - `Counter` component logic (count এবং increment) encapsulate করে।
   - এই logic render props এর মাধ্যমে `ClickCounter` এবং `HoverCounter` এ share করা হয়েছে।

2. **Separation of Concerns**:
   - `Counter` component logic handle করে।
   - `ClickCounter` এবং `HoverCounter` UI handle করে।

---

### Final Output:
#### Click Counter:
```
[Button]
Button Clicked 0 times
```

#### Hover Counter:
```
Hovered 0 times
```

---

### Detailed Explanation of the Code Flow:

1. **Counter Component**:
   - `useState` দিয়ে count এবং increment logic manage করে।
   - `render` prop এর মাধ্যমে `count` এবং `increment` অন্য component এ pass করে।

2. **Render Prop Function**:
   - `render` function এ `count` এবং `increment` পাঠানো হয়।
   - UI component (যেমন `ClickCounter`, `HoverCounter`) এই render function থেকে props পায়।

3. **Dynamic UI Creation**:
   - Render Props UI কে flexible এবং reusable করে তোলে।
   - `ClickCounter` এবং `HoverCounter` এর জন্য আলাদা UI তৈরি করা হয়েছে, কিন্তু logic share করা হয়েছে।

---

### Advantages of Render Props in this Example:

1. **Code Reusability**:
   - Counting logic একবার লিখে সব components এ ব্যবহার করা হয়েছে।
2. **Logic Encapsulation**:
   - Counting logic `Counter` component এর মধ্যে encapsulate করা হয়েছে।
3. **UI Flexibility**:
   - `render` function ব্যবহার করে আলাদা আলাদা UI তৈরি করা সম্ভব।
4. **Maintenance-Friendly**:
   - Logic পরিবর্তন করতে হলে শুধু `Counter` component এ পরিবর্তন করতে হবে।



<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-15: React Context API

## Table of Contents

- [Introduction to Context API](#introduction-to-context-api)
- [Why Use Context API?](#why-use-context-api)
- [Core Concepts of Context API](#core-concepts-of-context-api)
- [Implementing Context API in React](#implementing-context-api-in-react)
- [Real-life Examples](#real-life-examples)
- [Best Practices for Context API](#best-practices-for-context-api)

---

### 📘 Introduction to Context API

React **Context API** হলো একটি powerful tool যা component গুলোর মধ্যে data pass এবং share করতে ব্যবহার করা হয়। সাধারণত, data parent থেকে child component এ props এর মাধ্যমে pass করা হয়। তবে, যদি component গুলোর মধ্যে nested structure অনেক বড় হয়, তখন প্রতিটি layer এ props pass করা cumbersome হয়ে ওঠে। **Context API** এই সমস্যা সমাধান করে data globally manage এবং access করার সুবিধা দিয়ে।

Context API ব্যবহার করে component tree তে data সরাসরি এক স্তর থেকে অন্য স্তরে pass করা যায়, যা data এর accessibility এবং component গুলোর মধ্যে interaction সহজ করে তোলে।

---

### 🧐 Why Use Context API?

Context API এর প্রধান কাজ হলো component গুলোর মধ্যে data share সহজ করা। এটি একটি central location তৈরি করে যেখানে data রাখা হয় এবং যেকোনো nested component সহজেই এই data access করতে পারে। নিচে Context API ব্যবহারের কারণগুলো উল্লেখ করা হলো:

1. **Avoids Prop Drilling**: অনেকগুলো nested component এর মধ্যে data pass করার জন্য প্রতি layer এ props ব্যবহার করার প্রয়োজন নেই।
2. **Centralized State Management**: একটি central state তৈরি করা যায়, যা application এর যেকোনো component এ access করা সম্ভব।
3. **Reusability and Flexibility**: একই context বিভিন্ন component এ সহজে ব্যবহৃত হতে পারে, যা reusability এবং flexibility বাড়ায়।

Context API সাধারণত এমন পরিস্থিতিতে ব্যবহার করা হয়, যখন কিছু data (যেমন theme, user information, authentication status) global ভাবে accessible থাকা প্রয়োজন।

---

### 🔍 Core Concepts of Context API

Context API এর মূলত তিনটি প্রধান অংশ রয়েছে:

1. **Context Creation**: প্রথম ধাপে context তৈরি করতে হয়, যা data store করার জন্য একটি container হিসেবে কাজ করে।

   ```javascript
   const ThemeContext = React.createContext(defaultValue);
   ```

   এখানে `ThemeContext` একটি context তৈরি করে, যা পরে data provide এবং consume করার জন্য ব্যবহার হবে।

2. **Provider Component**: Context provider component data বা state provide করে এবং এই data যেকোনো child component access করতে পারে।

   ```javascript
   <ThemeContext.Provider value={/* some data */}>
     {/* Child components */}
   </ThemeContext.Provider>
   ```

   Provider component এ `value` props এর মাধ্যমে data pass করা হয়, যা nested component গুলো access করতে পারে।

3. **Consumer Component**: Context consumer component ব্যবহার করে যে কোনো nested component context থেকে data consume করতে পারে।
   ```javascript
   <ThemeContext.Consumer>
     {value => /* render something based on the context value */}
   </ThemeContext.Consumer>
   ```
   Consumer component ব্যবহার করে context এর data dynamically render করা হয়।

এই তিনটি অংশ Context API এর মাধ্যমে data share এবং access এর কাজকে সহজ করে।

---

### ⚙️ Implementing Context API in React

React এ Context API implement করতে, প্রথমে context তৈরি করা হয়, তারপর provider component এর মাধ্যমে data provide করা হয় এবং consumer component এর মাধ্যমে context থেকে data access করা হয়। নিচে একটি basic উদাহরণ দেখানো হলো।

#### Example: Implementing Theme Context

```javascript
import React, { createContext, useState, useContext } from "react";

// Step 1: Create a Context
const ThemeContext = createContext();

// Step 2: Create a Provider Component
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState("light");

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

// Step 3: Create a Component that Consumes the Context
function ThemedButton() {
  const { theme, setTheme } = useContext(ThemeContext);

  return (
    <button
      onClick={() => setTheme(theme === "light" ? "dark" : "light")}
      style={{
        background: theme === "light" ? "#fff" : "#333",
        color: theme === "light" ? "#000" : "#fff",
      }}
    >
      Toggle Theme
    </button>
  );
}

// Step 4: Use the Provider in the App Component
function App() {
  return (
    <ThemeProvider>
      <ThemedButton />
    </ThemeProvider>
  );
}

export default App;
```

**Explanation**:

1. **Context Creation**: `ThemeContext` তৈরি করা হয়েছে, যা theme সংক্রান্ত data রাখবে।
2. **Provider Component**: `ThemeProvider` component `ThemeContext.Provider` এর মাধ্যমে data provide করছে। `theme` এবং `setTheme` value হিসাবে context এ pass করা হয়েছে।
3. **Consumer Component**: `ThemedButton` component `useContext` hook এর মাধ্যমে `ThemeContext` থেকে data access করছে এবং button এর theme dynamically update করছে।
4. **Using the Provider**: `App` component এ `ThemeProvider` ব্যবহার করে পুরো application এ `theme` context provide করা হয়েছে।

এই উদাহরণে, Context API ব্যবহার করে একটি global theme তৈরি করা হয়েছে, যা application এর যেকোনো component এ dynamically access করা সম্ভব।

---

### 📖 Real-life Examples

নিচে Context API এর দুটি বাস্তব উদাহরণ রয়েছে, যা এই প্যাটার্নটির কাজকে আরও ভালভাবে বোঝাবে।

#### Example 1: User Authentication Context

ধরুন, আমাদের একটি application আছে যেখানে user authentication status check করা প্রয়োজন। Context API ব্যবহার করে আমরা একটি central authentication context তৈরি করতে পারি, যা application এর বিভিন্ন component এ সহজেই access করা যাবে।

```javascript
import React, { createContext, useState, useContext } from "react";

// Create an Authentication Context
const AuthContext = createContext();

function AuthProvider({ children }) {
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  const login = () => setIsAuthenticated(true);
  const logout = () => setIsAuthenticated(false);

  return (
    <AuthContext.Provider value={{ isAuthenticated, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

// Component that Consumes the Auth Context
function UserStatus() {
  const { isAuthenticated, login, logout } = useContext(AuthContext);

  return (
    <div>
      {isAuthenticated ? (
        <>
          <p>User is logged in</p>
          <button onClick={logout}>Logout</button>
        </>
      ) : (
        <>
          <p>User is logged out</p>
          <button onClick={login}>Login</button>
        </>
      )}
    </div>
  );
}

function App() {
  return (
    <AuthProvider>
      <UserStatus />
    </AuthProvider>
  );
}

export default App;
```

**Explanation**:

1. **AuthContext Creation**: `AuthContext` তৈরি করা হয়েছে, যা user এর authentication status সংরক্ষণ করবে।
2. **Provider Component**: `AuthProvider` component এ `isAuthenticated`, `login`, এবং `logout` method value হিসেবে provide করা হয়েছে।
3. **Consumer Component**: `UserStatus` component `AuthContext` থেকে `isAuthenticated` status access করছে এবং user এর login বা logout status অনুযায়ী UI render করছে।
4. **Using the Provider**: `App` component এ `AuthProvider` ব্যবহার করা হয়েছে, যা পুরো application এ authentication context provide করছে।

এই উদাহরণে, Context API ব্যবহার করে একটি central authentication state তৈরি করা হয়েছে, যা application এর বিভিন্ন component এ ব্যবহার করা যায়।

---

#### Example 2: Language Context for Multilingual Application

একটি multilingual application এর জন্য language context তৈরি করা যায়, যেখানে user এর পছন্দ অনুযায়ী language change করা যায়।

```javascript
import React, { createContext, useState, useContext } from "react";

// Create a Language Context
const LanguageContext = createContext();

function LanguageProvider({ children }) {
  const [language, setLanguage] = useState("en");

  const switchLanguage = (lang) => setLanguage(lang);

  return (
    <LanguageContext.Provider value={{ language, switchLanguage }}>
      {children}
    </LanguageContext.Provider>
  );
}

// Component that Consumes the Language Context
function LanguageSwitcher() {
  const { language, switchLanguage } = useContext(LanguageContext);

  return (
    <div>
      <p>Current Language: {language}</p>
      <button onClick={() => switchLanguage("en")}>English</button>
      <button onClick={() => switchLanguage("es")}>Spanish</button>
    </div>
  );
}

function App() {
  return (
    <LanguageProvider>
      <LanguageSwitcher />
    </LanguageProvider>
  );
}

export default App;
```

**Explanation**:

1. **LanguageContext Creation**: `LanguageContext` তৈরি করা হয়েছে, যা user এর language preference সংরক্ষণ করবে।
2. **Provider Component**: `LanguageProvider` component এ `language` এবং `switchLanguage` function provide করা হয়েছে।
3. **Consumer Component**: `LanguageSwitcher` component এ `useContext` hook এর মাধ্যমে `LanguageContext` থেকে data access করা হচ্ছে এবং language switch এর জন্য UI প্রদান করা হচ্ছে।
4. **Using the Provider**: `App` component এ `LanguageProvider` ব্যবহার করা হয়েছে, যা পুরো application এ language context provide করছে।

এই উদাহরণে, Context API ব্যবহার করে একটি central language management system তৈরি করা হয়েছে, যা user এর ভাষার প

ছন্দ অনুযায়ী UI change করতে সাহায্য করে।

---

### ✅ Best Practices for Context API

Context API ব্যবহার করার সময় কিছু Best Practices অনুসরণ করলে code structure আরও পরিষ্কার এবং maintainable হয়।

1. **Avoid Overusing Context**: প্রতিটি data এর জন্য context ব্যবহার না করে গুরুত্বপূর্ণ এবং frequently accessed data এর জন্য context ব্যবহার করুন।
2. **Use Separate Contexts for Different Data**: বিভিন্ন ধরনের data এর জন্য আলাদা context ব্যবহার করুন যাতে code আরও modular থাকে।
3. **Minimize Re-renders**: Context value change করলে re-render হয়, তাই যে data প্রায়ই পরিবর্তিত হয় তা context এ না রাখা ভালো।
4. **Document Context Usage**: Context API ব্যবহার করার সময় context এর প্রতিটি অংশের জন্য উপযুক্ত comments এবং documentation প্রদান করুন।

---

React এ Context API প্যাটার্ন component গুলোর মধ্যে data share এবং accessibility সহজ করে তোলে। এটি component কে আরও modular, reusable এবং flexible করে তোলে। Proper implementation এবং best practices অনুসরণ করে Context API ব্যবহার করলে React এ উন্নত মানের application তৈরি করা সম্ভব। 😊

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-16: How to Use React Context API

## Table of Contents

- [Overview of Context API](#overview-of-context-api)
- [When to Use Context API](#when-to-use-context-api)
- [Steps to Implement Context API](#steps-to-implement-context-api)
  - [1. Creating a Context](#1-creating-a-context)
  - [2. Providing the Context](#2-providing-the-context)
  - [3. Consuming the Context](#3-consuming-the-context)
- [Example: Theme Context in a Simple Application](#example-theme-context-in-a-simple-application)
- [Best Practices](#best-practices)

---

### 📘 Overview of Context API

React **Context API** হলো এমন একটি প্যাটার্ন যা component গুলোর মধ্যে data share করার জন্য ব্যবহার করা হয়। সাধারণত, React এ data pass করার জন্য **props drilling** করতে হয়, যা খুবই জটিল হয়ে ওঠে যখন nested component structure বড় হয়। Context API ব্যবহার করে data সরাসরি parent থেকে deep-nested child component এ pass করা যায়, যা props drilling এর প্রয়োজনীয়তা দূর করে।

---

### 🧐 When to Use Context API

Context API সাধারণত এমন পরিস্থিতিতে ব্যবহার করা হয় যখন data বা state application এর একাধিক component এ প্রয়োজন হয়। Context API এর সাধারণ use cases:

1. **Authentication State**: Logged-in user এর তথ্য application এর বিভিন্ন স্থানে প্রয়োজন হলে।
2. **Theme Management**: Light এবং dark mode এর মত global theme switch করার জন্য।
3. **Language Preference**: Multilingual applications এ preferred language context হিসেবে সংরক্ষণ করতে।

Context API ব্যবহার করার আগে নিশ্চিত হোন যে data টি সত্যিই global level এ প্রয়োজন; অন্যথায়, শুধুমাত্র props ব্যবহার করা ভালো।

---

### 🔍 Steps to Implement Context API

React এ Context API implement করতে প্রধানত তিনটি ধাপ অনুসরণ করতে হয়।

---

#### 1. Creating a Context

প্রথমে একটি context তৈরি করতে হয়। Context তৈরি করতে `React.createContext()` function ব্যবহার করা হয়।

```javascript
import React, { createContext } from "react";

// Creating a Theme Context
const ThemeContext = createContext();
```

**Explanation**:

- `ThemeContext` নামক একটি context তৈরি করা হয়েছে যা data সংরক্ষণ করতে সাহায্য করবে।
- এই context এর মাধ্যমে আমরা data globally provide এবং consume করতে পারব।

---

#### 2. Providing the Context

Context তৈরি করার পরে, এটি **Provider** component এর মাধ্যমে component tree তে provide করা হয়। Provider component এর মাধ্যমে context data সকল child component এ accessible হয়ে যায়।

```javascript
import React, { useState } from "react";

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState("light");

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export { ThemeProvider, ThemeContext };
```

**Explanation**:

- `ThemeProvider` component `ThemeContext.Provider` কে wrap করে এবং `value` prop এর মাধ্যমে data provide করে।
- `theme` এবং `setTheme` value হিসেবে `ThemeContext` এ pass করা হয়েছে, যা child component গুলো access করতে পারবে।
- এই provider component যেকোনো nested component এ context data access করতে সহায়ক।

---

#### 3. Consuming the Context

Context data consume করতে **Consumer component** বা **useContext hook** ব্যবহার করা হয়। Consumer component বা useContext hook ব্যবহার করে child component context থেকে data access করতে পারে।

```javascript
import React, { useContext } from "react";
import { ThemeContext } from "./ThemeProvider";

function ThemedButton() {
  const { theme, setTheme } = useContext(ThemeContext);

  return (
    <button
      onClick={() => setTheme(theme === "light" ? "dark" : "light")}
      style={{
        backgroundColor: theme === "light" ? "#fff" : "#333",
        color: theme === "light" ? "#000" : "#fff",
      }}
    >
      Toggle Theme
    </button>
  );
}

export default ThemedButton;
```

**Explanation**:

- `useContext(ThemeContext)` এর মাধ্যমে `theme` এবং `setTheme` access করা হয়েছে।
- Button এর style `theme` এর উপর নির্ভর করে change হচ্ছে এবং click event এ theme toggle হচ্ছে।

---

### 📖 Example: Theme Context in a Simple Application

একটি simple উদাহরণ দেখা যাক যেখানে আমরা Context API ব্যবহার করে একটি theme context তৈরি করব এবং তা button এর মাধ্যমে toggle করব।

```javascript
import React, { createContext, useState, useContext } from "react";

// Step 1: Create a Context
const ThemeContext = createContext();

// Step 2: Create a Provider Component
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState("light");

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

// Step 3: Create a Component that Consumes the Context
function ThemedButton() {
  const { theme, setTheme } = useContext(ThemeContext);

  return (
    <button
      onClick={() => setTheme(theme === "light" ? "dark" : "light")}
      style={{
        backgroundColor: theme === "light" ? "#fff" : "#333",
        color: theme === "light" ? "#000" : "#fff",
      }}
    >
      Toggle Theme
    </button>
  );
}

// Step 4: Use the Provider in the App Component
function App() {
  return (
    <ThemeProvider>
      <ThemedButton />
    </ThemeProvider>
  );
}

export default App;
```

**Explanation**:

1. **Creating the Context**: `ThemeContext` নামে একটি context তৈরি করা হয়েছে যা theme data store করবে।
2. **Providing the Context**: `ThemeProvider` component `ThemeContext.Provider` কে wrap করে এবং `theme` এবং `setTheme` value হিসেবে provide করছে।
3. **Consuming the Context**: `ThemedButton` component `useContext` hook ব্যবহার করে `ThemeContext` থেকে `theme` এবং `setTheme` access করছে এবং button এর মাধ্যমে theme toggle করছে।
4. **Using the Provider**: `App` component এ `ThemeProvider` ব্যবহার করে, পুরো application এ theme context provide করা হয়েছে।

**Output**:

- Button click করলে theme light থেকে dark এ এবং dark থেকে light এ toggle হবে।

---

### ✅ Best Practices for Context API

Context API ব্যবহারের সময় কিছু Best Practices অনুসরণ করলে code structure আরও পরিষ্কার এবং maintainable হয়।

1. **Limit Context Usage to Global Data**: প্রতিটি data এর জন্য context ব্যবহার না করে, শুধুমাত্র global data এর জন্য context ব্যবহার করুন।
2. **Use Multiple Contexts for Different Data**: বিভিন্ন ধরনের data এর জন্য আলাদা context ব্যবহার করুন, যাতে code আরও modular থাকে।
3. **Memoize Context Values**: Context value প্রায়ই পরিবর্তিত হলে re-renders কমানোর জন্য `useMemo` ব্যবহার করতে পারেন।
4. **Clear Documentation**: Context API এর প্রতিটি অংশের জন্য উপযুক্ত comments এবং documentation ব্যবহার করুন।

---

React এর Context API প্যাটার্নটি component গুলোর মধ্যে global data share করার জন্য একটি গুরুত্বপূর্ণ টুল। এটি component কে modular, reusable এবং flexible করে তোলে। Proper implementation এবং best practices অনুসরণ করে Context API ব্যবহার করলে React এ উন্নত মানের application তৈরি করা সম্ভব। 😊

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-17: React Context API: `contextType` & `useContext` Hook

## Table of Contents

- [Introduction to Context API](#introduction-to-context-api)
- [What is `contextType`](#what-is-contexttype)
- [How to Use `contextType`](#how-to-use-contexttype)
- [The `useContext` Hook Explained](#the-usecontext-hook-explained)
- [Comparing `contextType` and `useContext`](#comparing-contexttype-and-usecontext)
- [Real-life Examples](#real-life-examples)
- [Best Practices](#best-practices)

---

### 📘 Introduction to Context API

React **Context API** হলো এমন একটি tool যা component গুলোর মধ্যে data share করার জন্য ব্যবহৃত হয়। Context API props drilling এর পরিবর্তে একটি central location থেকে data access করতে সাহায্য করে, যা data management সহজ করে। Context API তে `Provider` এবং `Consumer` থাকে, যেগুলি combined করে global data sharing করা সম্ভব।

Context API এর সাথে দুটি গুরুত্বপূর্ণ concept রয়েছে: **`contextType`** এবং **`useContext` hook**। এগুলি context data consume করার জন্য দুটি ভিন্ন পদ্ধতি প্রদান করে।

---

### 🧐 What is `contextType`

`contextType` হলো একটি static property যা class components এ context data access করতে ব্যবহৃত হয়। যখন একটি class component এ context ব্যবহার করতে হয়, তখন `contextType` property এর মাধ্যমে context সরাসরি component এ access করা যায়। এটি শুধুমাত্র class component এর ক্ষেত্রে কার্যকর।

#### Syntax of `contextType`

```javascript
class MyComponent extends React.Component {
  static contextType = MyContext;

  render() {
    return <div>Context Value: {this.context}</div>;
  }
}
```

**Explanation**:

- `MyComponent` class এ `static contextType = MyContext` ব্যবহার করে `MyContext` context এ সংযুক্ত করা হয়েছে।
- `this.context` ব্যবহার করে context এর data access করা যায়।

---

### 🔍 How to Use `contextType`

`contextType` ব্যবহার করার জন্য, context কে `static contextType` property হিসেবে define করতে হয় এবং `this.context` এর মাধ্যমে data access করা হয়। এটি শুধুমাত্র একক context ব্যবহার করার জন্য উপযুক্ত এবং nested বা multiple contexts এর জন্য ideal নয়।

#### Example of `contextType`

```javascript
import React, { createContext, Component } from "react";

// Create a Context
const ThemeContext = createContext("light");

class ThemedComponent extends Component {
  static contextType = ThemeContext;

  render() {
    return (
      <div
        style={{
          backgroundColor: this.context === "light" ? "#fff" : "#333",
          color: this.context === "light" ? "#000" : "#fff",
        }}
      >
        Current Theme: {this.context}
      </div>
    );
  }
}

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <ThemedComponent />
    </ThemeContext.Provider>
  );
}

export default App;
```

**Explanation**:

1. **Creating the Context**: `ThemeContext` নামে একটি context তৈরি করা হয়েছে যা default value হিসেবে `"light"` গ্রহণ করে।
2. **Using `contextType` in Class Component**: `ThemedComponent` class এ `static contextType = ThemeContext` ব্যবহার করে context data access করা হয়েছে।
3. **Rendering Context Data**: `this.context` এর মাধ্যমে context এর current theme dynamically render করা হচ্ছে।
4. **Using the Provider**: `App` component এ `ThemeContext.Provider` ব্যবহার করে context value হিসেবে `"dark"` pass করা হয়েছে।

---

### ⚙️ The `useContext` Hook Explained

**`useContext` hook** হলো একটি React hook যা functional components এ context consume করতে ব্যবহৃত হয়। এটি সহজে context data access করতে সাহায্য করে এবং props drilling ছাড়াই context থেকে সরাসরি data retrieve করে।

#### Syntax of `useContext`

```javascript
const contextValue = useContext(MyContext);
```

**Explanation**:

- `useContext` hook এর মাধ্যমে `MyContext` এর data access করা যায়।
- `useContext` শুধুমাত্র functional components এ কাজ করে এবং context কে props হিসেবে সরাসরি pass করার প্রয়োজনীয়তা দূর করে।

#### Example of `useContext`

```javascript
import React, { createContext, useContext } from "react";

// Create a Context
const ThemeContext = createContext("light");

function ThemedButton() {
  const theme = useContext(ThemeContext);

  return (
    <button
      style={{
        backgroundColor: theme === "light" ? "#fff" : "#333",
        color: theme === "light" ? "#000" : "#fff",
      }}
    >
      Current Theme: {theme}
    </button>
  );
}

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <ThemedButton />
    </ThemeContext.Provider>
  );
}

export default App;
```

**Explanation**:

1. **Creating the Context**: `ThemeContext` context তৈরি করা হয়েছে যা default value `"light"` ধারণ করে।
2. **Using `useContext` Hook**: `ThemedButton` component এ `useContext(ThemeContext)` ব্যবহার করে theme value access করা হয়েছে।
3. **Rendering Theme Data**: button এর background এবং color `theme` value এর উপর ভিত্তি করে পরিবর্তিত হচ্ছে।
4. **Providing the Context**: `App` component এ `ThemeContext.Provider` ব্যবহার করে theme value `"dark"` set করা হয়েছে।

---

### 🔄 Comparing `contextType` and `useContext`

| Feature         | `contextType`                             | `useContext`                                 |
| --------------- | ----------------------------------------- | -------------------------------------------- |
| **Usage**       | Only works in class components            | Only works in functional components          |
| **Syntax**      | `static contextType = MyContext`          | `const value = useContext(MyContext)`        |
| **Limitations** | Limited to a single context per component | Supports multiple contexts easily            |
| **When to Use** | For older class-based codebases           | For modern, hook-based functional components |

---

### 📖 Real-life Examples

#### Example 1: Authentication Status with `useContext`

একটি application এ logged-in user এর authentication status handle করার জন্য context API এবং `useContext` ব্যবহার করা যায়।

```javascript
import React, { createContext, useContext, useState } from "react";

// Create Auth Context
const AuthContext = createContext();

function AuthProvider({ children }) {
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  const login = () => setIsAuthenticated(true);
  const logout = () => setIsAuthenticated(false);

  return (
    <AuthContext.Provider value={{ isAuthenticated, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

function UserStatus() {
  const { isAuthenticated, login, logout } = useContext(AuthContext);

  return (
    <div>
      {isAuthenticated ? (
        <>
          <p>Welcome back!</p>
          <button onClick={logout}>Logout</button>
        </>
      ) : (
        <>
          <p>Please log in.</p>
          <button onClick={login}>Login</button>
        </>
      )}
    </div>
  );
}

function App() {
  return (
    <AuthProvider>
      <UserStatus />
    </AuthProvider>
  );
}

export default App;
```

**Explanation**:

1. **Auth Context Creation**: `AuthContext` তৈরি করা হয়েছে যা authentication data store করে।
2. **Provider Component**: `AuthProvider` component এ `isAuthenticated`, `login`, এবং `logout` function provide করা হয়েছে।
3. **Consuming Context with `useContext`**: `UserStatus` component এ `useContext(AuthContext)` ব্যবহার করে authentication data access এবং update করা হয়েছে।

---

#### Example 2: Using `contextType` for User Preferences in Class Components

একটি class component এ user এর preferred language context handle করার জন্য `contextType` ব্যবহার করা যেতে পারে।

```javascript
import React, { createContext, Component } from "react";

// Create Language Context
const LanguageContext = createContext("en");

class LanguageDisplay extends Component {
  static contextType = LanguageContext;

  render() {
    return (
      <div>
        Preferred Language: {this.context === "en" ? "English" : "Spanish"}
      </div>
    );
  }
}

function App() {
  return (
    <LanguageContext.Provider value="es">
      <LanguageDisplay />
    </LanguageContext.Provider>
  );
}

export default App;
```

**Explanation**:

1. **Creating Language Context**: `LanguageContext` তৈরি করা হয়েছে এবং default value `"en"` প্রদান করা হয়েছে।
2. **Using `contextType` in Class Component**: `LanguageDisplay` class component এ `contextType` এর মাধ্যমে `LanguageContext` এ সংযুক্ত করা হয়েছে।
3. **Accessing Context with `this.context`**: `this.context` ব্যবহার করে preferred language dynamically display করা হচ্ছে।
4. **Providing Context**: `App` component এ `LanguageContext.Provider` ব্যবহার করে value `"es"` set করা হয়েছে।

---

### ✅ Best Practices for Using `contextType` and `useContext`

1. **Use `useContext` for Modern Functional Components**: Functional component এ `useContext` ব্যবহারের ফলে code সহজ এবং concise হয়।
2. **Use `contextType` in Legacy Class Components**: পুরোনো class component গুলোর জন্য `contextType` ব্যবহার করা উচিত।
3. **Limit Context Usage to Necessary Data**: শুধুমাত্র essential এবং frequently accessed data context এ রাখা উচিত।
4. **Clear Documentation**: Context API ব্যবহারের সময় `contextType`

এবং `useContext` এর প্রতিটি অংশের জন্য উপযুক্ত comments এবং documentation প্রদান করুন।

---

React এ **`contextType`** এবং **`useContext`** দুটি গুরুত্বপূর্ণ tool, যা Context API ব্যবহার করে component গুলোর মধ্যে data sharing সহজ করে। `useContext` functional component এর জন্য অত্যন্ত উপযোগী, যেখানে `contextType` class component এর জন্য উপযোগী। Proper usage এবং best practices অনুসরণ করে Context API এবং এর সাথে সংশ্লিষ্ট tools ব্যবহার করলে React এ আরও maintainable এবং scalable application তৈরি করা সম্ভব। 😊

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-18: React Hooks

## Table of Contents

- [Introduction to React Hooks](#introduction-to-react-hooks)
- [Why Use Hooks?](#why-use-hooks)
- [Essential React Hooks](#essential-react-hooks)
  - [1. `useState`](#1-usestate)
  - [2. `useEffect`](#2-useeffect)
  - [3. `useContext`](#3-usecontext)
- [Additional React Hooks](#additional-react-hooks)
  - [1. `useReducer`](#1-usereducer)
  - [2. `useRef`](#2-useref)
  - [3. `useMemo`](#3-usememo)
  - [4. `useCallback`](#4-usecallback)
- [Real-life Examples](#real-life-examples)
- [Best Practices](#best-practices)

---

### 📘 Introduction to React Hooks

**React Hooks** হলো React 16.8 এ পরিচিত একটি feature যা functional components এ state এবং lifecycle methods ব্যবহারের সুযোগ দেয়। সাধারণত class components এ state এবং lifecycle methods ব্যবহৃত হতো, তবে Hooks আসার পর functional components এও এই সুবিধা যুক্ত হয়েছে। এর ফলে code structure আরও সহজ ও পরিষ্কার হয়েছে।

React Hooks এর মাধ্যমে component গুলোকে reusable এবং modular করা সহজ হয়, কারণ Hooks একই logic বারবার ব্যবহারের সুযোগ দেয় এবং component এর মধ্যে এর behavior আলাদা রাখা সম্ভব করে।

---

### 🧐 Why Use Hooks?

Hooks React এর structure এবং code লেখা পদ্ধতিতে একটি বড় পরিবর্তন এনেছে। এটি ব্যবহার করার প্রধান কারণগুলো হলো:

1. **Functional Components Only**: Hooks এর মাধ্যমে শুধুমাত্র functional components ব্যবহার করে state এবং lifecycle logic handle করা যায়, যা class components এর প্রয়োজনীয়তা দূর করে।
2. **Reusable Logic**: Hooks একই logic কে reusable করে, যা component গুলোর মধ্যে common logic share করতে সহায়ক।
3. **Simplifies Code Structure**: Hooks component structure কে আরো সহজ এবং maintainable করে।
4. **Avoids Prop Drilling**: Context API এর সাথে `useContext` ব্যবহার করে nested components এর মধ্যে data সহজে pass করা যায়।

---

### 🔍 Essential React Hooks

#### 1. `useState`

**`useState`** হলো এমন একটি Hook যা component এ state তৈরি এবং পরিচালনা করতে ব্যবহৃত হয়। এটি একটি initial state গ্রহণ করে এবং সেই state এর current value এবং একটি function প্রদান করে যা state update করতে সাহায্য করে।

**Syntax**:

```javascript
const [state, setState] = useState(initialValue);
```

**Example**:

```javascript
import React, { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

**Explanation**:

- `count` একটি state variable যা `useState(0)` এর মাধ্যমে initialize হয়েছে।
- `setCount` function এর মাধ্যমে `count` update করা হয়, যা button এর click event এ call করা হয়।

---

#### 2. `useEffect`

**`useEffect`** হলো একটি Hook যা side effects handle করতে ব্যবহৃত হয়, যেমন data fetch করা, DOM update করা, বা timer set করা। এটি component এর rendering এর পর execute হয় এবং dependency array এর উপর ভিত্তি করে re-run হয়।

**Syntax**:

```javascript
useEffect(() => {
  // Side effect code
}, [dependencies]);
```

**Example**:

```javascript
import React, { useState, useEffect } from "react";

function DataFetcher() {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch("https://api.example.com/data")
      .then((response) => response.json())
      .then((result) => setData(result));
  }, []);

  return <div>{data ? JSON.stringify(data) : "Loading..."}</div>;
}
```

**Explanation**:

- Data fetch করার জন্য `useEffect` ব্যবহার করা হয়েছে, যা component render এর পর execute হয়।
- `[]` empty dependency array প্রদান করা হয়েছে, ফলে এই effect শুধুমাত্র একবার run হবে।

---

#### 3. `useContext`

**`useContext`** হলো এমন একটি Hook যা Context API এর মাধ্যমে global state বা data consume করতে সাহায্য করে। এটি props drilling এড়াতে এবং context থেকে সরাসরি data access করতে ব্যবহৃত হয়।

**Syntax**:

```javascript
const contextValue = useContext(MyContext);
```

**Example**:

```javascript
import React, { createContext, useContext } from "react";

const ThemeContext = createContext("light");

function ThemedComponent() {
  const theme = useContext(ThemeContext);

  return <div>Current Theme: {theme}</div>;
}

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <ThemedComponent />
    </ThemeContext.Provider>
  );
}
```

**Explanation**:

- `useContext` Hook ব্যবহার করে `ThemeContext` থেকে theme value সরাসরি access করা হয়েছে।
- `ThemeContext.Provider` এর মাধ্যমে `ThemedComponent` context এ provide করা value access করতে পারে।

---

### 🔄 Additional React Hooks

#### 1. `useReducer`

**`useReducer`** একটি complex state management Hook যা reducer function ব্যবহার করে state এবং dispatch function প্রদান করে। এটি `useState` এর মতোই কাজ করে, তবে complex logic handle করার জন্য এটি বেশি কার্যকর।

**Syntax**:

```javascript
const [state, dispatch] = useReducer(reducer, initialState);
```

**Example**:

```javascript
import React, { useReducer } from "react";

function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: "increment" })}>Increment</button>
      <button onClick={() => dispatch({ type: "decrement" })}>Decrement</button>
    </div>
  );
}
```

---

#### 2. `useRef`

**`useRef`** হলো এমন একটি Hook যা component এর মধ্যে mutable reference তৈরি করতে ব্যবহৃত হয়। এটি DOM element এর reference তৈরি করতে বা value persist করতে ব্যবহৃত হয়।

**Syntax**:

```javascript
const ref = useRef(initialValue);
```

**Example**:

```javascript
import React, { useRef } from "react";

function TextInputFocus() {
  const inputRef = useRef(null);

  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={() => inputRef.current.focus()}>Focus Input</button>
    </div>
  );
}
```

---

#### 3. `useMemo`

**`useMemo`** একটি Hook যা computationally expensive function এর result কে cache করতে সাহায্য করে, যাতে rerendering এর সময় computation বারবার না হয়।

**Syntax**:

```javascript
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

**Example**:

```javascript
import React, { useMemo, useState } from "react";

function ExpensiveCalculationComponent({ number }) {
  const calculatedValue = useMemo(() => {
    return expensiveCalculation(number);
  }, [number]);

  return <div>Calculated Value: {calculatedValue}</div>;
}
```

---

#### 4. `useCallback`

**`useCallback`** এমন একটি Hook যা function এর instance কে cache করে এবং dependency পরিবর্তন না হলে সেই instance পুনরায় ব্যবহার করে।

**Syntax**:

```javascript
const memoizedCallback = useCallback(() => {
  // Function code
}, [dependencies]);
```

---

### 📖 Real-life Examples

#### Example 1: User Authentication with `useContext` and `useState`

```javascript
import React, { createContext, useContext, useState } from "react";

const AuthContext = createContext();

function AuthProvider({ children }) {
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  const login = () => setIsAuthenticated(true);
  const logout = () => setIsAuthenticated(false);

  return (
    <AuthContext.Provider value={{ isAuthenticated, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

function UserStatus() {
  const { isAuthenticated, login, logout } = useContext(AuthContext);

  return (
    <div>
      {isAuthenticated ? (
        <>
          <p>Welcome, User!</p>
          <button onClick={logout}>Logout</button>
        </>
      ) : (
        <>
          <p>Please log in.</p>
          <button onClick={login}>Login</button>
        </>
      )}
    </div>
  );
}

function App() {
  return (
    <AuthProvider>
      <UserStatus />
    </AuthProvider>
  );
}

export default App;
```

#### Example 2: Theme Toggle with `useState` and `useContext`

```javascript
import React, { createContext, useState, useContext } from "react";

const ThemeContext = createContext();

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState("light");

  const toggleTheme = () => set;

  Theme(theme === "light" ? "dark" : "light");

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

function ThemedComponent() {
  const { theme, toggleTheme } = useContext(ThemeContext);

  return (
    <div
      style={{
        backgroundColor: theme === "light" ? "#fff" : "#333",
        color: theme === "light" ? "#000" : "#fff",
      }}
    >
      <p>Current Theme: {theme}</p>
      <button onClick={toggleTheme}>Toggle Theme</button>
    </div>
  );
}

function App() {
  return (
    <ThemeProvider>
      <ThemedComponent />
    </ThemeProvider>
  );
}

export default App;
```

---

### ✅ Best Practices for Using Hooks

1. **Use Hooks Only in Functional Components**: Hooks শুধুমাত্র functional components এ ব্যবহার করা উচিত।
2. **Follow Hook Rules**: Hooks এর মাধ্যমে nested structure এড়ানো উচিত এবং শুধুমাত্র top-level এ use করা উচিত।
3. **Optimize with `useMemo` and `useCallback`**: Expensive computations এবং unnecessary re-renders কমাতে `useMemo` এবং `useCallback` ব্যবহার করুন।
4. **Use Custom Hooks for Reusable Logic**: Custom Hooks তৈরি করে reusable logic encapsulate করা উচিত।

React Hooks component structure আরও modular, reusable, এবং maintainable করতে সাহায্য করে। Proper usage এবং best practices অনুসরণ করে Hooks ব্যবহারে React application এ আরও উন্নত performance এবং code clarity অর্জন করা যায়। 😊

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-19:

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-20:

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-21:

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Project-01:

### Difficulty: Easy (2/10)

### You Will Learn

-

### Project Description

### Project Screenshot

### Live Project Link

[Open in CodePen]()

### Video Explanation

Coming Soon...

### Project Source Codes

[Source Codes]()
