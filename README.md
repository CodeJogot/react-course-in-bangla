# Learn ReactJS in 30 Chapters

### After completing this course, we'll build [5 Projects](#) with ReactJS.

While you complete the 30-chapter module, jump in the [Projects Section](#).

|                                    Chapter                                     |                                                               Topics                                                               | Video Explanation |
| :----------------------------------------------------------------------------: | :--------------------------------------------------------------------------------------------------------------------------------: | :---------------: |
|                                    [00](#)                                     |                                                                []()                                                                |   [Watch Now]()   |
|                   [01](#chapter-01-introduction-to-reactjs)                    |                                  [Introduction to React.js](#chapter-01-introduction-to-reactjs)                                   |   [Watch Now]()   |
|                   [01.1](#chapter-011-library-vs-framework)                    |                                      [Libray vs Framework](#chapter-011-library-vs-framework)                                      |   [Watch Now]()   |
|                 [02](#chapter-02-react-virtual-dom-what--why)                  |                              [React Virtual DOM: What & Why](#chapter-02-react-virtual-dom-what--why)                              |     Watch Now     |
| [03](#chapter-03-how-to-install-react-step-by-step-guide-with-example-project) | [How to Install React (Step by Step Guide with Example)](#chapter-03-how-to-install-react-step-by-step-guide-with-example-project) |     Watch Now     |
|                      [04](#chapter-04-react-render-html)                       |                                         [React Render HTML](#chapter-04-react-render-html)                                         |     Watch Now     |
|                          [05](#chapter-05-react-jsx)                           |                                                 [React JSX](#chapter-05-react-jsx)                                                 |     Watch Now     |
|                       [06](#chapter-06-react-components)                       |                                          [React Components](#chapter-06-react-components)                                          |     Watch Now     |
|                    [07](#chapter-07-react-class-components)                    |                                    [React Class Components](#chapter-07-react-class-components)                                    |     Watch Now     |
|                         [08](#chapter-08-react-props)                          |                                               [React Props](#chapter-08-react-props)                                               |     Watch Now     |
|          [09](#chapter-09-react-state--lifecycle-in-class-components)          |               [React State & Lifecycle in Class Components](#chapter-09-react-state--lifecycle-in-class-components)                |     Watch Now     |
|                         [10](#chapter-10-react-events)                         |                                              [React Events](#chapter-10-react-events)                                              |     Watch Now     |
|                 [11](#chapter-11-react-conditional-rendering)                  |                               [React Conditional Rendering](#chapter-11-react-conditional-rendering)                               |     Watch Now     |
|                                    [12](#)                                     |                                            [](#chapter-12-css-float-display-alignment)                                             |     Watch Now     |
|                         [13](#chapter-13-css-flexbox)                          |                                                    [](#chapter-13-css-flexbox)                                                     |     Watch Now     |
|                        [14](#chapter-14-css-selectors)                         |                                                   [](#chapter-14-css-selectors)                                                    |     Watch Now     |
|                    [15](#chapter-15-css-text-fonts--icons)                     |                                               [](#chapter-15-css-text-fonts--icons)                                                |     Watch Now     |
|          [16](#chapter-16-css-links-lists-tables-display--max-width)           |                                     [](#chapter-16-css-links-lists-tables-display--max-width)                                      |     Watch Now     |
|             [17](#chapter-17-css-image-gallery-and-image-sprites)              |                                        [](#chapter-17-css-image-gallery-and-image-sprites)                                         |     Watch Now     |
|                                       18                                       |                                                                                                                                    |     Watch Now     |
|            [19](#chapter-19-visualize-and-play-with-css-properties)            |                                       [](#chapter-19-visualize-and-play-with-css-properties)                                       |     Watch Now     |
|                       [20](#chapter-20-css-grid-layout)                        |                                                  [](#chapter-20-css-grid-layout)                                                   |     Watch Now     |
|                         [21](#chapter-21-css-gradient)                         |                                                    [](#chapter-21-css-gradient)                                                    |     Watch Now     |
|                   [22](#chapter-22-css-2d-and-3d-transforms)                   |                                              [](#chapter-22-css-2d-and-3d-transforms)                                              |     Watch Now     |
|                        [23](#chapter-23-css-animations)                        |                                                                []()                                                                |     Watch Now     |
|                                       24                                       |                                                                                                                                    |     Watch Now     |
|                                       25                                       |                                                                                                                                    |     Watch Now     |
|                                       26                                       |                                                                                                                                    |     Watch Now     |
|                                       27                                       |                                                                                                                                    |     Watch Now     |
|                                       28                                       |                                                                                                                                    |     Watch Now     |
|                                       29                                       |                                                                                                                                    |     Watch Now     |
|                                       30                                       |                                                                                                                                    |     Watch Now     |

# 5 React.js Projects

|                     Project No.                      |                    Project Name                    | Video Explanation |   Live Demo   |
| :--------------------------------------------------: | :------------------------------------------------: | :---------------: | :-----------: |
|                          01                          |                                                    |     Watch Now     |   Live Demo   |
|  [02](#project-02-simple-website-layout-with-float)  |  [](#project-02-simple-website-layout-with-float)  |     Watch Now     |   Live Demo   |
| [03](#project-03-simple-website-layout-with-flexbox) | [](#project-03-simple-website-layout-with-flexbox) |     Watch Now     |   Live Demo   |
|                          04                          |                                                    |     Watch Now     |   Live Demo   |
|      [05](#project-05-simple-3d-animation-page)      |      [](#project-05-simple-3d-animation-page)      |  [Watch Now](#)   | [Live Demo]() |

# Chapter-00: How The Course is Designed

### কোর্সটি যেভাবে সাজানো হয়েছেঃ

- এই পুরো Article কে একটা বই মনে করতে পারেন। কোর্সটি 30 টি Chapter এ ভাগ করা হয়েছে। প্রতিটি Chapter এ React.js এর বিভিন্ন Topics নিয়ে আলোচনা করা হয়েছে।
- প্রতিটা Chapter এর Module সাজানো হয়েছে ক্রমানুসারে । উদাহরণস্বরূপ, Chapter-05 এর টপিকসগুলো শিখতে হলে অবশ্যই আপনাকে Chapter-04 শেষ করে আসতে হবে। একইভাবে Chapter-04 শিখতে হলে আপনাকে Chapter-03 শেষ করে আসতে হবে ।
- প্রতিটা Chapter এর Topics এর Written Documentation/Explanation এর সাথে সাথে Video Explanation-ও দেয়া আছে। যাতে শিক্ষার্থীরা খুব সহজেই টপিকসগুলো আত্মস্থ করতে পারে।

### কোর্সটি কাদের জন্য?

- এই কোর্সটিতে যেকেউ অংশগ্রহণ করতে পারবে। শিখার জন্য মনের ইচ্ছাটাই আসল!
- Course টি মূলত Beginner-friendly.

### Prerequisite

- Good understanding of HTML, CSS, JavaScript.

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-01: Introduction to React.js

### Table of Contents:

1. [What is React?](#what-is-react)
   - [Single Page Application (SPA) কি?](#single-page-application-spa-কি)
   - [Component-Based Architecture কি?](#component-based-architecture-কি)
2. [Why Use React?](#why-use-react)
   - [Efficient UI Updates](#efficient-ui-updates)
   - [Example of Efficient UI Updates](#example-of-efficient-ui-updates)
3. [Problems Without React](#problems-without-react)
   - [Manual DOM Manipulation এর জটিলতা](#manual-dom-manipulation-জটিলতা)
   - [Poor Code Reusability](#poor-code-reusability)
   - [Complex State Management](#complex-state-management)
4. [Conclusion](#conclusion)

---

### 1. What is React?

**ReactJS** হলো একটি **JavaScript library** যা user interfaces (UI) তৈরি করতে ব্যবহৃত হয়। এটি মূলত **Single Page Applications (SPA)** এর জন্য ব্যবহৃত হয়, যেখানে web page এর বিভিন্ন অংশ dynamically update হয়, কিন্তু পুরো page reload হয় না। React প্রথমে **Facebook** দ্বারা ২০১৩ সালে তৈরি করা হয় এবং এখন এটি modern web development এর অন্যতম জনপ্রিয় library হিসেবে বিবেচিত হয়।

#### Example of a Simple React Component:

```jsx
function Welcome() {
  return <h1>Hello, React!</h1>;
}

export default Welcome;
```

React এর প্রধান বৈশিষ্ট্য হলো **Component-based Architecture**, যেখানে UI কে ছোট ছোট, পুনরায় ব্যবহারযোগ্য অংশে ভাগ করা যায়।

---

### 1.1 Single Page Application (SPA) কি?

**Single Page Application (SPA)** হলো একটি ধরনের web application, যেখানে একটি page load হওয়ার পর user এর interaction অনুযায়ী page এর বিভিন্ন অংশ dynamically update হয়, কিন্তু পুরো page reload হয় না। Traditional multi-page applications এ প্রতিবার কোনো page পরিবর্তন করার জন্য server থেকে নতুন HTML file fetch করতে হয়, কিন্তু SPA তে এটি প্রয়োজন হয় না। React মূলত SPA তৈরি করার জন্য ব্যবহৃত হয়, যা web applications কে দ্রুততর এবং seamless করে তোলে।

#### Example:

ধরুন, আপনি একটি Traditional web application ব্যবহার করছেন, যেখানে প্রতিবার আপনি কোনো নতুন section এ যান, তখন নতুন একটি HTML পেজ লোড হয় এবং পুরো পেজ রিলোড হয়। কিন্তু **React** ব্যবহার করলে, page এর নির্দিষ্ট অংশ dynamically update হয়, যা user experience কে দ্রুত এবং responsive করে তোলে।

---

### 1.2 Component-Based Architecture কি?

React এর সবচেয়ে শক্তিশালী বৈশিষ্ট্য হলো এর **component-based architecture**। এর মাধ্যমে পুরো UI কে ছোট ছোট পুনঃব্যবহারযোগ্য অংশে ভাগ করা যায়, যাকে **components** বলে। প্রতিটি component একটি নির্দিষ্ট কাজ সম্পন্ন করে এবং UI এর বিভিন্ন অংশের জন্য আলাদা আলাদা component তৈরি করা যায়।

#### Example:

```jsx
function Navbar() {
  return (
    <nav>
      <ul>
        <li>Home</li>
        <li>About</li>
        <li>Contact</li>
      </ul>
    </nav>
  );
}
```

এখানে একটি **Navbar** component তৈরি করা হয়েছে। এখন আপনি Navbar component কে যেকোনো page এ পুনরায় ব্যবহার করতে পারবেন, এবং যদি কোনো পরিবর্তন প্রয়োজন হয়, তবে component এ পরিবর্তন করে সমস্ত জায়গায় একই পরিবর্তন reflect হবে। এটি development process কে দ্রুত এবং maintainable করে।

---

### 2. Why Use React?

React এর কিছু গুরুত্বপূর্ণ সুবিধা হলো:

1. **Efficient UI Updates**:
   - React এর মাধ্যমে user interaction এর উপর ভিত্তি করে page এর নির্দিষ্ট অংশ update করা যায়। React এর **Virtual DOM** feature এর কারণে এটি খুব দ্রুত এবং efficient ভাবে কাজ করে।

#### Example of Efficient UI Updates with Virtual DOM:

```jsx
import React, { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

উপরের উদাহরণে, **count** state প্রতিবার increment হচ্ছে যখন user **button** এ click করছে। React এর **Virtual DOM** এর মাধ্যমে শুধুমাত্র **count** এর অংশটি রি-রেন্ডার হচ্ছে। DOM এর অন্য কোনো অংশ পরিবর্তন হচ্ছে না, যার ফলে UI দ্রুত এবং efficient ভাবে update হচ্ছে।

#### Example Without Virtual DOM:

ধরা যাক, আমরা traditional JavaScript দিয়ে এটি করতে চাই:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Counter Example</title>
    <script>
      function increment() {
        var count = document.getElementById("count");
        count.innerHTML = parseInt(count.innerHTML) + 1;
      }
    </script>
  </head>
  <body>
    <h1>Count: <span id="count">0</span></h1>
    <button onclick="increment()">Increment</button>
  </body>
</html>
```

এখানে প্রতিবার **button** এ click করলে আমরা manual DOM manipulation করছি। JavaScript সরাসরি DOM এর সাথে কাজ করছে, যা বড় application এ performance সমস্যার সৃষ্টি করে। React এর মতো **Virtual DOM** না থাকায় প্রতিবার DOM পরিবর্তনের জন্য browser কে পুরো structure রি-রেন্ডার করতে হয়। এছাড়া DOM এর direct manipulation সময়সাপেক্ষ এবং memory-heavy হয়ে যায়।

#### Why React’s Approach is Better:

- **Performance**: React এর **Virtual DOM** শুধুমাত্র প্রয়োজনীয় অংশটুকু update করে, যেখানে traditional approach এ পুরো DOM structure কে পরিবর্তন করতে হয়।
- **Maintainability**: React এর **declarative syntax** এবং automatic DOM update এর কারণে complex UI গুলোও সহজে manage করা যায়।

---

### 3. Problems Without React

React ছাড়া modern web applications তৈরি করতে traditional DOM manipulation পদ্ধতি ব্যবহার করতে হয়, যা বড় বড় applications এর জন্য অনেক সমস্যা তৈরি করতে পারে।

#### 1) Manual DOM Manipulation এর জটিলতা

Traditional JavaScript দিয়ে DOM এর elements manually manipulate করতে গেলে আপনাকে প্রতিটি element এর জন্য DOM API (`getElementById`, `querySelector`) ব্যবহার করতে হয়, এবং প্রতিবার page এ কোনো পরিবর্তন আনতে হলে নতুন করে পুরো DOM এর সাথে interaction করতে হয়। এর ফলে UI complex হয়ে গেলে কোড অনেক বেশি জটিল এবং দুর্বল হয়ে পড়ে।

#### Example Without React (Dynamic List):

ধরুন, আপনি একটি **To-Do List** তৈরি করতে চান যেখানে user নতুন নতুন items যোগ করতে পারে:

```html
<!DOCTYPE html>
<html>
  <head>
    <script>
      function addItem() {
        const list = document.getElementById("list");
        const newItem = document.createElement("li");
        const inputValue = document.getElementById("input").value;
        newItem.textContent = inputValue;
        list.appendChild(newItem);
        document.getElementById("input").value = "";
      }
    </script>
  </head>
  <body>
    <h1>To-Do List</h1>
    <input type="text" id="input" placeholder="Enter new item" />
    <button onclick="addItem()">Add</button>
    <ul id="list"></ul>
  </body>
</html>
```

এখানে প্রতিবার user নতুন item যোগ করলে list এ একটি নতুন **`<li>`** element যোগ করতে হচ্ছে। JavaScript এর মাধ্যমে আমরা DOM এ সরাসরি manipulate করছি, যা বড় বা complex lists এর জন্য খুবই জটিল হয়ে পড়ে এবং performance সমস্যা তৈরি করতে পারে।

#### 2) Poor Code Reusability

Traditional JavaScript কোড reusability এর ক্ষেত্রে দুর্বল। যদি একই ধরনের UI element বারবার তৈরি করতে হয়, আপনাকে বারবার কোড লিখতে হবে, যা redundancy সৃষ্টি করে এবং bugs এর সম্ভাবনা বাড়ায়।

#### Example Without React (Navbar):

```html
<nav>
  <ul>
    <li>Home</li>
    <li>About</li>
    <li>Contact</li>
  </ul>
</nav>
```

এখানে আমরা একটি simple **Navbar** তৈরি করেছি। এখন যদি আরেকটি similar navbar তৈরি করতে হয়, তবে আপনাকে একই কোড আবার লিখতে হবে। Traditional JavaScript এ আপনি component-based architecture ব্যবহার করতে পারবেন না, যার ফলে UI element গুলোকে পুনরায় ব্যবহার করতে সমস্যা হয়।

#### 3) Complex State Management

Traditional JavaScript এ **state management** খুবই জটিল। যদি page এর বিভিন্ন element এর উপর ভিত্তি করে UI update করতে হয়, তবে আপনাকে বিভিন্ন DOM element এর সাথে synchronize করতে হবে। এটি বড় application এর ক্ষেত্রে অনেক জটিল হয়ে পড়ে।

#### Example (Without React State):

```html
<input type="text" id="name" placeholder="Enter your name" />
<button onclick="updateGreeting()">Greet</button>
<h1 id="greeting">Hello,</h1>

<script>
  function updateGreeting() {
    const name = document.getElementById("name").value;
    document.getElementById("greeting").innerHTML = "Hello, " + name;
  }
</script>
```

---

#### Solution with React:

React এর **state management** feature আপনাকে সহজে component এর state handle করতে দেয়, এবং UI এর পরিবর্তন স্বয়ংক্রিয়ভাবে synchronize হয়:

```jsx
import React, { useState } from "react";

function Greeting() {
  const [name, setName] = useState("");

  return (
    <div>
      <input
        type="text"
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Enter your name"
      />
      <h1>Hello, {name}!</h1>
    </div>
  );
}

export default Greeting;
```

এই উদাহরণে, user input অনুযায়ী greeting dynamically update হচ্ছে, এবং React এর **state** পরিবর্তন অনুযায়ী UI render হচ্ছে। JavaScript এর সরাসরি DOM manipulation এর প্রয়োজন নেই।

---

### 4. Conclusion

React একটি declarative, efficient, এবং flexible JavaScript library, যা modern web development এর জন্য অত্যন্ত উপযোগী। এটি UI development কে সহজতর করে, বিশেষত complex applications এর জন্য যেখানে dynamic content management প্রয়োজন।

React এর সবচেয়ে বড় সুবিধা হলো **component-based architecture** এবং **Virtual DOM**, যা UI management এবং performance সমস্যাগুলোকে অনেক সহজ করে তোলে। Traditional JavaScript এর তুলনায় React development আরও maintainable এবং reusable করে তোলে, যা large-scale applications এর জন্য বিশেষভাবে গুরুত্বপূর্ণ।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-01.1: Library vs Framework

### Table of Contents:

1. [What is a Library?](#what-is-a-library)
2. [What is a Framework?](#what-is-a-framework)
3. [Key Differences Between Library and Framework](#key-differences-between-library-and-framework)
4. [Examples of Popular Libraries and Frameworks](#examples-of-popular-libraries-and-frameworks)
5. [When to Use a Library vs. a Framework](#when-to-use-a-library-vs-a-framework)
6. [Conclusion](#conclusion)

---

### 1. What is a Library?

**Library** হলো এমন একটি code collection বা package, যা নির্দিষ্ট কাজ বা functionalities সম্পন্ন করার জন্য ব্যবহৃত হয়। এটি সাধারণত pre-written functions বা methods এর একটি সমাহার, যা developer দের একটি নির্দিষ্ট কাজ সহজে সম্পন্ন করতে সাহায্য করে। Library ব্যবহার করলে developer দের প্রয়োজনীয় function বা method call করে ব্যবহার করতে হয়, অর্থাৎ developer ই decide করে, কখন, কিভাবে, এবং কোথায় সেই code ব্যবহার হবে।

##### উদাহরণ:

JavaScript এর **React** একটি library, যা user interface তৈরি করতে ব্যবহৃত হয়। React developer দের components তৈরি এবং তাদের মধ্যে data pass করার জন্য functions এবং methods প্রদান করে, কিন্তু পুরো application structure বা control developer এর উপর থাকে।

---

### 2. What is a Framework?

**Framework** হলো একটি complete structure বা architecture, যা পুরো application এর জন্য একটি নির্দিষ্ট guideline এবং control প্রদান করে। Framework ব্যবহার করলে, developer দের নির্দিষ্ট rules এবং conventions অনুযায়ী code লিখতে হয়। এটি একটি predefined code structure প্রদান করে এবং application এর control অনেকাংশে framework এর উপর থাকে, যেখানে developer নির্দিষ্ট parts এ code লিখতে পারেন।

##### উদাহরণ:

JavaScript এর **Angular** একটি framework, যা একটি complete structure বা architecture প্রদান করে। Angular application তৈরি করার সময় developer দের Angular এর বিভিন্ন services, components, এবং modules ব্যবহার করতে হয়, এবং Angular application এর flow এবং lifecycle manage করে।

---

### 3. Key Differences Between Library and Framework

| **Aspect**      | **Library**                                              | **Framework**                                          |
| --------------- | -------------------------------------------------------- | ------------------------------------------------------ |
| **Control**     | Developer control করে কিভাবে এবং কোথায় code ব্যবহার হবে | Framework control করে application structure এবং flow   |
| **Flexibility** | Developer এর হাতে বেশি flexibility থাকে                  | Framework এর নির্দিষ্ট guideline অনুযায়ী কাজ করতে হয় |
| **Usage**       | নির্দিষ্ট কাজ সম্পন্ন করার জন্য library import করা হয়   | Framework application এর পুরো structure তৈরি করে       |
| **Examples**    | React, Lodash, jQuery                                    | Angular, Vue.js, Django                                |

#### Explanation:

- **Control**: Library ব্যবহার করলে developer control করে কিভাবে function call করা হবে। Framework এ control অনেকাংশে framework নিজেই করে, developer framework এর নির্দিষ্ট rules অনুযায়ী code লিখেন।
- **Flexibility**: Library এর ক্ষেত্রে developer ই নির্ধারণ করেন কিভাবে এবং কখন library এর code ব্যবহার করা হবে। Framework এর ক্ষেত্রে developer framework এর নির্দিষ্ট structure এবং guideline অনুসরণ করে code লিখেন।
- **Usage**: Library সাধারণত ছোট কাজগুলো (যেমন: data manipulation, DOM manipulation) সহজ করতে ব্যবহৃত হয়। Framework একটি পূর্ণাঙ্গ application তৈরি করার জন্য ব্যবহৃত হয়, যেখানে পুরো application structure predefined থাকে।

---

### 4. Examples of Popular Libraries and Frameworks

#### Libraries:

1. **React** (JavaScript)
2. **Lodash** (JavaScript)
3. **jQuery** (JavaScript)
4. **NumPy** (Python)
5. **Pandas** (Python)

#### Frameworks:

1. **Angular** (JavaScript)
2. **Vue.js** (JavaScript)
3. **Django** (Python)
4. **Laravel** (PHP)
5. **Spring** (Java)

React এর মতো library developer দের UI components তৈরির flexibility প্রদান করে, যেখানে Angular এর মতো framework একটি পূর্ণাঙ্গ structure এবং control প্রদান করে।

---

### 5. When to Use a Library vs. a Framework

#### When to Use a Library:

- যদি আপনার application এর একটি নির্দিষ্ট part এর জন্য code reusability এবং flexibility দরকার হয়।
- যখন আপনি কিছু specific functionality যেমন DOM manipulation (jQuery) বা data manipulation (Lodash, Pandas) করতে চান।
- যখন আপনি পুরো application structure নিজের মতো করে তৈরি করতে চান এবং তার উপর control রাখতে চান।

#### When to Use a Framework:

- যদি আপনি একটি complete application তৈরি করতে চান এবং predefined structure এবং architecture ব্যবহার করতে চান।
- যখন আপনি code organization এবং application structure নিয়ে সময় বাঁচাতে চান।
- যখন একটি large-scale application তৈরি করতে হবে এবং একটি scalable structure দরকার।

---

### 6. Conclusion

**Library** এবং **Framework** উভয়ই software development এর জন্য গুরুত্বপূর্ণ tools, তবে এদের কাজ এবং control এর ধরণ ভিন্ন।

- **Library** developer কে নির্দিষ্ট কাজ সম্পন্ন করার জন্য flexibility দেয় এবং developer control করে কিভাবে এবং কখন সেই library ব্যবহার হবে।
- **Framework** একটি পূর্ণাঙ্গ architecture বা structure প্রদান করে এবং developer কে সেই structure অনুযায়ী কাজ করতে হয়। Framework অনেক ক্ষেত্রে control ধরে রাখে এবং application এর flow manage করে।

React এর মতো libraries ছোট ছোট components তৈরি করতে সাহায্য করে, যেখানে Angular এর মতো frameworks পুরো application structure নির্ধারণ করে দেয়। আপনার application এর nature এবং requirement এর উপর ভিত্তি করে library বা framework বেছে নেওয়া উচিত।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-02: React Virtual DOM: What & Why

### Table of Contents:

1. [What is the Virtual DOM?](#what-is-the-virtual-dom)
2. [Why Virtual DOM is Needed?](#why-virtual-dom-is-needed)
   - [Performance Optimization](#performance-optimization)
   - [Efficient Reconciliation](#efficient-reconciliation)
   - [Improved User Experience](#improved-user-experience)
3. [How Virtual DOM Works?](#how-virtual-dom-works)
   - [React Lifecycle and Virtual DOM](#react-lifecycle-and-virtual-dom)
   - [Steps in Virtual DOM Update](#steps-in-virtual-dom-update)
4. [Real-life Example of Virtual DOM](#real-life-example-of-virtual-dom)
5. [Detailed Example Comparison (React vs Traditional DOM)](#detailed-example-comparison)
6. [Conclusion](#conclusion)

---

### 1. What is the Virtual DOM?

Virtual DOM (**Virtual Document Object Model**) হলো একটি **in-memory representation** যা React ব্যবহার করে UI updates এর performance অনেক দ্রুততর এবং efficient করতে। React এর মূল লক্ষ্য হলো performance optimize করা এবং unnecessary DOM manipulations কমিয়ে আনা। Virtual DOM আসলে একটি lightweight JavaScript object যা real DOM এর একটি virtual কপি তৈরি করে।

যখন React component এর state বা props এ পরিবর্তন হয়, React এই পরিবর্তনগুলো প্রথমে **Virtual DOM** এ reflect করে। এরপর React এর diffing algorithm ব্যবহার করে, শুধু পরিবর্তিত অংশগুলোকেই real DOM এর সাথে synchronize করে।

#### Traditional DOM Manipulation:

Traditional DOM API ব্যবহার করলে প্রতিবার পরিবর্তন আসলে real DOM এ সরাসরি কাজ করতে হয়। প্রতিবার যখন কোন element পরিবর্তিত হয়, browser পুরো UI রি-রেন্ডার করে। এটা অনেক সময় DOM খুব বড় হলে performance issue তৈরি করতে পারে।

#### Virtual DOM Concept:

Virtual DOM এর মাধ্যমে, শুধু পরিবর্তিত অংশ গুলোই real DOM এ আপডেট করা হয়, যাতে browser পুরো DOM structure রি-রেন্ডার করতে না হয়।

---

### 2. Why Virtual DOM is Needed?

#### Performance Optimization:

Traditional DOM manipulation computationally expensive, বিশেষ করে যদি DOM অনেক বড় হয়। প্রতিবার DOM এ পরিবর্তন হলে, browser পুরো structure কে repaint এবং reflow করে। কিন্তু React এর **Virtual DOM** system এই সমস্যার সমাধান করে।

##### Example Without Virtual DOM (Traditional DOM Manipulation):

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Traditional DOM Example</title>
    <script>
      function updateText() {
        document.getElementById("text").innerHTML = "Text Updated!";
      }
    </script>
  </head>
  <body>
    <p id="text">This is some text</p>
    <button onclick="updateText()">Update Text</button>
  </body>
</html>
```

##### Problem:

উপরের উদাহরণে যখন user "Update Text" button এ click করে, পুরো DOM structure re-render হয়। যদি বড় application হয় যেখানে DOM অনেক elements থাকে, তাহলে performance issue হতে পারে।

#### Efficient Reconciliation:

React এর diffing algorithm **virtual DOM** এবং **real DOM** এর মধ্যে differences track করে এবং শুধু changed parts update করে। এই process কে **reconciliation** বলা হয়। এটি unnecessary DOM re-renders এড়িয়ে performance উন্নত করে।

#### Improved User Experience:

React এর **Virtual DOM** ব্যবহার করার আরেকটি বড় সুবিধা হলো **smooth user experience**। Frequent UI updates এবং smooth transitions নিশ্চিত করার জন্য Virtual DOM অনেক গুরুত্বপূর্ণ ভূমিকা পালন করে। Traditional approach এ page refresh হতে অনেক সময় লাগতে পারে, যা user experience ধীর করে দেয়। কিন্তু Virtual DOM ব্যবহার করলে এই সমস্যা অনেকাংশে কমে যায়।

---

### 3. How Virtual DOM Works?

Virtual DOM মূলত real DOM এর একটি lightweight copy, এবং এই পুরো process তিনটি পর্যায়ে কাজ করে:

1. **Render Phase**:
   যখনই React component এ কোনো state change বা props change হয়, React প্রথমে এই পরিবর্তনগুলো virtual DOM এ reflect করে। এই render phase এ real DOM পরিবর্তিত হয় না, বরং memory তে একটি ভার্চুয়াল কপি তৈরি হয়।

2. **Diffing Algorithm**:
   এই algorithm এর কাজ হলো virtual DOM এবং real DOM এর মধ্যে differences খুঁজে বের করা। React কেবলমাত্র changed parts track করে এবং এই parts গুলোকে optimize করে real DOM এর সাথে sync করে।

3. **Update Real DOM**:
   পরিবর্তনের পরে React minimal updates real DOM এ apply করে এবং unnecessary re-rendering এড়ায়। এটি real DOM কে দ্রুত পরিবর্তন করার জন্য খুবই কার্যকর।

#### Example with React Virtual DOM:

```jsx
import React, { useState } from "react";

function TextUpdate() {
  const [text, setText] = useState("This is some text");

  const updateText = () => {
    setText("Text Updated!");
  };

  return (
    <div>
      <p>{text}</p>
      <button onClick={updateText}>Update Text</button>
    </div>
  );
}

export default TextUpdate;
```

এখানে, button click করলে React প্রথমে Virtual DOM এ **text** update করে, তারপর diffing algorithm এর মাধ্যমে changes track করে এবং real DOM এ শুধুমাত্র updated text রেন্ডার করে।

#### Steps in Virtual DOM Update:

1. **React component renders** – State বা props পরিবর্তন হলে React Virtual DOM প্রথমে UI কে re-render করে।
2. **React calculates the diff** – Virtual DOM এবং real DOM এর মধ্যে differences খুঁজে বের করা হয়।
3. **React updates only the necessary DOM nodes** – পরিবর্তিত অংশ গুলো real DOM এ reflect হয়, এবং শুধুমাত্র প্রয়োজনীয় DOM elements update করা হয়।

---

### 4. Real-life Example of Virtual DOM:

ধরা যাক, আপনি একটি **To-Do List** application তৈরি করছেন, যেখানে user dynamically নতুন items যোগ করতে পারে। যদি traditional DOM manipulation ব্যবহার করা হয়, প্রতিবার নতুন item যোগ করলে পুরো DOM re-render হতে পারে, যা performance কমিয়ে দেয়। কিন্তু Virtual DOM ব্যবহার করলে শুধু নতুন item টুকু dynamically update হয়।

#### React Example (Real-life Scenario):

```jsx
import React, { useState } from "react";

function TodoList() {
  const [items, setItems] = useState(["Item 1", "Item 2"]);

  const addItem = () => {
    setItems([...items, `Item ${items.length + 1}`]);
  };

  return (
    <div>
      <ul>
        {items.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
      <button onClick={addItem}>Add Item</button>
    </div>
  );
}

export default TodoList;
```

#### Explanation:

উপরের উদাহরণে, যখন user **Add Item** button এ click করবে, শুধু নতুন **item** টুকু Virtual DOM এ update হবে। পরে React সেই change detect করে real DOM এর সাথে synchronize করে।

---

### 5. Detailed Example Comparison (React vs Traditional DOM)

##### Traditional DOM Approach:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Traditional DOM Example</title>
    <script>
      function addItem() {
        var list = document.getElementById("list");
        var newItem = document.createElement("li");
        newItem.textContent = "New Item";
        list.appendChild(newItem);
      }
    </script>
  </head>
  <body>
    <ul id="list">
      <li>Item 1</li>
      <li>Item 2</li>
    </ul>
    <button onclick="addItem()">Add Item</button>
  </body>
</html>
```

##### React with Virtual DOM Approach:

```jsx
import React, { useState } from "react";

function ItemList() {
  const [items, setItems] = useState(["Item 1", "Item 2"]);

  const addItem = () => {
    setItems([...items, `Item ${items.length + 1}`]);
  };

  return (
    <div>
      <ul>
        {items.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
      <button onClick={addItem}>Add Item</button>
    </div>
  );
}

export default ItemList;
```

##### Key Differences:

1. **Traditional DOM**: Button click করলে পুরো DOM re-render হতে পারে, যা performance কমিয়ে দেয়।
2. **React with Virtual DOM**: শুধু পরিবর্তিত **item** টুকু update হয় এবং real DOM এর সাথে efficiently sync করা হয়।

---

### 6. Conclusion:

React এর **Virtual DOM** modern web development এর একটি শক্তিশালী tool যা UI rendering অনেক দ্রুত এবং efficient করে তোলে। এটি unnecessary DOM manipulations এড়িয়ে শুধুমাত্র changed parts real DOM এ apply করে। এইভাবে, large-scale applications এর performance অনেক উন্নত হয় এবং user experience আরো smooth হয়।

Traditional DOM manipulation এর তুলনায় React এর **Virtual DOM** application development সহজ, faster, এবং scalable করে তোলে। Performance এবং maintainability এর দিক থেকে **Virtual DOM** একটি game changer হিসেবে কাজ করে।

React এর popularity এর পিছনে অন্যতম কারণ হলো এই **Virtual DOM**, যা অনেক বড় এবং dynamic UI গুলিকে দ্রুত update করতে সাহায্য করে।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-03: How to Install React (Step-by-Step Guide with Example Project)

### Table of Contents:

1. [Prerequisites](#prerequisites)
2. [Installing Node.js and npm](#installing-nodejs-and-npm)
3. [Creating a New React Project](#creating-a-new-react-project)
   - [Using Create React App (CRA)](#using-create-react-app)
   - [Folder Structure Overview with Real-life Example](#folder-structure-overview-with-real-life-example)
4. [package.json Explained](#packagejson-explained)
5. [Example Project: Simple To-Do List](#example-project-simple-to-do-list)
   - [Step 1: Setting Up the Project](#step-1-setting-up-the-project)
   - [Step 2: Creating the To-Do List Component](#step-2-creating-the-to-do-list-component)
   - [Step 3: Adding Interactivity](#step-3-adding-interactivity)
   - [Step 4: Running and Testing](#step-4-running-and-testing)
6. [Running the React Project](#running-the-react-project)
7. [Conclusion](#conclusion)

---

### 1. Prerequisites

React ইনস্টল করার আগে, আপনার সিস্টেমে **Node.js** এবং **npm** থাকতে হবে। এগুলো React এবং অন্যান্য JavaScript libraries পরিচালনার জন্য প্রয়োজনীয়। যদি Node.js এবং npm ইন্সটল করা না থাকে, তাহলে [Node.js অফিসিয়াল ওয়েবসাইট](https://nodejs.org/en/) থেকে ডাউনলোড করে ইনস্টল করুন।

---

### 2. Installing Node.js and npm

#### Step 1: Download Node.js

- [Node.js এর অফিসিয়াল ওয়েবসাইট](https://nodejs.org/en/) থেকে **LTS (Long-Term Support)** version ডাউনলোড করুন।
- ইনস্টল করার পর, Terminal বা Command Prompt খুলে নিচের কমান্ডগুলো দিয়ে যাচাই করুন:

```bash
node -v
npm -v
```

---

### 3. Creating a New React Project

React এর নতুন প্রজেক্ট তৈরি করতে **Create React App (CRA)** খুবই উপযোগী। এটি খুব সহজে একটি React প্রজেক্ট সেটআপ করতে সাহায্য করে।

#### Using Create React App (CRA)

**Step 1: Create React App ব্যবহার করে প্রজেক্ট তৈরি করা**

Terminal/Command Prompt এ নিচের কমান্ড লিখুন:

```bash
npx create-react-app my-app
```

এখানে **my-app** হলো আপনার প্রজেক্টের নাম। এটি ইনস্টল করে সমস্ত প্রয়োজনীয় dependencies যুক্ত করে।

**Step 2: Project ফোল্ডারে প্রবেশ করা**

```bash
cd my-app
```

---

### Folder Structure Overview with Real-life Example

React প্রজেক্ট তৈরি হলে নিচের মতো ফোল্ডার স্ট্রাকচার পাবেন:

#### Example of Folder Structure:

```
my-app/
├── node_modules/
├── public/
│   ├── index.html
│   └── favicon.ico
├── src/
│   ├── App.js
│   ├── App.css
│   ├── index.js
│   └── index.css
├── package.json
└── README.md
```

#### Folder Breakdown:

1. **node_modules/**: এখানে সমস্ত dependencies থাকে।
2. **public/**: public ফোল্ডারে **index.html** থাকে, যা ব্রাউজারে React app প্রদর্শন করে।
3. **src/**: এই ফোল্ডারে React এর মূল কোড থাকে (App.js, index.js, ইত্যাদি)।
4. **package.json**: প্রজেক্টের dependencies এবং scripts এখানে থাকে।

---

### 4. package.json Explained

**package.json** ফাইলটি আপনার প্রজেক্টের জন্য অত্যন্ত গুরুত্বপূর্ণ, যেখানে সমস্ত configuration এবং dependencies তালিকাভুক্ত থাকে।

#### Key Sections in package.json:

```json
{
  "name": "my-app",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "react-scripts": "5.0.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  }
}
```

- **dependencies**: আপনার প্রজেক্টে ইনস্টল হওয়া libraries।
- **scripts**: প্রজেক্ট চালানোর জন্য প্রয়োজনীয় স্ক্রিপ্ট, যেমন:
  - **npm start**: development server চালু করে।
  - **npm run build**: production build তৈরি করে।
  - **npm test**: testing চালায়।

---

### 5. Example Project: Simple To-Do List

এই অংশে আমরা একটি বাস্তব উদাহরণ দেব—**Simple To-Do List**। এটি খুবই সহজ, কিন্তু React এর ভিত্তিগত ধারণা বোঝার জন্য খুব কার্যকর।

#### Step 1: Setting Up the Project

Terminal এ নিচের কমান্ডগুলো দিয়ে প্রজেক্ট তৈরি করুন এবং **my-app** ফোল্ডারে প্রবেশ করুন:

```bash
npx create-react-app todo-app
cd todo-app
```

---

#### Step 2: Creating the To-Do List Component

**src/App.js** ফাইল খুলুন এবং নিচের কোডটি লিখুন:

```jsx
import React, { useState } from "react";

function App() {
  const [tasks, setTasks] = useState([]);
  const [newTask, setNewTask] = useState("");

  const handleAddTask = () => {
    setTasks([...tasks, newTask]);
    setNewTask("");
  };

  return (
    <div>
      <h1>To-Do List</h1>
      <input
        type="text"
        value={newTask}
        onChange={(e) => setNewTask(e.target.value)}
        placeholder="Add a new task"
      />
      <button onClick={handleAddTask}>Add Task</button>
      <ul>
        {tasks.map((task, index) => (
          <li key={index}>{task}</li>
        ))}
      </ul>
    </div>
  );
}

export default App;
```

#### Explanation:

1. **useState Hook**: আমরা **useState** ব্যবহার করছি task list এবং নতুন task handle করার জন্য।
2. **handleAddTask**: এটি নতুন task list এ যুক্ত করে এবং input field টি reset করে।
3. **map Function**: আমরা **map** function ব্যবহার করছি **tasks** array render করতে।

---

#### Step 3: Adding Interactivity

এখানে নতুন **task** input এ টাইপ করলে **Add Task** বাটন চাপলে task list এ নতুন item যুক্ত হয়।

#### Step 4: Running and Testing

**npm start** কমান্ড দিয়ে প্রজেক্ট চালান:

```bash
npm start
```

ব্রাউজারে **http://localhost:3000** এ গিয়ে আপনার To-Do List অ্যাপটি পরীক্ষা করুন।

---

### 6. Running the React Project

React প্রজেক্ট চালানোর জন্য **npm start** কমান্ড ব্যবহার করুন। এটি local development server চালু করবে এবং আপনি প্রজেক্টটি **http://localhost:3000** এ দেখতে পাবেন।

---

### 7. Conclusion

React এর মাধ্যমে একটি সহজ প্রজেক্ট তৈরি করা অত্যন্ত সহজ এবং দ্রুত। উপরের উদাহরণে আমরা **Simple To-Do List** প্রজেক্ট দেখিয়েছি, যেখানে আপনি একটি নতুন task যুক্ত করতে পারবেন এবং task list দেখতে পারবেন।

React environment setup করার পর, আপনি খুব সহজেই এমন আরও প্রজেক্ট তৈরি করতে পারবেন এবং React এর অন্যান্য feature ব্যবহার করতে পারবেন, যেমন state management এবং component rendering।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-03.1: React Install with Vite

### Table of Contents:

1. [Introduction to Vite](#introduction-to-vite)
2. [Why Use Vite for React?](#why-use-vite-for-react)
3. [Installing React with Vite](#installing-react-with-vite)
   - [Step 1: Installing Vite](#step-1-installing-vite)
   - [Step 2: Setting Up the React Project](#step-2-setting-up-the-react-project)
   - [Step 3: Running the Development Server](#step-3-running-the-development-server)
4. [Folder Structure Overview](#folder-structure-overview)
5. [Real-life Example Project](#real-life-example-project)
6. [Conclusion](#conclusion)

---

### 1. Introduction to Vite

**Vite** হলো একটি modern frontend build tool, যা দ্রুত development server এবং build process প্রদান করে। এটি মূলত **ESM (ECMAScript Modules)** এবং **Hot Module Replacement (HMR)** ব্যবহার করে দ্রুত development environment setup করতে সাহায্য করে। Vite বিশেষভাবে দ্রুত startup time এবং minimal configuration এর জন্য পরিচিত, যা React এর মতো frameworks এর সাথে ভালোভাবে কাজ করে।

---

### 2. Why Use Vite for React?

Vite React এর development environment setup করার জন্য দ্রুত এবং efficient একটি উপায়। এর কিছু প্রধান সুবিধা হলো:

- **Fast Startup**: Traditional bundlers যেমন Webpack এর তুলনায় Vite অনেক দ্রুত startup time প্রদান করে।
- **Hot Module Replacement (HMR)**: Vite এর মাধ্যমে দ্রুত code changes UI তে reflect হয়, যা development process কে আরও efficient করে তোলে।
- **Minimal Configuration**: Vite এর default configuration অনেক সহজ, এবং React এর জন্য এটি automatically সেটআপ করে।
- **Optimized Build**: Vite production build এর জন্য automatically optimized output তৈরি করে।

---

### 3. Installing React with Vite

Vite দিয়ে React setup করতে কয়েকটি ধাপে কাজ করতে হয়। নিচে step-by-step নির্দেশনা দেয়া হলো:

#### Step 1: Installing Vite

প্রথমে, **npm** বা **yarn** ব্যবহার করে Vite ইনস্টল করতে হবে। Terminal বা Command Prompt এ নিচের command লিখুন:

```bash
npm create vite@latest my-react-app
```

অথবা

```bash
yarn create vite my-react-app
```

**my-react-app** এর জায়গায় আপনার পছন্দমতো project এর নাম দিতে পারেন।

#### Step 2: Setting Up the React Project

Vite ইনস্টল করার পরে, Vite আপনাকে কিছু options দিবে। আপনি **React** এবং **JavaScript** (বা TypeScript) select করতে পারেন।

```bash
cd my-react-app
npm install
```

এখন, **cd my-react-app** command এর মাধ্যমে project এর ভেতরে যান এবং **npm install** command দিয়ে dependencies install করুন।

#### Step 3: Running the Development Server

Development server চালু করতে নিচের command লিখুন:

```bash
npm run dev
```

এটি আপনার local server চালু করবে এবং browser এ application preview করবে। Vite এর HMR feature এর কারণে, code এ কোনো পরিবর্তন হলে সাথে সাথে UI তে reflect হবে।

Output:

```
VITE vX.X.X  ready in 300 ms

  ➜  Local:   http://localhost:3000/
  ➜  Network: use --host to expose
```

এই URL এ গিয়ে আপনি আপনার React application দেখতে পাবেন।

---

### 4. Folder Structure Overview

Vite দিয়ে React setup করার পরে একটি সহজ এবং পরিচ্ছন্ন folder structure তৈরি হয়:

```
my-react-app
├── node_modules
├── public
├── src
│   ├── App.jsx
│   ├── main.jsx
│   └── index.css
├── .gitignore
├── index.html
├── package.json
├── vite.config.js
```

- **src**: সমস্ত application এর মূল কোড এখানে থাকে। **App.jsx** এবং **main.jsx** হলো মূল React components এবং entry point।
- **public**: Static files এর জন্য ব্যবহৃত হয়।
- **index.html**: Vite এর জন্য প্রধান HTML ফাইল।
- **vite.config.js**: Vite এর configuration ফাইল।

---

## Explanation of main.jsx File

### Table of Contents
1. **Code Overview**
2. **What is StrictMode?**
3. **How does createRoot Work?**
4. **Rendering Process with ReactDOM**
5. **Discussion on File Imports**

---

### 1. Code Overview

এই কোডটি একটি React Application এর Entry Point হিসেবে কাজ করে, যা মূলত ব্রাউজারে Render করা হয়। এখানে `React` এবং `ReactDOM` লাইব্রেরির কিছু ফাংশন ব্যবহার করা হয়েছে আমাদের Application-কে ব্রাউজারে দেখানোর জন্য।

### 2. What is StrictMode?

`StrictMode` হল React এর একটি Component যা আমাদের কোডের কিছু সাধারণ সমস্যা যেমন Deprecated API ব্যবহার করা বা কোনো অনাকাঙ্ক্ষিত Side-Effect ধরতে সাহায্য করে। এটি শুধুমাত্র Development Mode-এ কাজ করে, Production Mode-এ কোনো প্রভাব ফেলে না। নিচে আমরা `StrictMode` ব্যবহার করেছি Application-কে Render করার সময় যাতে Development Console-এ কোনো সমস্যা থাকলে সেটি দেখায়:

```jsx
<StrictMode>
  <App />
</StrictMode>
```

### 3. How does createRoot Work?

`createRoot` হল `React 18` এর একটি নতুন API, যা React Application-কে Render করার জন্য ব্যবহৃত হয়। এটি ReactDOM এর নতুন Method হিসেবে এসেছে, যা পুরোনো `ReactDOM.render` এর পরিবর্তে ব্যবহৃত হচ্ছে।

```javascript
createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
```

- `createRoot` প্রথমে HTML ডকুমেন্টে সেই Element খুঁজে বের করে যার `id` `'root'`।
- তারপর এটি `render` Method এর মাধ্যমে `<App />` Component-টি `StrictMode` এর মধ্যে Render করে। এতে করে, পুরো Application টি ঐ `root` Div-এর মধ্যে Render হয়।

### 4. Rendering Process with ReactDOM

আগে আমরা `ReactDOM.render` ব্যবহার করতাম, কিন্তু `React 18` থেকে, আমরা `ReactDOM.createRoot` এবং `.render()` Method ব্যবহার করি। এটি Rendering Performance উন্নত করে এবং নতুন কিছু Feature যেমন Concurrent Mode কে সমর্থন করে।

### 5. Discussion on File Imports

```javascript
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'
```

- **`StrictMode`**: এটি `react` লাইব্রেরি থেকে Import করা হয়।
- **`createRoot`**: এটি `react-dom/client` থেকে Import করা হয়।
- **`'./index.css'`**: Stylesheet Import করা হয়েছে, যা Application এর Style নির্ধারণ করে।
- **`App`**: `'./App.jsx'` থেকে আমাদের মূল Application Component Import করা হয়েছে, যা আমাদের Application এর প্রধান অংশ।

এইভাবে, কোডটি আমাদের React Application-কে সফলভাবে ব্রাউজারে Render করার জন্য প্রয়োজনীয় সবকিছু প্রস্তুত করে।

### 5. Real-life Example Project

ধরা যাক, আমরা একটি simple React component তৈরি করবো যেখানে "Hello, Vite!" প্রদর্শিত হবে।

#### Example Code:

**App.jsx**

```jsx
function App() {
  return (
    <div className="App">
      <h1>Hello, Vite!</h1>
    </div>
  );
}

export default App;
```

**main.jsx**

```jsx
import React from "react";
import ReactDOM from "react-dom";
import App from "./App";
import "./index.css";

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

এই কোড Vite environment এ দ্রুত render হবে এবং আপনি browser এ "Hello, Vite!" দেখতে পাবেন।

---

### 6. Conclusion

Vite দিয়ে React setup করা খুবই সহজ এবং efficient। এটি traditional bundlers এর তুলনায় দ্রুত এবং minimal configuration দিয়ে কাজ করে, যা modern React development এর জন্য আদর্শ। Vite এর মাধ্যমে আপনি খুব সহজেই একটি React application তৈরি করতে পারেন এবং দ্রুত development environment পেতে পারেন।

Vite এর speed এবং flexibility React এর modern development environment এর জন্য একটি বড় সুবিধা।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-04: React Render HTML

### Table of Contents:

1. [What Does Rendering HTML Mean in React?](#what-does-rendering-html-mean-in-react)
2. [How React Renders HTML](#how-react-renders-html)
   - [JSX Syntax](#jsx-syntax)
   - [ReactDOM.render()](#reactdomrender)
3. [Rendering Dynamic Content](#rendering-dynamic-content)
4. [Real-life Example of Rendering HTML](#real-life-example-of-rendering-html)
5. [React Virtual DOM and Rendering Efficiency](#react-virtual-dom-and-rendering-efficiency)
6. [Conclusion](#conclusion)

---

### 1. What Does Rendering HTML Mean in React?

**Rendering HTML** মানে হলো HTML elements বা components-কে web browser এ প্রদর্শন করা। সাধারণত traditional JavaScript দিয়ে DOM (Document Object Model) এর সাথে কাজ করা হয়, যেখানে `document.createElement()` বা `innerHTML` ব্যবহার করে HTML dynamically generate করা হয়। কিন্তু **React** এ, rendering process আরও streamlined এবং efficient, কারণ React এর মাধ্যমে আপনি HTML code **JSX (JavaScript XML)** syntax ব্যবহার করে লিখতে পারেন এবং virtual DOM এর মাধ্যমে efficiently render করতে পারেন।

React এর মূল কাজ হলো user interface তৈরি করা এবং সেই UI কে browser এর real DOM এ reflect করা। React এই কাজটি করে **ReactDOM** এর মাধ্যমে যা web page এ HTML render করে।

---

### 2. How React Renders HTML

#### JSX Syntax

**JSX (JavaScript XML)** হলো React এর special syntax যা HTML এর মতো দেখতে, কিন্তু এটি JavaScript এর মধ্যে embedded থাকে। JSX ব্যবহার করলে HTML elements এবং JavaScript একসাথে manage করা সহজ হয়। JSX এর মাধ্যমে আপনি HTML এর মতো structure লিখতে পারেন, যেটা পরে React component এ পরিবর্তিত হয়ে rendering হয়।

##### Example of JSX:

```jsx
const element = <h1>Hello, world!</h1>;
```

এটি দেখলে HTML এর মতো মনে হলেও এটি আসলে **JSX**। React এই JSX কে JavaScript এ convert করে এবং DOM এ render করে।

#### ReactDOM.render()

**ReactDOM.render()** method ব্যবহার করে React component বা JSX কে real DOM এ রেন্ডার করা হয়।

##### Syntax:

```jsx
ReactDOM.render(element, document.getElementById("root"));
```

এই example এ, **element** হলো যে HTML বা React component টি render করা হবে, এবং **'root'** হলো HTML এর id, যেখানে এই content inject হবে।

##### Example:

```jsx
import React from "react";
import ReactDOM from "react-dom";

const element = <h1>Hello, React!</h1>;

ReactDOM.render(element, document.getElementById("root"));
```

উপরের কোডটি **index.html** এর একটি **div** element এর মধ্যে render হবে যেটির id হবে "root":

```html
<div id="root"></div>
```

---

### 3. Rendering Dynamic Content

React এ শুধু static HTML নয়, বরং dynamic content render করা যায়। উদাহরণস্বরূপ, user input অনুযায়ী data dynamically update এবং render করা যায়।

##### Example of Rendering Dynamic Content:

```jsx
import React, { useState } from "react";
import ReactDOM from "react-dom";

function App() {
  const [name, setName] = useState("React");

  return (
    <div>
      <h1>Hello, {name}!</h1>
      <input
        type="text"
        value={name}
        onChange={(e) => setName(e.target.value)}
      />
    </div>
  );
}

ReactDOM.render(<App />, document.getElementById("root"));
```

#### Explanation:

1. **useState Hook**: আমরা **useState** hook ব্যবহার করে **name** নামক একটি state তৈরি করেছি।
2. **Dynamic Rendering**: যখন user input field এ কিছু লিখবে, সেই **name** value dynamically update হয়ে rendering হবে।

---

### 4. Real-life Example of Rendering HTML

ধরা যাক, আপনি একটি e-commerce website তৈরি করছেন যেখানে প্রতিবার নতুন product যোগ করলে সেই product টি dynamically render করতে হবে। React এর মাধ্যমে সহজেই এই কাজ করা যায়।

#### Example:

```jsx
import React, { useState } from "react";
import ReactDOM from "react-dom";

function ProductList() {
  const [products, setProducts] = useState(["Product 1", "Product 2"]);

  const addProduct = () => {
    setProducts([...products, `Product ${products.length + 1}`]);
  };

  return (
    <div>
      <h1>Product List</h1>
      <ul>
        {products.map((product, index) => (
          <li key={index}>{product}</li>
        ))}
      </ul>
      <button onClick={addProduct}>Add Product</button>
    </div>
  );
}

ReactDOM.render(<ProductList />, document.getElementById("root"));
```

#### Explanation:

1. **useState**: এখানে **products** নামক একটি state আছে যেটা একটি array ধরে। যখন নতুন product যোগ করা হয়, সেটা **addProduct** function এর মাধ্যমে **products** এ যুক্ত হয়।
2. **Dynamic Rendering**: প্রতিবার নতুন product যোগ করার পরে, **ProductList** component টিকে re-render করা হয় এবং updated product list দেখতে পাওয়া যায়।

---

### 5. React Virtual DOM and Rendering Efficiency

React এর HTML rendering এত efficient হওয়ার পেছনে বড় কারণ হলো এর **Virtual DOM**। যখন আপনি React component এ কোনো পরিবর্তন করেন, React পুরো DOM কে re-render করে না। এটি প্রথমে Virtual DOM এ changes apply করে এবং তারপর minimal changes real DOM এ implement করে। এর মাধ্যমে unnecessary re-rendering এড়ানো যায়, এবং UI দ্রুত আপডেট হয়।

---

### 6. Conclusion

React এর মাধ্যমে HTML rendering process অনেক সহজ এবং efficient হয়ে যায়, বিশেষ করে **JSX** এবং **ReactDOM** এর কারণে। আপনি শুধুমাত্র static content নয়, dynamic content ও খুব সহজে render করতে পারেন, এবং React এর **Virtual DOM** এর মাধ্যমে UI খুব দ্রুত এবং smooth ভাবে update হয়।

এইভাবে, React modern web applications এর জন্য একটি essential tool হয়ে উঠেছে, যা UI rendering কে সহজ করে এবং performance উন্নত করে।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-05: React JSX

### Table of Contents:

1. [What is JSX?](#what-is-jsx)
2. [Why JSX is Important](#why-jsx-is-important)
3. [JSX Syntax](#jsx-syntax)
   - [Embedding Expressions in JSX](#embedding-expressions-in-jsx)
   - [JSX Elements and Components](#jsx-elements-and-components)
4. [JSX vs HTML](#jsx-vs-html)
5. [Real-life Example of JSX](#real-life-example-of-jsx)
6. [Common JSX Mistakes and Best Practices](#common-jsx-mistakes-and-best-practices)
7. [Conclusion](#conclusion)

---

### 1. What is JSX?

**JSX (JavaScript XML)** হলো React এর একটি syntax extension, যা JavaScript এর ভেতরে HTML এর মতো structure লিখতে দেয়। যদিও JSX দেখতে HTML এর মতো, এটি আসলে একটি **JavaScript** এর বিশেষ syntax যা **React** এর মধ্যে ব্যবহার করা হয়। React এর সাথে কাজ করতে গেলে JSX শেখা অত্যন্ত গুরুত্বপূর্ণ, কারণ React এর মাধ্যমে UI তৈরি করার জন্য JSX অন্যতম প্রধান উপাদান।

##### Example of JSX:

```jsx
const element = <h1>Hello, World!</h1>;
```

উপরের কোডটিতে **<h1>Hello, World!</h1>** হলো JSX এর একটি উদাহরণ, যা পরবর্তীতে JavaScript কোডে পরিবর্তিত হয়ে DOM এ render হয়।

---

### 2. Why JSX is Important

JSX React এর একটি প্রধান অংশ, কারণ এটি HTML এর মতো syntax ব্যবহার করে **JavaScript** এর ভেতরে **UI components** তৈরির কাজকে সহজ করে। এর কিছু প্রধান সুবিধা হলো:

1. **Readable and Declarative**: JSX HTML এর মতো দেখতে হওয়ায় কোডটি অনেক বেশি readable এবং declarative হয়, যা development experience সহজ করে।
2. **Integration with JavaScript**: JSX এর মাধ্যমে সহজেই JavaScript expressions এবং logic UI এর সাথে integrate করা যায়।
3. **Faster Rendering**: React এর **Virtual DOM** এর সাথে মিলিত হয়ে JSX দ্রুত HTML render করে এবং performance বৃদ্ধি করে।

---

### 3. JSX Syntax

JSX এর syntax দেখতে HTML এর মতো, কিন্তু এর কিছু বিশেষ নিয়ম এবং functionality রয়েছে যা HTML এর চেয়ে আলাদা।

#### Embedding Expressions in JSX

JSX এর সবচেয়ে শক্তিশালী বৈশিষ্ট্য হলো এর মধ্যে **JavaScript expressions** embed করা যায়। JavaScript এর কোনো value JSX এ curly braces `{}` এর মধ্যে রেখে render করা যায়।

##### Example of Embedding JavaScript in JSX:

```jsx
const name = "React";
const element = <h1>Hello, {name}!</h1>;
```

এই উদাহরণে, **name** নামক JavaScript variable টি JSX এর মধ্যে রাখা হয়েছে। এর ফলে DOM এ **"Hello, React!"** render হবে।

#### JSX Elements and Components

JSX এর মাধ্যমে শুধুমাত্র HTML elements তৈরি করা যায় না, বরং React components কে JSX এর মধ্যে ব্যবহার করা যায়।

##### Example of JSX with Components:

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}!</h1>;
}

const element = <Welcome name="React" />;
```

এখানে **Welcome** হলো একটি React component যা JSX এর মাধ্যমে render হয়েছে। Component এর **props** ব্যবহার করে dynamic data render করা হচ্ছে।

---

### 4. JSX vs HTML

যদিও JSX HTML এর মতো দেখতে, এদের মধ্যে কিছু পার্থক্য রয়েছে। কিছু গুরুত্বপূর্ণ পার্থক্য নিচে উল্লেখ করা হলো:

1. **class vs className**: HTML এ **class** attribute ব্যবহার করা হয়, কিন্তু JSX এ **className** ব্যবহার করতে হয়, কারণ **class** হলো JavaScript এর reserved keyword।

   ```jsx
   <div className="container"></div>
   ```

2. **Self-closing Tags**: JSX এ প্রতিটি tag self-close করা প্রয়োজন, যদি তার কোনো closing tag না থাকে।

   ```jsx
   <img src="image.jpg" alt="Sample" />
   ```

3. **JSX attributes in camelCase**: HTML attributes, যেমন **onclick** বা **onchange** JSX এ camelCase এ লিখতে হয়।

   ```jsx
   <button onClick={handleClick}>Click Me</button>
   ```

---

### 5. Real-life Example of JSX

ধরা যাক, আপনি একটি **User Profile** component তৈরি করতে চান, যেখানে user's name, email, এবং profile picture থাকবে। React এর মাধ্যমে এটি সহজেই করা যায়।

#### Example:

```jsx
function UserProfile(props) {
  return (
    <div className="profile-card">
      <img src={props.avatar} alt="User Avatar" />
      <h2>{props.name}</h2>
      <p>Email: {props.email}</p>
    </div>
  );
}

const element = (
  <UserProfile
    avatar="https://example.com/avatar.jpg"
    name="John Doe"
    email="john.doe@example.com"
  />
);

ReactDOM.render(element, document.getElementById("root"));
```

#### Explanation:

1. **UserProfile Component**: এখানে **UserProfile** নামে একটি React component তৈরি করা হয়েছে, যা props হিসেবে user এর **name**, **email**, এবং **avatar** image গ্রহণ করে।
2. **Props Usage**: **props.name**, **props.email** ইত্যাদি JSX এর মধ্যে render হচ্ছে, যার ফলে component dynamic ভাবে ব্যবহার করা যায়।
3. **Rendering**: ReactDOM.render() method এর মাধ্যমে component কে DOM এ render করা হয়েছে।

---

### 6. Common JSX Mistakes and Best Practices

#### Mistake 1: Forgetting to Close Tags

JSX এ প্রতিটি element self-closing হওয়া উচিত যদি তার কোনো child না থাকে। উদাহরণস্বরূপ:

```jsx
// Incorrect
<input>

// Correct
<input />
```

#### Mistake 2: Returning Multiple Elements Without Wrapping

JSX এ multiple elements return করতে গেলে এগুলোকে একটি parent element এর মধ্যে রাখতে হয়। উদাহরণস্বরূপ:

```jsx
// Incorrect
return (
  <h1>Hello</h1>
  <p>World</p>
);

// Correct
return (
  <div>
    <h1>Hello</h1>
    <p>World</p>
  </div>
);
```

---

### 7. Conclusion

**JSX** হলো React এর প্রধান syntax যা JavaScript এর মধ্যে HTML elements এবং components তৈরি করতে সাহায্য করে। এটি declarative এবং readable syntax এর কারণে UI development সহজ করে। JSX এর মাধ্যমে আপনি শুধু static content নয়, dynamic JavaScript expressions এবং React components ব্যবহার করতে পারবেন।

JSX এর সঠিক ব্যবহার React এর core concepts বুঝতে সাহায্য করে এবং complex UI গুলোকে সহজে maintainable করে তোলে।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-06: React Components

### Table of Contents:

1. [What are React Components?](#what-are-react-components)
2. [Types of React Components](#types-of-react-components)
   - [Function Components](#function-components)
   - [Class Components](#class-components)
3. [Props in React Components](#props-in-react-components)
4. [State in React Components](#state-in-react-components)
5. [Lifecycle Methods in Class Components](#lifecycle-methods-in-class-components)
6. [Real-life Example of React Components](#real-life-example-of-react-components)
7. [Conclusion](#conclusion)

---

### 1. What are React Components?

**React components** হলো React এর মূল building blocks, যা UI কে ছোট ছোট অংশে ভাগ করে পুনরায় ব্যবহারযোগ্য করে তোলে। প্রতিটি React component একটি JavaScript function বা class যা **HTML-like** structure (JSX) return করে এবং UI এর বিভিন্ন অংশে প্রদর্শিত হয়। Components independent হওয়ার কারণে, একটি component তার নিজস্ব state এবং props ব্যবহার করে নির্দিষ্ট অংশের কাজ সম্পন্ন করে।

##### Example of a Simple React Component:

```jsx
function Welcome() {
  return <h1>Hello, React!</h1>;
}
```

এখানে, **Welcome** হলো একটি React function component যা **Hello, React!** text কে render করে। React components ব্যবহার করে আপনি complex UI গুলোকে ছোট ছোট reusable অংশে ভাগ করতে পারেন।

---

### 2. Types of React Components

React এ দুটি প্রধান ধরনের component আছে: **Function Components** এবং **Class Components**।

#### Function Components

**Function Components** হলো JavaScript functions যা JSX return করে। এগুলো React Hooks ব্যবহার করে state এবং lifecycle এর সাথে কাজ করতে পারে। Function components সাধারণত সহজ এবং lightweight হয়।

##### Example of Function Component:

```jsx
function Greeting(props) {
  return <h1>Hello, {props.name}!</h1>;
}
```

#### Class Components

**Class Components** হলো ES6 এর JavaScript classes যা React.Component থেকে extend করে। এগুলো state এবং lifecycle methods support করে। তবে function components এবং hooks এর আগমনের পর class components এর ব্যবহার কমে গেছে।

##### Example of Class Component:

```jsx
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}
```

---

### 3. Props in React Components

**Props** হলো component এর external data যা parent component থেকে pass করা হয়। এটি immutable, অর্থাৎ component এর ভিতর থেকে props modify করা যায় না। Props এর মাধ্যমে component গুলো dynamic data গ্রহণ করে এবং সেই অনুযায়ী render করতে পারে।

##### Example of Passing Props:

```jsx
function Greeting(props) {
  return <h1>Hello, {props.name}!</h1>;
}

const element = <Greeting name="John" />;
ReactDOM.render(element, document.getElementById("root"));
```

এখানে, **name** prop parent component থেকে **Greeting** component এ pass করা হয়েছে, যা UI তে dynamic data প্রদর্শন করছে।

---

### 4. State in React Components

**State** হলো component এর internal data, যা পরিবর্তনশীল এবং component এর behavior কে dynamically পরিবর্তন করতে পারে। Function components এ state handle করতে **useState Hook** এবং class components এ **this.state** ব্যবহার করা হয়। State dynamic data handle করে, যা user interaction এর উপর ভিত্তি করে পরিবর্তিত হয়।

##### Example of State in Function Component:

```jsx
import React, { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}
```

##### Example of State in Class Component:

```jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  render() {
    return (
      <div>
        <p>You clicked {this.state.count} times</p>
        <button onClick={() => this.setState({ count: this.state.count + 1 })}>
          Click me
        </button>
      </div>
    );
  }
}
```

---

### 5. Lifecycle Methods in Class Components

React class components এ **lifecycle methods** থাকে, যা component এর বিভিন্ন পর্যায়ে (mounting, updating, unmounting) কাজ করতে সাহায্য করে। কিছু গুরুত্বপূর্ণ lifecycle methods হলো:

- **componentDidMount**: component render হওয়ার পর একবার চালানো হয়।
- **componentDidUpdate**: component re-render হলে এটি চালানো হয়।
- **componentWillUnmount**: component destroy হওয়ার আগে চালানো হয়।

##### Example of componentDidMount:

```jsx
class Timer extends React.Component {
  componentDidMount() {
    this.timerID = setInterval(() => this.tick(), 1000);
  }

  tick() {
    console.log("Timer is ticking");
  }

  render() {
    return <h1>Timer Running</h1>;
  }
}
```

---

### 6. Real-life Example of React Components

ধরা যাক, আপনি একটি **User Profile** তৈরি করতে চান যেখানে user এর নাম, বয়স এবং address দেখানো হবে। এটি component ভিত্তিক ভাবে খুব সহজেই করা যায়।

#### Example:

```jsx
function UserProfile(props) {
  return (
    <div className="profile">
      <h2>{props.name}</h2>
      <p>Age: {props.age}</p>
      <p>Address: {props.address}</p>
    </div>
  );
}

const element = (
  <UserProfile name="John Doe" age="30" address="123 React Street" />
);

ReactDOM.render(element, document.getElementById("root"));
```

#### Explanation:

- **UserProfile Component**: এখানে একটি reusable React component তৈরি করা হয়েছে, যা props এর মাধ্যমে dynamic data render করছে।
- **Props**: User এর **name**, **age**, এবং **address** props আকারে **UserProfile** component এ পাঠানো হয়েছে।

---

### 7. Conclusion

React এর **components** modern web development এর cornerstone, কারণ এগুলো UI কে ছোট, reusable অংশে ভাগ করে, যেগুলো dynamic ভাবে কাজ করে। React components বিভিন্ন ধরণের data handle করতে পারে, যেমন props, state, এবং lifecycle methods এর মাধ্যমে complex UI তৈরি করতে পারে।

Function components এবং hooks আসার পর থেকে React এর ব্যবহার আরও সহজ এবং efficient হয়েছে, কিন্তু class components এর শক্তিশালী lifecycle methods এখনও বেশ উপযোগী।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-07: React Class Components

### Table of Contents:

1. [What is a React Class Component?](#what-is-a-react-class-component)
2. [Defining a React Class Component](#defining-a-react-class-component)
3. [React Class vs Function Components](#react-class-vs-function-components)
4. [State in Class Components](#state-in-class-components)
5. [Lifecycle Methods in Class Components](#lifecycle-methods-in-class-components)
6. [Props in Class Components](#props-in-class-components)
7. [Real-life Example of React Class Components](#real-life-example-of-react-class-components)
8. [Conclusion](#conclusion)

---

### 1. What is a React Class Component?

**React Class Components** হলো traditional React components যা ES6 এর JavaScript class এর মাধ্যমে তৈরি করা হয়। Class components ব্যবহার করে state management, lifecycle methods এবং complex functionality সহজে handle করা যায়। যদিও function components এবং React Hooks এর আগমনে class components এর ব্যবহার কমে গেছে, তবুও class components এখনও পুরোনো কোডবেস এবং কিছু complex scenarios তে ব্যবহৃত হয়।

Class components React.Component class থেকে extend করে এবং অবশ্যই **render()** method রাখতে হয়, যা JSX বা React elements return করে।

---

### 2. Defining a React Class Component

React class component define করতে গেলে, আপনাকে ES6 class ব্যবহার করতে হবে, যা **React.Component** class থেকে inherit করে। নিচে একটি React class component এর উদাহরণ দেয়া হলো:

##### Example of Class Component:

```jsx
import React, { Component } from "react";

class Welcome extends Component {
  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}

export default Welcome;
```

#### Explanation:

1. **Welcome Component**: এখানে **Welcome** নামে একটি React class component তৈরি করা হয়েছে, যা **React.Component** থেকে extend করা হয়েছে।
2. **render() Method**: প্রত্যেক React class component এর মধ্যে **render()** method থাকতে হবে, যেখানে JSX বা React elements return করা হবে।
3. **props**: Class components এর মধ্যে **props** **this.props** ব্যবহার করে access করতে হয়।

---

### 3. React Class vs Function Components

React এর শুরুতে class components ব্যবহার করা হতো, কিন্তু function components এবং React Hooks আসার পর থেকে function components বেশি জনপ্রিয়। নিচে দুই ধরনের component এর পার্থক্য দেয়া হলো:

#### Function Components:

- **Simpler**: Function components সহজ এবং lightweight।
- **Hooks**: React Hooks এর মাধ্যমে function components state এবং lifecycle methods manage করতে পারে।
- **Less Boilerplate**: Function components এ class components এর মতো boilerplate কোড লিখতে হয় না।

#### Class Components:

- **State and Lifecycle**: Class components এ state এবং lifecycle methods প্রাকৃতিকভাবে আছে।
- **Legacy Code**: পুরোনো React কোডবেসে এখনও class components ব্যবহার করা হয়।
- **Complex Features**: কিছু complex feature class components এ বেশি সহজে handle করা যায়।

---

### 4. State in Class Components

**State** হলো class component এর internal data, যা dynamic ভাবে পরিবর্তিত হতে পারে এবং component এর UI কে update করতে পারে। Class components এ **this.state** এবং **this.setState()** ব্যবহার করে state manage করা হয়।

##### Example of State in Class Component:

```jsx
import React, { Component } from "react";

class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}

export default Counter;
```

#### Explanation:

1. **this.state**: এখানে **count** নামক একটি state তৈরি করা হয়েছে।
2. **this.setState()**: state update করতে **this.setState()** method ব্যবহার করা হয়েছে।
3. **render()**: state এর পরিবর্তন অনুযায়ী component re-render হয় এবং updated data UI তে প্রদর্শিত হয়।

---

### 5. Lifecycle Methods in Class Components

React class components এর একটি গুরুত্বপূর্ণ feature হলো **lifecycle methods**। এই methods component এর lifecycle এর বিভিন্ন পর্যায়ে (mounting, updating, unmounting) execute হয়।

#### Common Lifecycle Methods:

1. **componentDidMount**: Component render হওয়ার পর এটি একবার execute হয়।
2. **componentDidUpdate**: Component re-render হলে execute হয়।
3. **componentWillUnmount**: Component destroy হওয়ার আগে execute হয়।

##### Example of Lifecycle Method:

```jsx
import React, { Component } from "react";

class Timer extends Component {
  componentDidMount() {
    this.timerID = setInterval(() => this.tick(), 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    console.log("Timer ticking");
  }

  render() {
    return <h1>Timer is running</h1>;
  }
}

export default Timer;
```

#### Explanation:

1. **componentDidMount**: Timer শুরু করার জন্য **setInterval** এখানে ব্যবহার করা হয়েছে, যা component render হওয়ার পর চালু হয়।
2. **componentWillUnmount**: Component destroy হওয়ার আগে **clearInterval** ব্যবহার করে timer বন্ধ করা হয়েছে।

---

### 6. Props in Class Components

**Props** হলো external data যা parent component থেকে class component এ pass করা হয়। Class components এ props **this.props** ব্যবহার করে access করা হয়।

##### Example of Props in Class Component:

```jsx
import React, { Component } from "react";

class Welcome extends Component {
  render() {
    return <h1>Welcome, {this.props.name}!</h1>;
  }
}

export default Welcome;
```

#### Explanation:

1. **this.props**: এখানে **name** prop pass করা হয়েছে, যা **this.props.name** ব্যবহার করে UI তে প্রদর্শিত হচ্ছে।

---

### 7. Real-life Example of React Class Components

ধরা যাক, আপনি একটি **User Profile** class component তৈরি করতে চান, যেখানে user এর নাম এবং বয়স dynamic ভাবে প্রদর্শিত হবে এবং সেই তথ্য পরিবর্তিত হবে।

#### Example:

```jsx
import React, { Component } from "react";

class UserProfile extends Component {
  constructor(props) {
    super(props);
    this.state = { age: 25 };
  }

  incrementAge = () => {
    this.setState({ age: this.state.age + 1 });
  };

  render() {
    return (
      <div>
        <h2>{this.props.name}</h2>
        <p>Age: {this.state.age}</p>
        <button onClick={this.incrementAge}>Increase Age</button>
      </div>
    );
  }
}

export default UserProfile;
```

#### Explanation:

1. **UserProfile Component**: এখানে **UserProfile** একটি class component যা user এর নাম এবং বয়স প্রদর্শন করছে।
2. **Props and State**: User এর নাম **props** এর মাধ্যমে pass করা হয়েছে এবং বয়স **state** এর মাধ্যমে handle করা হচ্ছে।
3. **Increment Function**: **this.setState()** method ব্যবহার করে user এর বয়স বাড়ানো হচ্ছে।

---

### 8. Conclusion

React class components modern web development এর cornerstone, বিশেষ করে state management এবং lifecycle methods handle করার ক্ষেত্রে। যদিও function components এবং React Hooks আসার পরে class components এর ব্যবহার কিছুটা কমেছে, তবুও তারা পুরনো কোডবেস এবং complex applications এর জন্য এখনও গুরুত্বপূর্ণ। Class components এর মাধ্যমে React এর powerful features যেমন state, props, এবং lifecycle methods handle করা সম্ভব হয়।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-08: React Props

### Table of Contents:

1. [What are Props in React?](#what-are-props-in-react)
2. [Why are Props Important?](#why-are-props-important)
3. [How to Pass Props in React](#how-to-pass-props-in-react)
4. [Accessing Props in Components](#accessing-props-in-components)
5. [Default Props](#default-props)
6. [Props vs State](#props-vs-state)
7. [Real-life Example of Props](#real-life-example-of-props)
8. [Conclusion](#conclusion)

---

### 1. What are Props in React?

**Props** হলো React components এর external data যা parent component থেকে child component এ pass করা হয়। React এর **props** system component গুলোর মধ্যে data share এবং dynamic UI তৈরি করার অন্যতম প্রধান উপায়। **Props** immutable, অর্থাৎ component এর ভেতর থেকে props পরিবর্তন করা যায় না, বরং এটি শুধুমাত্র read-only data হিসেবে কাজ করে।

Props এর মাধ্যমে React components reusability বাড়ানো যায়, কারণ parent component থেকে child component এ বিভিন্ন data পাঠানো যায় এবং সেই অনুযায়ী render করা যায়।

##### Example of Props:

```jsx
function Greeting(props) {
  return <h1>Hello, {props.name}!</h1>;
}
```

এখানে **props.name** এর মাধ্যমে **name** নামক external data component এ dynamically প্রদর্শিত হচ্ছে।

---

### 2. Why are Props Important?

Props React এ **reusable** এবং **dynamic** component তৈরি করার জন্য অত্যন্ত গুরুত্বপূর্ণ। এগুলো parent-child component গুলোর মধ্যে data communication এর কাজ করে। Parent component থেকে props pass করলে, child component সেই props data ব্যবহার করে dynamic content তৈরি করতে পারে।

#### Key Reasons Props are Important:

- **Reusability**: Props ব্যবহার করে একই component কে বিভিন্ন data দিয়ে পুনরায় ব্যবহার করা যায়।
- **Dynamic Rendering**: Props এর মাধ্যমে dynamic data handle করা যায়, যা UI কে ব্যবহারকারীর action অনুযায়ী পরিবর্তিত করতে পারে।
- **Unidirectional Data Flow**: React এর props system parent থেকে child component এ data flow নিশ্চিত করে।

---

### 3. How to Pass Props in React

React component এ props pass করতে গেলে JSX attributes এর মতো syntax ব্যবহার করতে হয়। Parent component থেকে child component এ props pass করা খুবই সহজ এবং নিচের উদাহরণে তা দেখানো হয়েছে।

##### Example of Passing Props:

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}!</h1>;
}

const element = <Welcome name="John" />;
ReactDOM.render(element, document.getElementById("root"));
```

#### Explanation:

1. **Parent Component**: Parent component থেকে **name="John"** props হিসেবে pass করা হয়েছে।
2. **Child Component**: Child component (Welcome) **props.name** এর মাধ্যমে সেই data access করছে এবং JSX এর মধ্যে render করছে।

---

### 4. Accessing Props in Components

**Props** কে class component এবং function component দুটিতেই ব্যবহার করা যায়, কিন্তু দুটো component এ props access করার পদ্ধতি কিছুটা আলাদা।

#### Accessing Props in Function Components:

Function components এ **props** function এর argument হিসেবে access করা হয়।

##### Example:

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}!</h1>;
}
```

#### Accessing Props in Class Components:

Class components এ **this.props** ব্যবহার করে props access করা হয়।

##### Example:

```jsx
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}
```

---

### 5. Default Props

কিছু ক্ষেত্রে, component এ কোনো props pass না হলে default value set করা দরকার হতে পারে। এই ক্ষেত্রে React এর **defaultProps** feature ব্যবহার করা হয়।

##### Example of Default Props:

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}!</h1>;
}

Welcome.defaultProps = {
  name: "Guest",
};
```

#### Explanation:

এখানে **name** props pass না করা হলে, **'Guest'** default হিসেবে render হবে।

---

### 6. Props vs State

**Props** এবং **State** উভয়ই component এর data manage করতে ব্যবহৃত হয়, কিন্তু এদের মধ্যে কিছু গুরুত্বপূর্ণ পার্থক্য রয়েছে:

| **Props**                      | **State**                              |
| ------------------------------ | -------------------------------------- |
| Immutable                      | Mutable                                |
| Parent component থেকে pass হয় | Component এর ভেতরে declare করা হয়     |
| Read-only                      | Component এর ভেতর থেকে update করা যায় |
| Unidirectional data flow করে   | Component এর behavior handle করে       |

#### Key Differences:

- **Props** parent থেকে child component এ data pass করার জন্য ব্যবহৃত হয়।
- **State** component এর internal data যা dynamic এবং component এর behavior পরিবর্তন করতে সাহায্য করে।

---

### 7. Real-life Example of Props

ধরা যাক, আপনি একটি **Product Card** component তৈরি করতে চান, যেখানে product এর image, নাম, এবং মূল্য থাকবে। Props ব্যবহার করে parent component থেকে এই data child component এ pass করা হবে।

#### Example:

```jsx
function ProductCard(props) {
  return (
    <div className="product-card">
      <img src={props.image} alt={props.name} />
      <h2>{props.name}</h2>
      <p>Price: ${props.price}</p>
    </div>
  );
}

const product = {
  name: "Laptop",
  price: 1200,
  image: "https://example.com/laptop.jpg",
};

ReactDOM.render(
  <ProductCard
    name={product.name}
    price={product.price}
    image={product.image}
  />,
  document.getElementById("root")
);
```

#### Explanation:

1. **ProductCard Component**: এখানে **ProductCard** নামে একটি component তৈরি করা হয়েছে, যেখানে props এর মাধ্যমে **name**, **price**, এবং **image** pass করা হয়েছে।
2. **Parent Component**: Parent component থেকে product এর সমস্ত data props হিসেবে **ProductCard** component এ pass করা হচ্ছে।
3. **Rendering**: Product এর নাম, মূল্য এবং ছবি dynamic ভাবে render হচ্ছে।

---

### 8. Conclusion

React এর **Props** হলো component গুলোর মধ্যে data flow এবং communication এর অন্যতম প্রধান উপাদান। এটি component কে dynamic ভাবে render করতে এবং reusability বাড়াতে সাহায্য করে। Props immutable হওয়ায় component এর ভিতরে এটি পরিবর্তন করা যায় না, যা predictable এবং stable component তৈরি করতে সহায়ক।

Props এবং state একসাথে ব্যবহার করে complex এবং interactive UI তৈরি করা সম্ভব হয়।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-09: React State & Lifecycle in Class Components

### Table of Contents:

1. [What is State in React Class Components?](#what-is-state-in-react-class-components)
2. [What is Lifecycle in React Class Components?](#what-is-lifecycle-in-react-class-components)
3. [Managing State in Class Components](#managing-state-in-class-components)
   - [Setting Initial State](#setting-initial-state)
   - [Updating State with setState](#updating-state-with-setstate)
4. [React Class Component Lifecycle Phases](#react-class-component-lifecycle-phases)
   - [Mounting Phase](#mounting-phase)
   - [Updating Phase](#updating-phase)
   - [Unmounting Phase](#unmounting-phase)
5. [Common Lifecycle Methods](#common-lifecycle-methods)
   - [componentDidMount](#componentdidmount)
   - [componentDidUpdate](#componentdidupdate)
   - [componentWillUnmount](#componentwillunmount)
6. [Real-life Example: Timer with State and Lifecycle](#real-life-example-timer-with-state-and-lifecycle)
7. [Conclusion](#conclusion)

---

### 1. What is State in React Class Components?

**State** হলো React class component এর internal data, যা component এর behavior এবং appearance পরিবর্তনের জন্য dynamically manage করা হয়। Class components এ **state** এর মাধ্যমে component এ পরিবর্তন আসলে UI সেই অনুযায়ী update হয়। State এমন একটি JavaScript object যা component এর ভেতরে থাকে এবং component এর data বা UI control করতে সাহায্য করে।

##### Example of State:

```jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  render() {
    return <h1>Count: {this.state.count}</h1>;
  }
}
```

---

### 2. What is Lifecycle in React Class Components?

**Component lifecycle** হলো React component এর বিভিন্ন পর্যায় যা component এর creation থেকে destruction পর্যন্ত চলে। একটি React class component মূলত তিনটি ধাপে থাকে:

1. **Mounting**: Component DOM এ প্রথমবার insert হওয়ার সময়।
2. **Updating**: Component এর props বা state পরিবর্তিত হলে।
3. **Unmounting**: Component DOM থেকে remove হওয়ার সময়।

React এর lifecycle methods এই বিভিন্ন ধাপগুলোতে component এর behavior পরিচালনা করে। এই methods component এর বিভিন্ন পর্যায়ে execute হয়, যেমন component যখন render হয় বা destroy হয়।

---

### 3. Managing State in Class Components

#### Setting Initial State

Class component এর **constructor()** method এর মাধ্যমে initial state set করা হয়। **this.state** এর মাধ্যমে state এর initial value নির্ধারণ করা হয়।

##### Example of Initial State:

```jsx
class Greeting extends React.Component {
  constructor(props) {
    super(props);
    this.state = { message: "Hello, World!" };
  }

  render() {
    return <h1>{this.state.message}</h1>;
  }
}
```

#### Updating State with setState

State কে পরিবর্তন করতে হলে **this.setState()** method ব্যবহার করা হয়। এটি asynchronous ভাবে কাজ করে এবং state এর পরিবর্তন অনুযায়ী component re-render করে।

##### Example of Updating State:

```jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <h1>Count: {this.state.count}</h1>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}
```

#### Explanation:

1. **this.state**: Initial state set করার জন্য **this.state** ব্যবহার করা হয়েছে।
2. **this.setState()**: state update করার জন্য **this.setState()** method ব্যবহার করা হয়েছে এবং count increment করা হচ্ছে।

---

### 4. React Class Component Lifecycle Phases

React class component lifecycle তিনটি ধাপে বিভক্ত:

#### Mounting Phase

এই phase এ component DOM এ প্রথমবার insert হয়। কিছু common lifecycle methods হলো:

- **constructor()**
- **componentDidMount()**

#### Updating Phase

Component এর state বা props পরিবর্তিত হলে component update হয়। এই phase এ কিছু common lifecycle methods হলো:

- **shouldComponentUpdate()**
- **componentDidUpdate()**

#### Unmounting Phase

Component যখন DOM থেকে remove হয়, তখন এই phase শুরু হয়। একটি common lifecycle method হলো:

- **componentWillUnmount()**

---

### 5. Common Lifecycle Methods

#### componentDidMount

**componentDidMount** lifecycle method টি তখন execute হয় যখন component DOM এ প্রথমবার render হয়। এটি সাধারণত API calls বা external resources load করার জন্য ব্যবহার করা হয়।

##### Example:

```jsx
class Timer extends React.Component {
  componentDidMount() {
    this.timerID = setInterval(() => this.tick(), 1000);
  }

  tick() {
    console.log("Timer is running");
  }

  render() {
    return <h1>Timer Started</h1>;
  }
}
```

#### componentDidUpdate

**componentDidUpdate** method টি component update হওয়ার পরে execute হয়। এটি props বা state এর পরিবর্তন অনুযায়ী কাজ করতে পারে।

##### Example:

```jsx
class Counter extends React.Component {
  componentDidUpdate(prevProps, prevState) {
    if (this.state.count !== prevState.count) {
      console.log("Count updated");
    }
  }

  render() {
    return <h1>Updated Count: {this.state.count}</h1>;
  }
}
```

#### componentWillUnmount

**componentWillUnmount** method component destroy হওয়ার আগে execute হয়। এটি component এর resources (যেমন timers, subscriptions) clear করতে ব্যবহার করা হয়।

##### Example:

```jsx
class Timer extends React.Component {
  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  render() {
    return <h1>Timer Stopped</h1>;
  }
}
```

---

### 6. Real-life Example: Timer with State and Lifecycle

ধরা যাক, আপনি একটি timer component তৈরি করতে চান, যেখানে প্রতি সেকেন্ডে timer increment হবে এবং component destroy হলে timer বন্ধ হবে।

##### Example:

```jsx
class Timer extends React.Component {
  constructor(props) {
    super(props);
    this.state = { seconds: 0 };
  }

  componentDidMount() {
    this.timerID = setInterval(() => this.tick(), 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    this.setState({ seconds: this.state.seconds + 1 });
  }

  render() {
    return (
      <div>
        <h1>Timer: {this.state.seconds} seconds</h1>
      </div>
    );
  }
}

export default Timer;
```

#### Explanation:

1. **State Management**: Timer component এর state initial value হিসাবে 0 set করা হয়েছে।
2. **Lifecycle Methods**: **componentDidMount** method এর মাধ্যমে timer শুরু করা হয়েছে এবং **componentWillUnmount** method এর মাধ্যমে timer clear করা হয়েছে।
3. **State Update**: **this.setState()** method এর মাধ্যমে প্রতি সেকেন্ডে state update হচ্ছে এবং seconds value বাড়ানো হচ্ছে।

---

### 7. Conclusion

React class components এর **state** এবং **lifecycle methods** React এর অন্যতম প্রধান features, যা dynamic এবং interactive UI তৈরি করতে সাহায্য করে। **State** component এর internal data manage করতে সাহায্য করে, যেখানে **lifecycle methods** component এর lifecycle এর বিভিন্ন পর্যায়ে বিভিন্ন কাজ পরিচালনা করে।

State এবং lifecycle methods ব্যবহার করে আপনি complex functionality handle করতে পারেন, যেমন asynchronous operations (API calls), timers, এবং resource management। Class components এ state এবং lifecycle একসাথে কাজ করে component behavior এবং rendering process কে নিয়ন্ত্রণ করে, যা একটি powerful tool React developers এর জন্য।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-10: React Events

### Table of Contents:

1. [What are Events in React?](#what-are-events-in-react)
2. [How Events Work in React](#how-events-work-in-react)
3. [Handling Events in React](#handling-events-in-react)
4. [Event Handling in Functional and Class Components](#event-handling-in-functional-and-class-components)
5. [Passing Arguments to Event Handlers](#passing-arguments-to-event-handlers)
6. [Common React Event Types](#common-react-event-types)
   - [Click Events](#click-events)
   - [Form Events](#form-events)
   - [Keyboard Events](#keyboard-events)
7. [Real-life Example: Form Handling with Events](#real-life-example-form-handling-with-events)
8. [Conclusion](#conclusion)

---

### 1. What are Events in React?

**Events** React এ এমন কার্যকলাপ যেগুলো ব্যবহারকারী UI এর সাথে ইন্টারেক্ট করলে ট্রিগার হয়। উদাহরণস্বরূপ, button এ click করা, input field এ টাইপ করা, form submit করা — এসবই events। React events web browsers এর native DOM events এর উপর ভিত্তি করে কাজ করে, কিন্তু React events **camelCase** এ লেখা হয় এবং inline **JavaScript functions** বা **function references** এর মাধ্যমে handle করা হয়।

---

### 2. How Events Work in React

React এ event handling এর process কিছুটা আলাদা। Traditional DOM এর events যেমন `onclick`, `onchange` এগুলো lowercase এ লেখা হয়, কিন্তু React এ event attributes গুলো **camelCase** এ লিখতে হয় যেমন `onClick`, `onChange` ইত্যাদি। React events **synthetic events** নামে পরিচিত, যা native browser events এর উপর ভিত্তি করে তৈরি।

Synthetic events cross-browser compatibility নিশ্চিত করে এবং React এর Virtual DOM এর সাথে efficiently কাজ করে।

---

### 3. Handling Events in React

React এ events handle করতে হলে inline function অথবা function reference ব্যবহার করা হয়। একটি React event handling এর উদাহরণ নিচে দেখানো হলো।

##### Example of Event Handling:

```jsx
function ButtonClick() {
  const handleClick = () => {
    alert("Button was clicked!");
  };

  return <button onClick={handleClick}>Click Me</button>;
}
```

#### Explanation:

- **handleClick function**: এই function টি button এ click হলে execute হবে।
- **onClick event**: **onClick** event attribute এর মাধ্যমে **handleClick** function button এ click করার সাথে সাথে ট্রিগার হয়।

---

### 4. Event Handling in Functional and Class Components

React এ event handling class components এবং functional components এ কিছুটা আলাদা পদ্ধতিতে করা হয়। Functional components এ সরাসরি function declare করা হয়, যেখানে class components এ event handlers typically class methods এর মাধ্যমে handle করা হয়।

#### Event Handling in Functional Components:

```jsx
function Greeting() {
  const handleClick = () => {
    console.log("Hello!");
  };

  return <button onClick={handleClick}>Greet</button>;
}
```

#### Event Handling in Class Components:

```jsx
class Greeting extends React.Component {
  handleClick = () => {
    console.log("Hello!");
  };

  render() {
    return <button onClick={this.handleClick}>Greet</button>;
  }
}
```

#### Key Differences:

- **Functional Components**: সরাসরি function declaration এর মাধ্যমে events handle করা হয়।
- **Class Components**: **this** keyword ব্যবহার করে class methods এর মাধ্যমে events handle করা হয়।

---

### 5. Passing Arguments to Event Handlers

React এ event handlers এ arguments pass করা সম্ভব। React এর events automatically **event object** কে প্রথম argument হিসেবে pass করে, তবে আপনি custom arguments pass করতে চাইলে inline function বা arrow function ব্যবহার করতে পারেন।

##### Example of Passing Arguments:

```jsx
function ButtonClick() {
  const handleClick = (message) => {
    alert(message);
  };

  return (
    <button onClick={() => handleClick("Button was clicked!")}>Click Me</button>
  );
}
```

#### Explanation:

- **Arrow Function**: Inline arrow function ব্যবহার করে custom message pass করা হয়েছে।

---

### 6. Common React Event Types

React এ বিভিন্ন ধরনের events আছে, যেগুলো UI এর বিভিন্ন element এর সাথে ব্যবহার করা যায়। নিচে কিছু common event types এর উদাহরণ দেয়া হলো:

#### Click Events

Click event হল এমন একটি event যা button, link, বা যেকোনো clickable element এ ঘটে।

##### Example:

```jsx
<button onClick={() => alert("Button clicked!")}>Click Me</button>
```

#### Form Events

Form elements এর জন্য যেমন **input**, **select**, **textarea** — এগুলোতে **onChange**, **onSubmit** events ব্যবহার করা হয়।

##### Example:

```jsx
function Form() {
  const handleChange = (event) => {
    console.log(event.target.value);
  };

  return <input type="text" onChange={handleChange} placeholder="Type here" />;
}
```

#### Keyboard Events

Keyboard events ব্যবহার করে keyboard interaction handle করা যায়, যেমন key press করা।

##### Example:

```jsx
function KeyPress() {
  const handleKeyPress = (event) => {
    console.log(`Key pressed: ${event.key}`);
  };

  return <input type="text" onKeyPress={handleKeyPress} />;
}
```

---

### 7. Real-life Example: Form Handling with Events

ধরা যাক, আপনি একটি simple form তৈরি করতে চান যেখানে user এর নাম এবং email input field থাকবে এবং submit button এর মাধ্যমে form data handle করা হবে।

##### Example:

```jsx
import React, { useState } from "react";

function SimpleForm() {
  const [formData, setFormData] = useState({ name: "", email: "" });

  const handleChange = (event) => {
    const { name, value } = event.target;
    setFormData((prevData) => ({
      ...prevData,
      [name]: value,
    }));
  };

  const handleSubmit = (event) => {
    event.preventDefault();
    console.log("Form Submitted: ", formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Name:</label>
        <input
          type="text"
          name="name"
          value={formData.name}
          onChange={handleChange}
        />
      </div>
      <div>
        <label>Email:</label>
        <input
          type="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
        />
      </div>
      <button type="submit">Submit</button>
    </form>
  );
}

export default SimpleForm;
```

#### Explanation:

1. **useState Hook**: **useState** hook ব্যবহার করে form এর **name** এবং **email** state management করা হচ্ছে।
2. **handleChange function**: Input field এ কোন পরিবর্তন আসলে সেই data **handleChange** function এর মাধ্যমে state এ store হচ্ছে।
3. **handleSubmit function**: Form submit করার সময় **handleSubmit** function prevent করে browser এর default behavior এবং data console এ দেখানো হচ্ছে।

---

### 8. Conclusion

React এর ইভেন্ট সিস্টেম developer দের dynamic এবং interactive user interfaces তৈরি করতে সাহায্য করে। React এর **synthetic events** ব্রাউজারের বিভিন্ন incompatibility সমস্যা থেকে মুক্তি দেয় এবং একটি unified event handling system প্রদান করে। ইভেন্টগুলোর মাধ্যমে ব্যবহারকারীর actions যেমন **button click**, **keyboard input**, **form submission** ইত্যাদি handle করা হয়।

React এর **functional components** এবং **class components** উভয় ক্ষেত্রেই ইভেন্ট সহজে handle করা যায়। **Props** এর মাধ্যমে ফাংশনগুলো dynamic ভাবে ব্যবহার করা হয় এবং **state management** এর মাধ্যমে UI তে পরিবর্তন আনা হয়।

React এ ইভেন্ট handling এর সুবিধা হলো:

- ইভেন্টগুলো **camelCase** ফর্মেটে লেখা হয় এবং inline function বা reference ফাংশনের মাধ্যমে সহজেই ব্যবহার করা যায়।
- Cross-browser compatibility নিশ্চিত হয় এবং performance উন্নত হয়।

React ইভেন্টগুলো সম্পর্কে ভালো ধারণা থাকলে, interactive এবং responsive web applications তৈরি করা অনেক সহজ হয়ে যায়।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-11: React Conditional Rendering

### Table of Contents:

1. [What is Conditional Rendering?](#what-is-conditional-rendering)
2. [Importance of Conditional Rendering](#importance-of-conditional-rendering)
3. [Different Ways to Implement Conditional Rendering](#different-ways-to-implement-conditional-rendering)
   - [Using if/else Statements](#using-ifelse-statements)
   - [Using Ternary Operators](#using-ternary-operators)
   - [Using Logical && Operator](#using-logical--operator)
   - [Using Switch Statements](#using-switch-statements)
4. [Real-life Example of Conditional Rendering](#real-life-example-of-conditional-rendering)
5. [Best Practices for Conditional Rendering](#best-practices-for-conditional-rendering)
6. [Conclusion](#conclusion)

---

### 1. What is Conditional Rendering?

React এ **Conditional Rendering** মানে হলো component গুলো নির্দিষ্ট শর্তের (conditions) ভিত্তিতে UI তে render হয়। অর্থাৎ, শর্ত অনুযায়ী একটি component UI তে প্রদর্শিত হবে, না হলে অন্য কিছু দেখানো হবে। উদাহরণস্বরূপ, user login করা থাকলে তার profile দেখা যাবে, আর না থাকলে login form দেখানো হবে।

---

### 2. Importance of Conditional Rendering

React এ **Conditional Rendering** এর গুরুত্ব অনেক। এটি আমাদের dynamic এবং responsive UI তৈরি করতে সাহায্য করে। Web application এ user এর interaction, data এবং state এর উপর ভিত্তি করে UI বিভিন্ন ভাবে পরিবর্তন করা প্রয়োজন হয়। এই dynamic পরিবর্তনগুলি Conditional Rendering এর মাধ্যমে সহজেই সম্ভব।

উদাহরণস্বরূপ, একটি e-commerce site এ user logged in থাকলে তার order history দেখানো হয়, আর logged in না থাকলে তাকে login করতে বলা হয়। এছাড়াও, যদি কোনো API call থেকে data fetch করতে সময় লাগে, তখন loader দেখানো হয় এবং data পাওয়ার পর result দেখানো হয়।

---

### 3. Different Ways to Implement Conditional Rendering

#### Using if/else Statements

Traditional **if/else** statement ব্যবহার করে React এ সহজেই conditional rendering করা যায়। তবে এই statements JSX এর মধ্যে ব্যবহার করা সম্ভব নয়, তাই function এর ভেতরে রাখতে হয়।

##### Example:

```jsx
function Greeting(props) {
  if (props.isLoggedIn) {
    return <h1>Welcome back!</h1>;
  } else {
    return <h1>Please sign up.</h1>;
  }
}

ReactDOM.render(
  <Greeting isLoggedIn={true} />,
  document.getElementById("root")
);
```

#### Breakdown:

- **if/else Statement**: এখানে **props.isLoggedIn** এর মান চেক করা হচ্ছে। যদি true হয়, তাহলে "Welcome back!" দেখানো হচ্ছে। না হলে "Please sign up."।
- Output:
  - যদি **isLoggedIn** true হয়: **"Welcome back!"**
  - যদি **isLoggedIn** false হয়: **"Please sign up."**

#### Using Ternary Operators

**Ternary operator** React এ conditional rendering এর জন্য সবচেয়ে সংক্ষিপ্ত উপায়। এটি একই কোড আরও ছোট করে লিখতে সাহায্য করে।

##### Example:

```jsx
function Greeting(props) {
  return (
    <div>
      {props.isLoggedIn ? <h1>Welcome back!</h1> : <h1>Please sign up.</h1>}
    </div>
  );
}

ReactDOM.render(
  <Greeting isLoggedIn={false} />,
  document.getElementById("root")
);
```

#### Breakdown:

- **Ternary Operator**: এক লাইনে condition check করে "Welcome back!" বা "Please sign up." দেখানো হচ্ছে।
- Output:
  - যদি **isLoggedIn** true হয়: **"Welcome back!"**
  - যদি **isLoggedIn** false হয়: **"Please sign up."**

#### Using Logical && Operator

**Logical && operator** React এ এমন শর্ত ব্যবহারের জন্য উপযুক্ত যেখানে কোনো শর্ত true হলে শুধুমাত্র একটি অংশ render হবে।

##### Example:

```jsx
function Greeting(props) {
  return <div>{props.isLoggedIn && <h1>Welcome back!</h1>}</div>;
}

ReactDOM.render(
  <Greeting isLoggedIn={true} />,
  document.getElementById("root")
);
```

#### Breakdown:

- **Logical && operator**: এখানে **props.isLoggedIn** true হলে "Welcome back!" দেখানো হচ্ছে। যদি false হয়, কিছুই render হবে না।
- Output:
  - যদি **isLoggedIn** true হয়: **"Welcome back!"**
  - যদি **isLoggedIn** false হয়: **(কিছুই দেখাবে না)**

#### Using Switch Statements

যখন একাধিক শর্ত থাকে, তখন **switch statement** ব্যবহার করা হয়। এটি বড় বড় conditions সহজে handle করতে সাহায্য করে।

##### Example:

```jsx
function Greeting(props) {
  switch (props.status) {
    case "guest":
      return <h1>Welcome, Guest!</h1>;
    case "user":
      return <h1>Welcome back!</h1>;
    case "admin":
      return <h1>Welcome, Admin!</h1>;
    default:
      return <h1>Hello!</h1>;
  }
}

ReactDOM.render(<Greeting status="admin" />, document.getElementById("root"));
```

#### Breakdown:

- **Switch Statement**: এখানে **props.status** চেক করে বিভিন্ন greeting message দেখানো হচ্ছে। যেমন, guest এর জন্য "Welcome, Guest!" এবং admin এর জন্য "Welcome, Admin!"।
- Output:
  - **status** "admin" হলে: **"Welcome, Admin!"**
  - **status** "guest" হলে: **"Welcome, Guest!"**
  - অন্য কোনো status থাকলে: **"Hello!"**

---

### 4. Real-life Example of Conditional Rendering

একটি বাস্তব উদাহরণে ধরুন, একটি **E-commerce Dashboard** রয়েছে, যেখানে user logged in থাকলে তার নাম এবং recent order গুলো দেখানো হবে, আর logged in না থাকলে তাকে login করতে বলবে।

##### Example:

```jsx
function UserDashboard(props) {
  if (props.isLoggedIn) {
    return (
      <div>
        <h1>Welcome back, {props.userName}!</h1>
        <p>Here are your recent orders:</p>
        {/* Order details */}
      </div>
    );
  } else {
    return (
      <div>
        <h1>Please log in to view your dashboard.</h1>
        <button onClick={props.onLogin}>Login</button>
      </div>
    );
  }
}

ReactDOM.render(
  <UserDashboard
    isLoggedIn={false}
    userName="John"
    onLogin={() => alert("Logging in...")}
  />,
  document.getElementById("root")
);
```

#### Breakdown:

- **isLoggedIn চেক করা হচ্ছে**: যদি user logged in থাকে, তার নাম এবং order details দেখানো হবে। আর না থাকলে login button দেখানো হবে।
- **Output**:
  - যদি **isLoggedIn = true** হয়, তাহলে দেখাবে:
    ```
    Welcome back, John!
    Here are your recent orders.
    ```
  - যদি **isLoggedIn = false** হয়, তাহলে দেখাবে:
    ```
    Please log in to view your dashboard.
    [Login Button]
    ```

---

### 5. Best Practices for Conditional Rendering

1. **Simple Logic ব্যবহার করুন**: Complex conditional rendering এর জন্য কোডকে যতটা সম্ভব সহজ রাখা উচিত। ছোট শর্তগুলির জন্য **ternary operator** এবং **&& operator** ব্যবহার করতে পারেন। উদাহরণস্বরূপ, একটি খুব ছোট condition এর জন্য একাধিক **if/else** না করে **ternary operator** ব্যবহার করতে পারেন।
2. **Nested JSX এড়িয়ে চলুন**: Nested JSX অনেক ক্ষেত্রে পড়তে এবং বোঝাতে জটিল হয়ে যায়। এর চেয়ে ভালো উপায় হলো subcomponents তৈরি করা।

3. **Switch Statement ব্যবহার করুন**: যখন একাধিক শর্ত রয়েছে, তখন **switch statement** ব্যবহার করলে কোড সহজ এবং পরিষ্কার হয়।

---

### 6. Conclusion

React এর **Conditional Rendering** একটি শক্তিশালী ফিচার, যা UI কে dynamic এবং responsive করতে সাহায্য করে। এই পদ্ধতিতে আপনি user এর state বা props এর উপর ভিত্তি করে UI এর বিভিন্ন অংশকে পরিবর্তন করতে পারেন। React এ conditional rendering এর বিভিন্ন পদ্ধতি রয়েছে, যেমন **if/else**, **ternary operators**, **&& operator**, এবং **switch statement**। প্রতিটি পদ্ধতি situation অনুযায়ী উপযোগী, তবে সবসময় কোডকে সহজ এবং পরিষ্কার রাখার চেষ্টা করা উচিত।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-12:

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-12:

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Project-01:

### Difficulty: Easy (2/10)

### You Will Learn

-

### Project Description

### Project Screenshot

### Live Project Link

[Open in CodePen]()

### Video Explanation

Coming Soon...

### Project Source Codes

[Source Codes]()
