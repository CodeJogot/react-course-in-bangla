# Learn ReactJS in 30 Chapters

### After completing this course, we'll build [5 Projects](#) with ReactJS.

While you complete the 30-chapter module, jump in the [Projects Section](#).

|                                    Chapter                                     |                                                               Topics                                                               | Video Explanation |
| :----------------------------------------------------------------------------: | :--------------------------------------------------------------------------------------------------------------------------------: | :---------------: |
|                                    [00](#)                                     |                                                                []()                                                                |   [Watch Now]()   |
|                   [01](#chapter-01-introduction-to-reactjs)                    |                                  [Introduction to React.js](#chapter-01-introduction-to-reactjs)                                   |   [Watch Now]()   |
|                   [01.1](#chapter-011-library-vs-framework)                    |                                      [Libray vs Framework](#chapter-011-library-vs-framework)                                      |   [Watch Now]()   |
|                 [02](#chapter-02-react-virtual-dom-what--why)                  |                              [React Virtual DOM: What & Why](#chapter-02-react-virtual-dom-what--why)                              |     Watch Now     |
| [03](#chapter-03-how-to-install-react-step-by-step-guide-with-example-project) | [How to Install React (Step by Step Guide with Example)](#chapter-03-how-to-install-react-step-by-step-guide-with-example-project) |     Watch Now     |
|                  [03.1](#chapter-031-react-install-with-vite)                  |                                  [React Install with Vite](#chapter-031-react-install-with-vite)                                   |     Watch Now     |
|                      [04](#chapter-04-react-render-html)                       |                                         [React Render HTML](#chapter-04-react-render-html)                                         |     Watch Now     |
|                          [05](#chapter-05-react-jsx)                           |                                                 [React JSX](#chapter-05-react-jsx)                                                 |     Watch Now     |
|                       [06](#chapter-06-react-components)                       |                                          [React Components](#chapter-06-react-components)                                          |     Watch Now     |
|                    [07](#chapter-07-react-class-components)                    |                                    [React Class Components](#chapter-07-react-class-components)                                    |     Watch Now     |
|           [07.1](#chapter-071-lifecycle-methods-in-class-components)           |                     [Lifecyle Methods in Class Components](#chapter-071-lifecycle-methods-in-class-components)                     |     Watch Now     |
|                 [07.2](#chapter-072-props-in-class-components)                 |                                [Props in Class Components](#chapter-072-props-in-class-components)                                 |     Watch Now     |
|                [08](#chapter-08-props-in-functional-components)                |                            [Props in Functional Components](#chapter-08-props-in-functional-components)                            |     Watch Now     |
|          [09](#chapter-09-react-state--lifecycle-in-class-components)          |               [React State & Lifecycle in Class Components](#chapter-09-react-state--lifecycle-in-class-components)                |     Watch Now     |
|                         [10](#chapter-10-react-events)                         |                                              [React Events](#chapter-10-react-events)                                              |     Watch Now     |
|                 [11](#chapter-11-react-conditional-rendering)                  |                               [React Conditional Rendering](#chapter-11-react-conditional-rendering)                               |     Watch Now     |
|                                    [12](#)                                     |                                            [](#chapter-12-css-float-display-alignment)                                             |     Watch Now     |
|                         [13](#chapter-13-css-flexbox)                          |                                                    [](#chapter-13-css-flexbox)                                                     |     Watch Now     |
|                        [14](#chapter-14-css-selectors)                         |                                                   [](#chapter-14-css-selectors)                                                    |     Watch Now     |
|                    [15](#chapter-15-css-text-fonts--icons)                     |                                               [](#chapter-15-css-text-fonts--icons)                                                |     Watch Now     |
|          [16](#chapter-16-css-links-lists-tables-display--max-width)           |                                     [](#chapter-16-css-links-lists-tables-display--max-width)                                      |     Watch Now     |
|             [17](#chapter-17-css-image-gallery-and-image-sprites)              |                                        [](#chapter-17-css-image-gallery-and-image-sprites)                                         |     Watch Now     |
|                                       18                                       |                                                                                                                                    |     Watch Now     |
|            [19](#chapter-19-visualize-and-play-with-css-properties)            |                                       [](#chapter-19-visualize-and-play-with-css-properties)                                       |     Watch Now     |
|                       [20](#chapter-20-css-grid-layout)                        |                                                  [](#chapter-20-css-grid-layout)                                                   |     Watch Now     |
|                         [21](#chapter-21-css-gradient)                         |                                                    [](#chapter-21-css-gradient)                                                    |     Watch Now     |
|                   [22](#chapter-22-css-2d-and-3d-transforms)                   |                                              [](#chapter-22-css-2d-and-3d-transforms)                                              |     Watch Now     |
|                        [23](#chapter-23-css-animations)                        |                                                                []()                                                                |     Watch Now     |
|                                       24                                       |                                                                                                                                    |     Watch Now     |
|                                       25                                       |                                                                                                                                    |     Watch Now     |
|                                       26                                       |                                                                                                                                    |     Watch Now     |
|                                       27                                       |                                                                                                                                    |     Watch Now     |
|                                       28                                       |                                                                                                                                    |     Watch Now     |
|                                       29                                       |                                                                                                                                    |     Watch Now     |
|                                       30                                       |                                                                                                                                    |     Watch Now     |

# 5 React.js Projects

|                     Project No.                      |                    Project Name                    | Video Explanation |   Live Demo   |
| :--------------------------------------------------: | :------------------------------------------------: | :---------------: | :-----------: |
|                          01                          |                                                    |     Watch Now     |   Live Demo   |
|  [02](#project-02-simple-website-layout-with-float)  |  [](#project-02-simple-website-layout-with-float)  |     Watch Now     |   Live Demo   |
| [03](#project-03-simple-website-layout-with-flexbox) | [](#project-03-simple-website-layout-with-flexbox) |     Watch Now     |   Live Demo   |
|                          04                          |                                                    |     Watch Now     |   Live Demo   |
|      [05](#project-05-simple-3d-animation-page)      |      [](#project-05-simple-3d-animation-page)      |  [Watch Now](#)   | [Live Demo]() |

# Chapter-00: How The Course is Designed

### কোর্সটি যেভাবে সাজানো হয়েছেঃ

- এই পুরো Article কে একটা বই মনে করতে পারেন। কোর্সটি 30 টি Chapter এ ভাগ করা হয়েছে। প্রতিটি Chapter এ React.js এর বিভিন্ন Topics নিয়ে আলোচনা করা হয়েছে।
- প্রতিটা Chapter এর Module সাজানো হয়েছে ক্রমানুসারে । উদাহরণস্বরূপ, Chapter-05 এর টপিকসগুলো শিখতে হলে অবশ্যই আপনাকে Chapter-04 শেষ করে আসতে হবে। একইভাবে Chapter-04 শিখতে হলে আপনাকে Chapter-03 শেষ করে আসতে হবে ।
- প্রতিটা Chapter এর Topics এর Written Documentation/Explanation এর সাথে সাথে Video Explanation-ও দেয়া আছে। যাতে শিক্ষার্থীরা খুব সহজেই টপিকসগুলো আত্মস্থ করতে পারে।

### কোর্সটি কাদের জন্য?

- এই কোর্সটিতে যেকেউ অংশগ্রহণ করতে পারবে। শিখার জন্য মনের ইচ্ছাটাই আসল!
- Course টি মূলত Beginner-friendly.

### Prerequisite

- Good understanding of HTML, CSS, JavaScript.

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-01: Introduction to React.js

### Table of Contents:

1. [What is React?](#what-is-react)
   - [Single Page Application (SPA) কি?](#single-page-application-spa-কি)
   - [Component-Based Architecture কি?](#component-based-architecture-কি)
2. [Why Use React?](#why-use-react)
   - [Efficient UI Updates](#efficient-ui-updates)
   - [Example of Efficient UI Updates](#example-of-efficient-ui-updates)
3. [Problems Without React](#problems-without-react)
   - [Manual DOM Manipulation এর জটিলতা](#manual-dom-manipulation-জটিলতা)
   - [Poor Code Reusability](#poor-code-reusability)
   - [Complex State Management](#complex-state-management)
4. [Conclusion](#conclusion)

---

### 1. What is React?

**ReactJS** হলো একটি **JavaScript library** যা user interfaces (UI) তৈরি করতে ব্যবহৃত হয়। এটি মূলত **Single Page Applications (SPA)** এর জন্য ব্যবহৃত হয়, যেখানে web page এর বিভিন্ন অংশ dynamically update হয়, কিন্তু পুরো page reload হয় না। React প্রথমে **Facebook** দ্বারা ২০১৩ সালে তৈরি করা হয় এবং এখন এটি modern web development এর অন্যতম জনপ্রিয় library হিসেবে বিবেচিত হয়।

#### Example of a Simple React Component:

```jsx
function Welcome() {
  return <h1>Hello, React!</h1>;
}

export default Welcome;
```

React এর প্রধান বৈশিষ্ট্য হলো **Component-based Architecture**, যেখানে UI কে ছোট ছোট, পুনরায় ব্যবহারযোগ্য অংশে ভাগ করা যায়।

---

### 1.1 Single Page Application (SPA) কি?

**Single Page Application (SPA)** হলো একটি ধরনের web application, যেখানে একটি page load হওয়ার পর user এর interaction অনুযায়ী page এর বিভিন্ন অংশ dynamically update হয়, কিন্তু পুরো page reload হয় না। Traditional multi-page applications এ প্রতিবার কোনো page পরিবর্তন করার জন্য server থেকে নতুন HTML file fetch করতে হয়, কিন্তু SPA তে এটি প্রয়োজন হয় না। React মূলত SPA তৈরি করার জন্য ব্যবহৃত হয়, যা web applications কে দ্রুততর এবং seamless করে তোলে।

#### Example:

ধরুন, আপনি একটি Traditional web application ব্যবহার করছেন, যেখানে প্রতিবার আপনি কোনো নতুন section এ যান, তখন নতুন একটি HTML পেজ লোড হয় এবং পুরো পেজ রিলোড হয়। কিন্তু **React** ব্যবহার করলে, page এর নির্দিষ্ট অংশ dynamically update হয়, যা user experience কে দ্রুত এবং responsive করে তোলে।

---

### 1.2 Component-Based Architecture কি?

React এর সবচেয়ে শক্তিশালী বৈশিষ্ট্য হলো এর **component-based architecture**। এর মাধ্যমে পুরো UI কে ছোট ছোট পুনঃব্যবহারযোগ্য অংশে ভাগ করা যায়, যাকে **components** বলে। প্রতিটি component একটি নির্দিষ্ট কাজ সম্পন্ন করে এবং UI এর বিভিন্ন অংশের জন্য আলাদা আলাদা component তৈরি করা যায়।

#### Example:

```jsx
function Navbar() {
  return (
    <nav>
      <ul>
        <li>Home</li>
        <li>About</li>
        <li>Contact</li>
      </ul>
    </nav>
  );
}
```

এখানে একটি **Navbar** component তৈরি করা হয়েছে। এখন আপনি Navbar component কে যেকোনো page এ পুনরায় ব্যবহার করতে পারবেন, এবং যদি কোনো পরিবর্তন প্রয়োজন হয়, তবে component এ পরিবর্তন করে সমস্ত জায়গায় একই পরিবর্তন reflect হবে। এটি development process কে দ্রুত এবং maintainable করে।

---

### 2. Why Use React?

React এর কিছু গুরুত্বপূর্ণ সুবিধা হলো:

1. **Efficient UI Updates**:
   - React এর মাধ্যমে user interaction এর উপর ভিত্তি করে page এর নির্দিষ্ট অংশ update করা যায়। React এর **Virtual DOM** feature এর কারণে এটি খুব দ্রুত এবং efficient ভাবে কাজ করে।

#### Example of Efficient UI Updates with Virtual DOM:

```jsx
import React, { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

উপরের উদাহরণে, **count** state প্রতিবার increment হচ্ছে যখন user **button** এ click করছে। React এর **Virtual DOM** এর মাধ্যমে শুধুমাত্র **count** এর অংশটি রি-রেন্ডার হচ্ছে। DOM এর অন্য কোনো অংশ পরিবর্তন হচ্ছে না, যার ফলে UI দ্রুত এবং efficient ভাবে update হচ্ছে।

#### Example Without Virtual DOM:

ধরা যাক, আমরা traditional JavaScript দিয়ে এটি করতে চাই:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Counter Example</title>
    <script>
      function increment() {
        var count = document.getElementById("count");
        count.innerHTML = parseInt(count.innerHTML) + 1;
      }
    </script>
  </head>
  <body>
    <h1>Count: <span id="count">0</span></h1>
    <button onclick="increment()">Increment</button>
  </body>
</html>
```

এখানে প্রতিবার **button** এ click করলে আমরা manual DOM manipulation করছি। JavaScript সরাসরি DOM এর সাথে কাজ করছে, যা বড় application এ performance সমস্যার সৃষ্টি করে। React এর মতো **Virtual DOM** না থাকায় প্রতিবার DOM পরিবর্তনের জন্য browser কে পুরো structure রি-রেন্ডার করতে হয়। এছাড়া DOM এর direct manipulation সময়সাপেক্ষ এবং memory-heavy হয়ে যায়।

#### Why React’s Approach is Better:

- **Performance**: React এর **Virtual DOM** শুধুমাত্র প্রয়োজনীয় অংশটুকু update করে, যেখানে traditional approach এ পুরো DOM structure কে পরিবর্তন করতে হয়।
- **Maintainability**: React এর **declarative syntax** এবং automatic DOM update এর কারণে complex UI গুলোও সহজে manage করা যায়।

---

### 3. Problems Without React

React ছাড়া modern web applications তৈরি করতে traditional DOM manipulation পদ্ধতি ব্যবহার করতে হয়, যা বড় বড় applications এর জন্য অনেক সমস্যা তৈরি করতে পারে।

#### 1) Manual DOM Manipulation এর জটিলতা

Traditional JavaScript দিয়ে DOM এর elements manually manipulate করতে গেলে আপনাকে প্রতিটি element এর জন্য DOM API (`getElementById`, `querySelector`) ব্যবহার করতে হয়, এবং প্রতিবার page এ কোনো পরিবর্তন আনতে হলে নতুন করে পুরো DOM এর সাথে interaction করতে হয়। এর ফলে UI complex হয়ে গেলে কোড অনেক বেশি জটিল এবং দুর্বল হয়ে পড়ে।

#### Example Without React (Dynamic List):

ধরুন, আপনি একটি **To-Do List** তৈরি করতে চান যেখানে user নতুন নতুন items যোগ করতে পারে:

```html
<!DOCTYPE html>
<html>
  <head>
    <script>
      function addItem() {
        const list = document.getElementById("list");
        const newItem = document.createElement("li");
        const inputValue = document.getElementById("input").value;
        newItem.textContent = inputValue;
        list.appendChild(newItem);
        document.getElementById("input").value = "";
      }
    </script>
  </head>
  <body>
    <h1>To-Do List</h1>
    <input type="text" id="input" placeholder="Enter new item" />
    <button onclick="addItem()">Add</button>
    <ul id="list"></ul>
  </body>
</html>
```

এখানে প্রতিবার user নতুন item যোগ করলে list এ একটি নতুন **`<li>`** element যোগ করতে হচ্ছে। JavaScript এর মাধ্যমে আমরা DOM এ সরাসরি manipulate করছি, যা বড় বা complex lists এর জন্য খুবই জটিল হয়ে পড়ে এবং performance সমস্যা তৈরি করতে পারে।

#### 2) Poor Code Reusability

Traditional JavaScript কোড reusability এর ক্ষেত্রে দুর্বল। যদি একই ধরনের UI element বারবার তৈরি করতে হয়, আপনাকে বারবার কোড লিখতে হবে, যা redundancy সৃষ্টি করে এবং bugs এর সম্ভাবনা বাড়ায়।

#### Example Without React (Navbar):

```html
<nav>
  <ul>
    <li>Home</li>
    <li>About</li>
    <li>Contact</li>
  </ul>
</nav>
```

এখানে আমরা একটি simple **Navbar** তৈরি করেছি। এখন যদি আরেকটি similar navbar তৈরি করতে হয়, তবে আপনাকে একই কোড আবার লিখতে হবে। Traditional JavaScript এ আপনি component-based architecture ব্যবহার করতে পারবেন না, যার ফলে UI element গুলোকে পুনরায় ব্যবহার করতে সমস্যা হয়।

#### 3) Complex State Management

Traditional JavaScript এ **state management** খুবই জটিল। যদি page এর বিভিন্ন element এর উপর ভিত্তি করে UI update করতে হয়, তবে আপনাকে বিভিন্ন DOM element এর সাথে synchronize করতে হবে। এটি বড় application এর ক্ষেত্রে অনেক জটিল হয়ে পড়ে।

#### Example (Without React State):

```html
<input type="text" id="name" placeholder="Enter your name" />
<button onclick="updateGreeting()">Greet</button>
<h1 id="greeting">Hello,</h1>

<script>
  function updateGreeting() {
    const name = document.getElementById("name").value;
    document.getElementById("greeting").innerHTML = "Hello, " + name;
  }
</script>
```

---

#### Solution with React:

React এর **state management** feature আপনাকে সহজে component এর state handle করতে দেয়, এবং UI এর পরিবর্তন স্বয়ংক্রিয়ভাবে synchronize হয়:

```jsx
import React, { useState } from "react";

function Greeting() {
  const [name, setName] = useState("");

  return (
    <div>
      <input
        type="text"
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Enter your name"
      />
      <h1>Hello, {name}!</h1>
    </div>
  );
}

export default Greeting;
```

এই উদাহরণে, user input অনুযায়ী greeting dynamically update হচ্ছে, এবং React এর **state** পরিবর্তন অনুযায়ী UI render হচ্ছে। JavaScript এর সরাসরি DOM manipulation এর প্রয়োজন নেই।

---

### 4. Conclusion

React একটি declarative, efficient, এবং flexible JavaScript library, যা modern web development এর জন্য অত্যন্ত উপযোগী। এটি UI development কে সহজতর করে, বিশেষত complex applications এর জন্য যেখানে dynamic content management প্রয়োজন।

React এর সবচেয়ে বড় সুবিধা হলো **component-based architecture** এবং **Virtual DOM**, যা UI management এবং performance সমস্যাগুলোকে অনেক সহজ করে তোলে। Traditional JavaScript এর তুলনায় React development আরও maintainable এবং reusable করে তোলে, যা large-scale applications এর জন্য বিশেষভাবে গুরুত্বপূর্ণ।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-01.1: Library vs Framework

### Table of Contents:

1. [What is a Library?](#what-is-a-library)
2. [What is a Framework?](#what-is-a-framework)
3. [Key Differences Between Library and Framework](#key-differences-between-library-and-framework)
4. [Examples of Popular Libraries and Frameworks](#examples-of-popular-libraries-and-frameworks)
5. [When to Use a Library vs. a Framework](#when-to-use-a-library-vs-a-framework)
6. [Conclusion](#conclusion)

---

### 1. What is a Library?

**Library** হলো এমন একটি code collection বা package, যা নির্দিষ্ট কাজ বা functionalities সম্পন্ন করার জন্য ব্যবহৃত হয়। এটি সাধারণত pre-written functions বা methods এর একটি সমাহার, যা developer দের একটি নির্দিষ্ট কাজ সহজে সম্পন্ন করতে সাহায্য করে। Library ব্যবহার করলে developer দের প্রয়োজনীয় function বা method call করে ব্যবহার করতে হয়, অর্থাৎ developer ই decide করে, কখন, কিভাবে, এবং কোথায় সেই code ব্যবহার হবে।

##### উদাহরণ:

JavaScript এর **React** একটি library, যা user interface তৈরি করতে ব্যবহৃত হয়। React developer দের components তৈরি এবং তাদের মধ্যে data pass করার জন্য functions এবং methods প্রদান করে, কিন্তু পুরো application structure বা control developer এর উপর থাকে।

---

### 2. What is a Framework?

**Framework** হলো একটি complete structure বা architecture, যা পুরো application এর জন্য একটি নির্দিষ্ট guideline এবং control প্রদান করে। Framework ব্যবহার করলে, developer দের নির্দিষ্ট rules এবং conventions অনুযায়ী code লিখতে হয়। এটি একটি predefined code structure প্রদান করে এবং application এর control অনেকাংশে framework এর উপর থাকে, যেখানে developer নির্দিষ্ট parts এ code লিখতে পারেন।

##### উদাহরণ:

JavaScript এর **Angular** একটি framework, যা একটি complete structure বা architecture প্রদান করে। Angular application তৈরি করার সময় developer দের Angular এর বিভিন্ন services, components, এবং modules ব্যবহার করতে হয়, এবং Angular application এর flow এবং lifecycle manage করে।

---

### 3. Key Differences Between Library and Framework

| **Aspect**      | **Library**                                              | **Framework**                                          |
| --------------- | -------------------------------------------------------- | ------------------------------------------------------ |
| **Control**     | Developer control করে কিভাবে এবং কোথায় code ব্যবহার হবে | Framework control করে application structure এবং flow   |
| **Flexibility** | Developer এর হাতে বেশি flexibility থাকে                  | Framework এর নির্দিষ্ট guideline অনুযায়ী কাজ করতে হয় |
| **Usage**       | নির্দিষ্ট কাজ সম্পন্ন করার জন্য library import করা হয়   | Framework application এর পুরো structure তৈরি করে       |
| **Examples**    | React, Lodash, jQuery                                    | Angular, Vue.js, Django                                |

#### Explanation:

- **Control**: Library ব্যবহার করলে developer control করে কিভাবে function call করা হবে। Framework এ control অনেকাংশে framework নিজেই করে, developer framework এর নির্দিষ্ট rules অনুযায়ী code লিখেন।
- **Flexibility**: Library এর ক্ষেত্রে developer ই নির্ধারণ করেন কিভাবে এবং কখন library এর code ব্যবহার করা হবে। Framework এর ক্ষেত্রে developer framework এর নির্দিষ্ট structure এবং guideline অনুসরণ করে code লিখেন।
- **Usage**: Library সাধারণত ছোট কাজগুলো (যেমন: data manipulation, DOM manipulation) সহজ করতে ব্যবহৃত হয়। Framework একটি পূর্ণাঙ্গ application তৈরি করার জন্য ব্যবহৃত হয়, যেখানে পুরো application structure predefined থাকে।

---

### 4. Examples of Popular Libraries and Frameworks

#### Libraries:

1. **React** (JavaScript)
2. **Lodash** (JavaScript)
3. **jQuery** (JavaScript)
4. **NumPy** (Python)
5. **Pandas** (Python)

#### Frameworks:

1. **Angular** (JavaScript)
2. **Vue.js** (JavaScript)
3. **Django** (Python)
4. **Laravel** (PHP)
5. **Spring** (Java)

React এর মতো library developer দের UI components তৈরির flexibility প্রদান করে, যেখানে Angular এর মতো framework একটি পূর্ণাঙ্গ structure এবং control প্রদান করে।

---

### 5. When to Use a Library vs. a Framework

#### When to Use a Library:

- যদি আপনার application এর একটি নির্দিষ্ট part এর জন্য code reusability এবং flexibility দরকার হয়।
- যখন আপনি কিছু specific functionality যেমন DOM manipulation (jQuery) বা data manipulation (Lodash, Pandas) করতে চান।
- যখন আপনি পুরো application structure নিজের মতো করে তৈরি করতে চান এবং তার উপর control রাখতে চান।

#### When to Use a Framework:

- যদি আপনি একটি complete application তৈরি করতে চান এবং predefined structure এবং architecture ব্যবহার করতে চান।
- যখন আপনি code organization এবং application structure নিয়ে সময় বাঁচাতে চান।
- যখন একটি large-scale application তৈরি করতে হবে এবং একটি scalable structure দরকার।

---

### 6. Conclusion

**Library** এবং **Framework** উভয়ই software development এর জন্য গুরুত্বপূর্ণ tools, তবে এদের কাজ এবং control এর ধরণ ভিন্ন।

- **Library** developer কে নির্দিষ্ট কাজ সম্পন্ন করার জন্য flexibility দেয় এবং developer control করে কিভাবে এবং কখন সেই library ব্যবহার হবে।
- **Framework** একটি পূর্ণাঙ্গ architecture বা structure প্রদান করে এবং developer কে সেই structure অনুযায়ী কাজ করতে হয়। Framework অনেক ক্ষেত্রে control ধরে রাখে এবং application এর flow manage করে।

React এর মতো libraries ছোট ছোট components তৈরি করতে সাহায্য করে, যেখানে Angular এর মতো frameworks পুরো application structure নির্ধারণ করে দেয়। আপনার application এর nature এবং requirement এর উপর ভিত্তি করে library বা framework বেছে নেওয়া উচিত।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-02: React Virtual DOM: What & Why

### Table of Contents:

1. [What is the Virtual DOM?](#what-is-the-virtual-dom)
2. [Why Virtual DOM is Needed?](#why-virtual-dom-is-needed)
   - [Performance Optimization](#performance-optimization)
   - [Efficient Reconciliation](#efficient-reconciliation)
   - [Improved User Experience](#improved-user-experience)
3. [How Virtual DOM Works?](#how-virtual-dom-works)
   - [React Lifecycle and Virtual DOM](#react-lifecycle-and-virtual-dom)
   - [Steps in Virtual DOM Update](#steps-in-virtual-dom-update)
4. [Real-life Example of Virtual DOM](#real-life-example-of-virtual-dom)
5. [Detailed Example Comparison (React vs Traditional DOM)](#detailed-example-comparison)
6. [Conclusion](#conclusion)

---

### 1. What is the Virtual DOM?

Virtual DOM (**Virtual Document Object Model**) হলো একটি **in-memory representation** যা React ব্যবহার করে UI updates এর performance অনেক দ্রুততর এবং efficient করতে। React এর মূল লক্ষ্য হলো performance optimize করা এবং unnecessary DOM manipulations কমিয়ে আনা। Virtual DOM আসলে একটি lightweight JavaScript object যা real DOM এর একটি virtual কপি তৈরি করে।

যখন React component এর state বা props এ পরিবর্তন হয়, React এই পরিবর্তনগুলো প্রথমে **Virtual DOM** এ reflect করে। এরপর React এর diffing algorithm ব্যবহার করে, শুধু পরিবর্তিত অংশগুলোকেই real DOM এর সাথে synchronize করে।

#### Traditional DOM Manipulation:

Traditional DOM API ব্যবহার করলে প্রতিবার পরিবর্তন আসলে real DOM এ সরাসরি কাজ করতে হয়। প্রতিবার যখন কোন element পরিবর্তিত হয়, browser পুরো UI রি-রেন্ডার করে। এটা অনেক সময় DOM খুব বড় হলে performance issue তৈরি করতে পারে।

#### Virtual DOM Concept:

Virtual DOM এর মাধ্যমে, শুধু পরিবর্তিত অংশ গুলোই real DOM এ আপডেট করা হয়, যাতে browser পুরো DOM structure রি-রেন্ডার করতে না হয়।

---

### 2. Why Virtual DOM is Needed?

#### Performance Optimization:

Traditional DOM manipulation computationally expensive, বিশেষ করে যদি DOM অনেক বড় হয়। প্রতিবার DOM এ পরিবর্তন হলে, browser পুরো structure কে repaint এবং reflow করে। কিন্তু React এর **Virtual DOM** system এই সমস্যার সমাধান করে।

##### Example Without Virtual DOM (Traditional DOM Manipulation):

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Traditional DOM Example</title>
    <script>
      function updateText() {
        document.getElementById("text").innerHTML = "Text Updated!";
      }
    </script>
  </head>
  <body>
    <p id="text">This is some text</p>
    <button onclick="updateText()">Update Text</button>
  </body>
</html>
```

##### Problem:

উপরের উদাহরণে যখন user "Update Text" button এ click করে, পুরো DOM structure re-render হয়। যদি বড় application হয় যেখানে DOM অনেক elements থাকে, তাহলে performance issue হতে পারে।

#### Efficient Reconciliation:

React এর diffing algorithm **virtual DOM** এবং **real DOM** এর মধ্যে differences track করে এবং শুধু changed parts update করে। এই process কে **reconciliation** বলা হয়। এটি unnecessary DOM re-renders এড়িয়ে performance উন্নত করে।

#### Improved User Experience:

React এর **Virtual DOM** ব্যবহার করার আরেকটি বড় সুবিধা হলো **smooth user experience**। Frequent UI updates এবং smooth transitions নিশ্চিত করার জন্য Virtual DOM অনেক গুরুত্বপূর্ণ ভূমিকা পালন করে। Traditional approach এ page refresh হতে অনেক সময় লাগতে পারে, যা user experience ধীর করে দেয়। কিন্তু Virtual DOM ব্যবহার করলে এই সমস্যা অনেকাংশে কমে যায়।

---

### 3. How Virtual DOM Works?

Virtual DOM মূলত real DOM এর একটি lightweight copy, এবং এই পুরো process তিনটি পর্যায়ে কাজ করে:

1. **Render Phase**:
   যখনই React component এ কোনো state change বা props change হয়, React প্রথমে এই পরিবর্তনগুলো virtual DOM এ reflect করে। এই render phase এ real DOM পরিবর্তিত হয় না, বরং memory তে একটি ভার্চুয়াল কপি তৈরি হয়।

2. **Diffing Algorithm**:
   এই algorithm এর কাজ হলো virtual DOM এবং real DOM এর মধ্যে differences খুঁজে বের করা। React কেবলমাত্র changed parts track করে এবং এই parts গুলোকে optimize করে real DOM এর সাথে sync করে।

3. **Update Real DOM**:
   পরিবর্তনের পরে React minimal updates real DOM এ apply করে এবং unnecessary re-rendering এড়ায়। এটি real DOM কে দ্রুত পরিবর্তন করার জন্য খুবই কার্যকর।

#### Example with React Virtual DOM:

```jsx
import React, { useState } from "react";

function TextUpdate() {
  const [text, setText] = useState("This is some text");

  const updateText = () => {
    setText("Text Updated!");
  };

  return (
    <div>
      <p>{text}</p>
      <button onClick={updateText}>Update Text</button>
    </div>
  );
}

export default TextUpdate;
```

এখানে, button click করলে React প্রথমে Virtual DOM এ **text** update করে, তারপর diffing algorithm এর মাধ্যমে changes track করে এবং real DOM এ শুধুমাত্র updated text রেন্ডার করে।

#### Steps in Virtual DOM Update:

1. **React component renders** – State বা props পরিবর্তন হলে React Virtual DOM প্রথমে UI কে re-render করে।
2. **React calculates the diff** – Virtual DOM এবং real DOM এর মধ্যে differences খুঁজে বের করা হয়।
3. **React updates only the necessary DOM nodes** – পরিবর্তিত অংশ গুলো real DOM এ reflect হয়, এবং শুধুমাত্র প্রয়োজনীয় DOM elements update করা হয়।

---

### 4. Real-life Example of Virtual DOM:

ধরা যাক, আপনি একটি **To-Do List** application তৈরি করছেন, যেখানে user dynamically নতুন items যোগ করতে পারে। যদি traditional DOM manipulation ব্যবহার করা হয়, প্রতিবার নতুন item যোগ করলে পুরো DOM re-render হতে পারে, যা performance কমিয়ে দেয়। কিন্তু Virtual DOM ব্যবহার করলে শুধু নতুন item টুকু dynamically update হয়।

#### React Example (Real-life Scenario):

```jsx
import React, { useState } from "react";

function TodoList() {
  const [items, setItems] = useState(["Item 1", "Item 2"]);

  const addItem = () => {
    setItems([...items, `Item ${items.length + 1}`]);
  };

  return (
    <div>
      <ul>
        {items.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
      <button onClick={addItem}>Add Item</button>
    </div>
  );
}

export default TodoList;
```

#### Explanation:

উপরের উদাহরণে, যখন user **Add Item** button এ click করবে, শুধু নতুন **item** টুকু Virtual DOM এ update হবে। পরে React সেই change detect করে real DOM এর সাথে synchronize করে।

---

### 5. Detailed Example Comparison (React vs Traditional DOM)

##### Traditional DOM Approach:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Traditional DOM Example</title>
    <script>
      function addItem() {
        var list = document.getElementById("list");
        var newItem = document.createElement("li");
        newItem.textContent = "New Item";
        list.appendChild(newItem);
      }
    </script>
  </head>
  <body>
    <ul id="list">
      <li>Item 1</li>
      <li>Item 2</li>
    </ul>
    <button onclick="addItem()">Add Item</button>
  </body>
</html>
```

##### React with Virtual DOM Approach:

```jsx
import React, { useState } from "react";

function ItemList() {
  const [items, setItems] = useState(["Item 1", "Item 2"]);

  const addItem = () => {
    setItems([...items, `Item ${items.length + 1}`]);
  };

  return (
    <div>
      <ul>
        {items.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
      <button onClick={addItem}>Add Item</button>
    </div>
  );
}

export default ItemList;
```

##### Key Differences:

1. **Traditional DOM**: Button click করলে পুরো DOM re-render হতে পারে, যা performance কমিয়ে দেয়।
2. **React with Virtual DOM**: শুধু পরিবর্তিত **item** টুকু update হয় এবং real DOM এর সাথে efficiently sync করা হয়।

---

### 6. Conclusion:

React এর **Virtual DOM** modern web development এর একটি শক্তিশালী tool যা UI rendering অনেক দ্রুত এবং efficient করে তোলে। এটি unnecessary DOM manipulations এড়িয়ে শুধুমাত্র changed parts real DOM এ apply করে। এইভাবে, large-scale applications এর performance অনেক উন্নত হয় এবং user experience আরো smooth হয়।

Traditional DOM manipulation এর তুলনায় React এর **Virtual DOM** application development সহজ, faster, এবং scalable করে তোলে। Performance এবং maintainability এর দিক থেকে **Virtual DOM** একটি game changer হিসেবে কাজ করে।

React এর popularity এর পিছনে অন্যতম কারণ হলো এই **Virtual DOM**, যা অনেক বড় এবং dynamic UI গুলিকে দ্রুত update করতে সাহায্য করে।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-03: How to Install React (Step-by-Step Guide with Example Project)

### Table of Contents:

1. [Prerequisites](#prerequisites)
2. [Installing Node.js and npm](#installing-nodejs-and-npm)
3. [Creating a New React Project](#creating-a-new-react-project)
   - [Using Create React App (CRA)](#using-create-react-app)
   - [Folder Structure Overview with Real-life Example](#folder-structure-overview-with-real-life-example)
4. [package.json Explained](#packagejson-explained)
5. [Example Project: Simple To-Do List](#example-project-simple-to-do-list)
   - [Step 1: Setting Up the Project](#step-1-setting-up-the-project)
   - [Step 2: Creating the To-Do List Component](#step-2-creating-the-to-do-list-component)
   - [Step 3: Adding Interactivity](#step-3-adding-interactivity)
   - [Step 4: Running and Testing](#step-4-running-and-testing)
6. [Running the React Project](#running-the-react-project)
7. [Conclusion](#conclusion)

---

### 1. Prerequisites

React ইনস্টল করার আগে, আপনার সিস্টেমে **Node.js** এবং **npm** থাকতে হবে। এগুলো React এবং অন্যান্য JavaScript libraries পরিচালনার জন্য প্রয়োজনীয়। যদি Node.js এবং npm ইন্সটল করা না থাকে, তাহলে [Node.js অফিসিয়াল ওয়েবসাইট](https://nodejs.org/en/) থেকে ডাউনলোড করে ইনস্টল করুন।

---

### 2. Installing Node.js and npm

#### Step 1: Download Node.js

- [Node.js এর অফিসিয়াল ওয়েবসাইট](https://nodejs.org/en/) থেকে **LTS (Long-Term Support)** version ডাউনলোড করুন।
- ইনস্টল করার পর, Terminal বা Command Prompt খুলে নিচের কমান্ডগুলো দিয়ে যাচাই করুন:

```bash
node -v
npm -v
```

---

### 3. Creating a New React Project

React এর নতুন প্রজেক্ট তৈরি করতে **Create React App (CRA)** খুবই উপযোগী। এটি খুব সহজে একটি React প্রজেক্ট সেটআপ করতে সাহায্য করে।

#### Using Create React App (CRA)

**Step 1: Create React App ব্যবহার করে প্রজেক্ট তৈরি করা**

Terminal/Command Prompt এ নিচের কমান্ড লিখুন:

```bash
npx create-react-app my-app
```

এখানে **my-app** হলো আপনার প্রজেক্টের নাম। এটি ইনস্টল করে সমস্ত প্রয়োজনীয় dependencies যুক্ত করে।

**Step 2: Project ফোল্ডারে প্রবেশ করা**

```bash
cd my-app
```

---

### Folder Structure Overview with Real-life Example

React প্রজেক্ট তৈরি হলে নিচের মতো ফোল্ডার স্ট্রাকচার পাবেন:

#### Example of Folder Structure:

```
my-app/
├── node_modules/
├── public/
│   ├── index.html
│   └── favicon.ico
├── src/
│   ├── App.js
│   ├── App.css
│   ├── index.js
│   └── index.css
├── package.json
└── README.md
```

#### Folder Breakdown:

1. **node_modules/**: এখানে সমস্ত dependencies থাকে।
2. **public/**: public ফোল্ডারে **index.html** থাকে, যা ব্রাউজারে React app প্রদর্শন করে।
3. **src/**: এই ফোল্ডারে React এর মূল কোড থাকে (App.js, index.js, ইত্যাদি)।
4. **package.json**: প্রজেক্টের dependencies এবং scripts এখানে থাকে।

---

### 4. package.json Explained

**package.json** ফাইলটি আপনার প্রজেক্টের জন্য অত্যন্ত গুরুত্বপূর্ণ, যেখানে সমস্ত configuration এবং dependencies তালিকাভুক্ত থাকে।

#### Key Sections in package.json:

```json
{
  "name": "my-app",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "react-scripts": "5.0.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  }
}
```

- **dependencies**: আপনার প্রজেক্টে ইনস্টল হওয়া libraries।
- **scripts**: প্রজেক্ট চালানোর জন্য প্রয়োজনীয় স্ক্রিপ্ট, যেমন:
  - **npm start**: development server চালু করে।
  - **npm run build**: production build তৈরি করে।
  - **npm test**: testing চালায়।

---

### 5. Example Project: Simple To-Do List

এই অংশে আমরা একটি বাস্তব উদাহরণ দেব—**Simple To-Do List**। এটি খুবই সহজ, কিন্তু React এর ভিত্তিগত ধারণা বোঝার জন্য খুব কার্যকর।

#### Step 1: Setting Up the Project

Terminal এ নিচের কমান্ডগুলো দিয়ে প্রজেক্ট তৈরি করুন এবং **my-app** ফোল্ডারে প্রবেশ করুন:

```bash
npx create-react-app todo-app
cd todo-app
```

---

#### Step 2: Creating the To-Do List Component

**src/App.js** ফাইল খুলুন এবং নিচের কোডটি লিখুন:

```jsx
import React, { useState } from "react";

function App() {
  const [tasks, setTasks] = useState([]);
  const [newTask, setNewTask] = useState("");

  const handleAddTask = () => {
    setTasks([...tasks, newTask]);
    setNewTask("");
  };

  return (
    <div>
      <h1>To-Do List</h1>
      <input
        type="text"
        value={newTask}
        onChange={(e) => setNewTask(e.target.value)}
        placeholder="Add a new task"
      />
      <button onClick={handleAddTask}>Add Task</button>
      <ul>
        {tasks.map((task, index) => (
          <li key={index}>{task}</li>
        ))}
      </ul>
    </div>
  );
}

export default App;
```

#### Explanation:

1. **useState Hook**: আমরা **useState** ব্যবহার করছি task list এবং নতুন task handle করার জন্য।
2. **handleAddTask**: এটি নতুন task list এ যুক্ত করে এবং input field টি reset করে।
3. **map Function**: আমরা **map** function ব্যবহার করছি **tasks** array render করতে।

---

#### Step 3: Adding Interactivity

এখানে নতুন **task** input এ টাইপ করলে **Add Task** বাটন চাপলে task list এ নতুন item যুক্ত হয়।

#### Step 4: Running and Testing

**npm start** কমান্ড দিয়ে প্রজেক্ট চালান:

```bash
npm start
```

ব্রাউজারে **http://localhost:3000** এ গিয়ে আপনার To-Do List অ্যাপটি পরীক্ষা করুন।

---

### 6. Running the React Project

React প্রজেক্ট চালানোর জন্য **npm start** কমান্ড ব্যবহার করুন। এটি local development server চালু করবে এবং আপনি প্রজেক্টটি **http://localhost:3000** এ দেখতে পাবেন।

---

### 7. Conclusion

React এর মাধ্যমে একটি সহজ প্রজেক্ট তৈরি করা অত্যন্ত সহজ এবং দ্রুত। উপরের উদাহরণে আমরা **Simple To-Do List** প্রজেক্ট দেখিয়েছি, যেখানে আপনি একটি নতুন task যুক্ত করতে পারবেন এবং task list দেখতে পারবেন।

React environment setup করার পর, আপনি খুব সহজেই এমন আরও প্রজেক্ট তৈরি করতে পারবেন এবং React এর অন্যান্য feature ব্যবহার করতে পারবেন, যেমন state management এবং component rendering।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-03.1: React Install with Vite

### Table of Contents:

1. [Introduction to Vite](#introduction-to-vite)
2. [Why Use Vite for React?](#why-use-vite-for-react)
3. [Installing React with Vite](#installing-react-with-vite)
   - [Step 1: Installing Vite](#step-1-installing-vite)
   - [Step 2: Setting Up the React Project](#step-2-setting-up-the-react-project)
   - [Step 3: Running the Development Server](#step-3-running-the-development-server)
4. [Folder Structure Overview](#folder-structure-overview)
5. [Real-life Example Project](#real-life-example-project)
6. [Conclusion](#conclusion)

---

### 1. Introduction to Vite

**Vite** হলো একটি modern frontend build tool, যা দ্রুত development server এবং build process প্রদান করে। এটি মূলত **ESM (ECMAScript Modules)** এবং **Hot Module Replacement (HMR)** ব্যবহার করে দ্রুত development environment setup করতে সাহায্য করে। Vite বিশেষভাবে দ্রুত startup time এবং minimal configuration এর জন্য পরিচিত, যা React এর মতো frameworks এর সাথে ভালোভাবে কাজ করে।

---

### 2. Why Use Vite for React?

Vite React এর development environment setup করার জন্য দ্রুত এবং efficient একটি উপায়। এর কিছু প্রধান সুবিধা হলো:

- **Fast Startup**: Traditional bundlers যেমন Webpack এর তুলনায় Vite অনেক দ্রুত startup time প্রদান করে।
- **Hot Module Replacement (HMR)**: Vite এর মাধ্যমে দ্রুত code changes UI তে reflect হয়, যা development process কে আরও efficient করে তোলে।
- **Minimal Configuration**: Vite এর default configuration অনেক সহজ, এবং React এর জন্য এটি automatically সেটআপ করে।
- **Optimized Build**: Vite production build এর জন্য automatically optimized output তৈরি করে।

---

### 3. Installing React with Vite

Vite দিয়ে React setup করতে কয়েকটি ধাপে কাজ করতে হয়। নিচে step-by-step নির্দেশনা দেয়া হলো:

#### Step 1: Installing Vite

প্রথমে, **npm** বা **yarn** ব্যবহার করে Vite ইনস্টল করতে হবে। Terminal বা Command Prompt এ নিচের command লিখুন:

```bash
npm create vite@latest my-react-app
```

অথবা

```bash
yarn create vite my-react-app
```

**my-react-app** এর জায়গায় আপনার পছন্দমতো project এর নাম দিতে পারেন।

#### Step 2: Setting Up the React Project

Vite ইনস্টল করার পরে, Vite আপনাকে কিছু options দিবে। আপনি **React** এবং **JavaScript** (বা TypeScript) select করতে পারেন।

```bash
cd my-react-app
npm install
```

এখন, **cd my-react-app** command এর মাধ্যমে project এর ভেতরে যান এবং **npm install** command দিয়ে dependencies install করুন।

#### Step 3: Running the Development Server

Development server চালু করতে নিচের command লিখুন:

```bash
npm run dev
```

এটি আপনার local server চালু করবে এবং browser এ application preview করবে। Vite এর HMR feature এর কারণে, code এ কোনো পরিবর্তন হলে সাথে সাথে UI তে reflect হবে।

Output:

```
VITE vX.X.X  ready in 300 ms

  ➜  Local:   http://localhost:3000/
  ➜  Network: use --host to expose
```

এই URL এ গিয়ে আপনি আপনার React application দেখতে পাবেন।

---

### 4. Folder Structure Overview

Vite দিয়ে React setup করার পরে একটি সহজ এবং পরিচ্ছন্ন folder structure তৈরি হয়:

```
my-react-app
├── node_modules
├── public
├── src
│   ├── App.jsx
│   ├── main.jsx
│   └── index.css
├── .gitignore
├── index.html
├── package.json
├── vite.config.js
```

- **src**: সমস্ত application এর মূল কোড এখানে থাকে। **App.jsx** এবং **main.jsx** হলো মূল React components এবং entry point।
- **public**: Static files এর জন্য ব্যবহৃত হয়।
- **index.html**: Vite এর জন্য প্রধান HTML ফাইল।
- **vite.config.js**: Vite এর configuration ফাইল।

---

## Explanation of main.jsx File

### Table of Contents

1. **Code Overview**
2. **What is StrictMode?**
3. **How does createRoot Work?**
4. **Rendering Process with ReactDOM**
5. **Discussion on File Imports**

---

### 1. Code Overview

এই কোডটি একটি React Application এর Entry Point হিসেবে কাজ করে, যা মূলত ব্রাউজারে Render করা হয়। এখানে `React` এবং `ReactDOM` লাইব্রেরির কিছু ফাংশন ব্যবহার করা হয়েছে আমাদের Application-কে ব্রাউজারে দেখানোর জন্য।

### 2. What is StrictMode?

`StrictMode` হল React এর একটি Component যা আমাদের কোডের কিছু সাধারণ সমস্যা যেমন Deprecated API ব্যবহার করা বা কোনো অনাকাঙ্ক্ষিত Side-Effect ধরতে সাহায্য করে। এটি শুধুমাত্র Development Mode-এ কাজ করে, Production Mode-এ কোনো প্রভাব ফেলে না। নিচে আমরা `StrictMode` ব্যবহার করেছি Application-কে Render করার সময় যাতে Development Console-এ কোনো সমস্যা থাকলে সেটি দেখায়:

```jsx
<StrictMode>
  <App />
</StrictMode>
```

### 3. How does createRoot Work?

`createRoot` হল `React 18` এর একটি নতুন API, যা React Application-কে Render করার জন্য ব্যবহৃত হয়। এটি ReactDOM এর নতুন Method হিসেবে এসেছে, যা পুরোনো `ReactDOM.render` এর পরিবর্তে ব্যবহৃত হচ্ছে।

```javascript
createRoot(document.getElementById("root")).render(
  <StrictMode>
    <App />
  </StrictMode>
);
```

- `createRoot` প্রথমে HTML ডকুমেন্টে সেই Element খুঁজে বের করে যার `id` `'root'`।
- তারপর এটি `render` Method এর মাধ্যমে `<App />` Component-টি `StrictMode` এর মধ্যে Render করে। এতে করে, পুরো Application টি ঐ `root` Div-এর মধ্যে Render হয়।

### 4. Rendering Process with ReactDOM

আগে আমরা `ReactDOM.render` ব্যবহার করতাম, কিন্তু `React 18` থেকে, আমরা `ReactDOM.createRoot` এবং `.render()` Method ব্যবহার করি। এটি Rendering Performance উন্নত করে এবং নতুন কিছু Feature যেমন Concurrent Mode কে সমর্থন করে।

### 5. Discussion on File Imports

```javascript
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./index.css";
import App from "./App.jsx";
```

- **`StrictMode`**: এটি `react` লাইব্রেরি থেকে Import করা হয়।
- **`createRoot`**: এটি `react-dom/client` থেকে Import করা হয়।
- **`'./index.css'`**: Stylesheet Import করা হয়েছে, যা Application এর Style নির্ধারণ করে।
- **`App`**: `'./App.jsx'` থেকে আমাদের মূল Application Component Import করা হয়েছে, যা আমাদের Application এর প্রধান অংশ।

এইভাবে, কোডটি আমাদের React Application-কে সফলভাবে ব্রাউজারে Render করার জন্য প্রয়োজনীয় সবকিছু প্রস্তুত করে।

### 5. Real-life Example Project

ধরা যাক, আমরা একটি simple React component তৈরি করবো যেখানে "Hello, Vite!" প্রদর্শিত হবে।

#### Example Code:

**App.jsx**

```jsx
function App() {
  return (
    <div className="App">
      <h1>Hello, Vite!</h1>
    </div>
  );
}

export default App;
```

**main.jsx**

```jsx
import React from "react";
import ReactDOM from "react-dom";
import App from "./App";
import "./index.css";

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

এই কোড Vite environment এ দ্রুত render হবে এবং আপনি browser এ "Hello, Vite!" দেখতে পাবেন।

---

### 6. Conclusion

Vite দিয়ে React setup করা খুবই সহজ এবং efficient। এটি traditional bundlers এর তুলনায় দ্রুত এবং minimal configuration দিয়ে কাজ করে, যা modern React development এর জন্য আদর্শ। Vite এর মাধ্যমে আপনি খুব সহজেই একটি React application তৈরি করতে পারেন এবং দ্রুত development environment পেতে পারেন।

Vite এর speed এবং flexibility React এর modern development environment এর জন্য একটি বড় সুবিধা।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-04: React Render HTML

### Table of Contents:

1. [What Does Rendering HTML Mean in React?](#what-does-rendering-html-mean-in-react)
2. [How React Renders HTML](#how-react-renders-html)
   - [JSX Syntax](#jsx-syntax)
   - [ReactDOM.render()](#reactdomrender)
3. [Rendering Dynamic Content](#rendering-dynamic-content)
4. [Real-life Example of Rendering HTML](#real-life-example-of-rendering-html)
5. [React Virtual DOM and Rendering Efficiency](#react-virtual-dom-and-rendering-efficiency)
6. [Conclusion](#conclusion)

---

### 1. What Does Rendering HTML Mean in React?

**Rendering HTML** মানে হলো HTML elements বা components-কে web browser এ প্রদর্শন করা। সাধারণত traditional JavaScript দিয়ে DOM (Document Object Model) এর সাথে কাজ করা হয়, যেখানে `document.createElement()` বা `innerHTML` ব্যবহার করে HTML dynamically generate করা হয়। কিন্তু **React** এ, rendering process আরও streamlined এবং efficient, কারণ React এর মাধ্যমে আপনি HTML code **JSX (JavaScript XML)** syntax ব্যবহার করে লিখতে পারেন এবং virtual DOM এর মাধ্যমে efficiently render করতে পারেন।

React এর মূল কাজ হলো user interface তৈরি করা এবং সেই UI কে browser এর real DOM এ reflect করা। React এই কাজটি করে **ReactDOM** এর মাধ্যমে যা web page এ HTML render করে।

---

### 2. How React Renders HTML

#### JSX Syntax

**JSX (JavaScript XML)** হলো React এর special syntax যা HTML এর মতো দেখতে, কিন্তু এটি JavaScript এর মধ্যে embedded থাকে। JSX ব্যবহার করলে HTML elements এবং JavaScript একসাথে manage করা সহজ হয়। JSX এর মাধ্যমে আপনি HTML এর মতো structure লিখতে পারেন, যেটা পরে React component এ পরিবর্তিত হয়ে rendering হয়।

##### Example of JSX:

```jsx
const element = <h1>Hello, world!</h1>;
```

এটি দেখলে HTML এর মতো মনে হলেও এটি আসলে **JSX**। React এই JSX কে JavaScript এ convert করে এবং DOM এ render করে।

#### ReactDOM.render()

**ReactDOM.render()** method ব্যবহার করে React component বা JSX কে real DOM এ রেন্ডার করা হয়।

##### Syntax:

```jsx
ReactDOM.render(element, document.getElementById("root"));
```

এই example এ, **element** হলো যে HTML বা React component টি render করা হবে, এবং **'root'** হলো HTML এর id, যেখানে এই content inject হবে।

##### Example:

```jsx
import React from "react";
import ReactDOM from "react-dom";

const element = <h1>Hello, React!</h1>;

ReactDOM.render(element, document.getElementById("root"));
```

উপরের কোডটি **index.html** এর একটি **div** element এর মধ্যে render হবে যেটির id হবে "root":

```html
<div id="root"></div>
```

---

### 3. Rendering Dynamic Content

React এ শুধু static HTML নয়, বরং dynamic content render করা যায়। উদাহরণস্বরূপ, user input অনুযায়ী data dynamically update এবং render করা যায়।

##### Example of Rendering Dynamic Content:

```jsx
import React, { useState } from "react";
import ReactDOM from "react-dom";

function App() {
  const [name, setName] = useState("React");

  return (
    <div>
      <h1>Hello, {name}!</h1>
      <input
        type="text"
        value={name}
        onChange={(e) => setName(e.target.value)}
      />
    </div>
  );
}

ReactDOM.render(<App />, document.getElementById("root"));
```

#### Explanation:

1. **useState Hook**: আমরা **useState** hook ব্যবহার করে **name** নামক একটি state তৈরি করেছি।
2. **Dynamic Rendering**: যখন user input field এ কিছু লিখবে, সেই **name** value dynamically update হয়ে rendering হবে।

---

### 4. Real-life Example of Rendering HTML

ধরা যাক, আপনি একটি e-commerce website তৈরি করছেন যেখানে প্রতিবার নতুন product যোগ করলে সেই product টি dynamically render করতে হবে। React এর মাধ্যমে সহজেই এই কাজ করা যায়।

#### Example:

```jsx
import React, { useState } from "react";
import ReactDOM from "react-dom";

function ProductList() {
  const [products, setProducts] = useState(["Product 1", "Product 2"]);

  const addProduct = () => {
    setProducts([...products, `Product ${products.length + 1}`]);
  };

  return (
    <div>
      <h1>Product List</h1>
      <ul>
        {products.map((product, index) => (
          <li key={index}>{product}</li>
        ))}
      </ul>
      <button onClick={addProduct}>Add Product</button>
    </div>
  );
}

ReactDOM.render(<ProductList />, document.getElementById("root"));
```

#### Explanation:

1. **useState**: এখানে **products** নামক একটি state আছে যেটা একটি array ধরে। যখন নতুন product যোগ করা হয়, সেটা **addProduct** function এর মাধ্যমে **products** এ যুক্ত হয়।
2. **Dynamic Rendering**: প্রতিবার নতুন product যোগ করার পরে, **ProductList** component টিকে re-render করা হয় এবং updated product list দেখতে পাওয়া যায়।

---

### 5. React Virtual DOM and Rendering Efficiency

React এর HTML rendering এত efficient হওয়ার পেছনে বড় কারণ হলো এর **Virtual DOM**। যখন আপনি React component এ কোনো পরিবর্তন করেন, React পুরো DOM কে re-render করে না। এটি প্রথমে Virtual DOM এ changes apply করে এবং তারপর minimal changes real DOM এ implement করে। এর মাধ্যমে unnecessary re-rendering এড়ানো যায়, এবং UI দ্রুত আপডেট হয়।

---

### 6. Conclusion

React এর মাধ্যমে HTML rendering process অনেক সহজ এবং efficient হয়ে যায়, বিশেষ করে **JSX** এবং **ReactDOM** এর কারণে। আপনি শুধুমাত্র static content নয়, dynamic content ও খুব সহজে render করতে পারেন, এবং React এর **Virtual DOM** এর মাধ্যমে UI খুব দ্রুত এবং smooth ভাবে update হয়।

এইভাবে, React modern web applications এর জন্য একটি essential tool হয়ে উঠেছে, যা UI rendering কে সহজ করে এবং performance উন্নত করে।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-05: React JSX

### Table of Contents:

1. [What is JSX?](#what-is-jsx)
2. [Why JSX is Important](#why-jsx-is-important)
3. [JSX Syntax](#jsx-syntax)
   - [Embedding Expressions in JSX](#embedding-expressions-in-jsx)
   - [JSX Elements and Components](#jsx-elements-and-components)
4. [JSX vs HTML](#jsx-vs-html)
5. [Real-life Example of JSX](#real-life-example-of-jsx)
6. [Common JSX Mistakes and Best Practices](#common-jsx-mistakes-and-best-practices)
7. [Conclusion](#conclusion)

---

### 1. What is JSX?

**JSX (JavaScript XML)** হলো React এর একটি syntax extension, যা JavaScript এর ভেতরে HTML এর মতো structure লিখতে দেয়। যদিও JSX দেখতে HTML এর মতো, এটি আসলে একটি **JavaScript** এর বিশেষ syntax যা **React** এর মধ্যে ব্যবহার করা হয়। React এর সাথে কাজ করতে গেলে JSX শেখা অত্যন্ত গুরুত্বপূর্ণ, কারণ React এর মাধ্যমে UI তৈরি করার জন্য JSX অন্যতম প্রধান উপাদান।

##### Example of JSX:

```jsx
const element = <h1>Hello, World!</h1>;
```

উপরের কোডটিতে **<h1>Hello, World!</h1>** হলো JSX এর একটি উদাহরণ, যা পরবর্তীতে JavaScript কোডে পরিবর্তিত হয়ে DOM এ render হয়।

---

### 2. Why JSX is Important

JSX React এর একটি প্রধান অংশ, কারণ এটি HTML এর মতো syntax ব্যবহার করে **JavaScript** এর ভেতরে **UI components** তৈরির কাজকে সহজ করে। এর কিছু প্রধান সুবিধা হলো:

1. **Readable and Declarative**: JSX HTML এর মতো দেখতে হওয়ায় কোডটি অনেক বেশি readable এবং declarative হয়, যা development experience সহজ করে।
2. **Integration with JavaScript**: JSX এর মাধ্যমে সহজেই JavaScript expressions এবং logic UI এর সাথে integrate করা যায়।
3. **Faster Rendering**: React এর **Virtual DOM** এর সাথে মিলিত হয়ে JSX দ্রুত HTML render করে এবং performance বৃদ্ধি করে।

---

### 3. JSX Syntax

JSX এর syntax দেখতে HTML এর মতো, কিন্তু এর কিছু বিশেষ নিয়ম এবং functionality রয়েছে যা HTML এর চেয়ে আলাদা।

#### Embedding Expressions in JSX

JSX এর সবচেয়ে শক্তিশালী বৈশিষ্ট্য হলো এর মধ্যে **JavaScript expressions** embed করা যায়। JavaScript এর কোনো value JSX এ curly braces `{}` এর মধ্যে রেখে render করা যায়।

##### Example of Embedding JavaScript in JSX:

```jsx
const name = "React";
const element = <h1>Hello, {name}!</h1>;
```

এই উদাহরণে, **name** নামক JavaScript variable টি JSX এর মধ্যে রাখা হয়েছে। এর ফলে DOM এ **"Hello, React!"** render হবে।

#### JSX Elements and Components

JSX এর মাধ্যমে শুধুমাত্র HTML elements তৈরি করা যায় না, বরং React components কে JSX এর মধ্যে ব্যবহার করা যায়।

##### Example of JSX with Components:

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}!</h1>;
}

const element = <Welcome name="React" />;
```

এখানে **Welcome** হলো একটি React component যা JSX এর মাধ্যমে render হয়েছে। Component এর **props** ব্যবহার করে dynamic data render করা হচ্ছে।

---

### 4. JSX vs HTML

যদিও JSX HTML এর মতো দেখতে, এদের মধ্যে কিছু পার্থক্য রয়েছে। কিছু গুরুত্বপূর্ণ পার্থক্য নিচে উল্লেখ করা হলো:

1. **class vs className**: HTML এ **class** attribute ব্যবহার করা হয়, কিন্তু JSX এ **className** ব্যবহার করতে হয়, কারণ **class** হলো JavaScript এর reserved keyword।

   ```jsx
   <div className="container"></div>
   ```

2. **Self-closing Tags**: JSX এ প্রতিটি tag self-close করা প্রয়োজন, যদি তার কোনো closing tag না থাকে।

   ```jsx
   <img src="image.jpg" alt="Sample" />
   ```

3. **JSX attributes in camelCase**: HTML attributes, যেমন **onclick** বা **onchange** JSX এ camelCase এ লিখতে হয়।

   ```jsx
   <button onClick={handleClick}>Click Me</button>
   ```

---

### 5. Real-life Example of JSX

ধরা যাক, আপনি একটি **User Profile** component তৈরি করতে চান, যেখানে user's name, email, এবং profile picture থাকবে। React এর মাধ্যমে এটি সহজেই করা যায়।

#### Example:

```jsx
function UserProfile(props) {
  return (
    <div className="profile-card">
      <img src={props.avatar} alt="User Avatar" />
      <h2>{props.name}</h2>
      <p>Email: {props.email}</p>
    </div>
  );
}

const element = (
  <UserProfile
    avatar="https://example.com/avatar.jpg"
    name="John Doe"
    email="john.doe@example.com"
  />
);

ReactDOM.render(element, document.getElementById("root"));
```

#### Explanation:

1. **UserProfile Component**: এখানে **UserProfile** নামে একটি React component তৈরি করা হয়েছে, যা props হিসেবে user এর **name**, **email**, এবং **avatar** image গ্রহণ করে।
2. **Props Usage**: **props.name**, **props.email** ইত্যাদি JSX এর মধ্যে render হচ্ছে, যার ফলে component dynamic ভাবে ব্যবহার করা যায়।
3. **Rendering**: ReactDOM.render() method এর মাধ্যমে component কে DOM এ render করা হয়েছে।

---

### 6. Common JSX Mistakes and Best Practices

#### Mistake 1: Forgetting to Close Tags

JSX এ প্রতিটি element self-closing হওয়া উচিত যদি তার কোনো child না থাকে। উদাহরণস্বরূপ:

```jsx
// Incorrect
<input>

// Correct
<input />
```

#### Mistake 2: Returning Multiple Elements Without Wrapping

JSX এ multiple elements return করতে গেলে এগুলোকে একটি parent element এর মধ্যে রাখতে হয়। উদাহরণস্বরূপ:

```jsx
// Incorrect
return (
  <h1>Hello</h1>
  <p>World</p>
);

// Correct
return (
  <div>
    <h1>Hello</h1>
    <p>World</p>
  </div>
);
```

---

### 7. Conclusion

**JSX** হলো React এর প্রধান syntax যা JavaScript এর মধ্যে HTML elements এবং components তৈরি করতে সাহায্য করে। এটি declarative এবং readable syntax এর কারণে UI development সহজ করে। JSX এর মাধ্যমে আপনি শুধু static content নয়, dynamic JavaScript expressions এবং React components ব্যবহার করতে পারবেন।

JSX এর সঠিক ব্যবহার React এর core concepts বুঝতে সাহায্য করে এবং complex UI গুলোকে সহজে maintainable করে তোলে।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-06: React Components

### Table of Contents:

1. [What are React Components?](#what-are-react-components)
2. [Types of React Components](#types-of-react-components)
   - [Function Components](#function-components)
   - [Class Components](#class-components)
3. [Props in React Components](#props-in-react-components)
4. [State in React Components](#state-in-react-components)
5. [Lifecycle Methods in Class Components](#lifecycle-methods-in-class-components)
6. [Real-life Example of React Components](#real-life-example-of-react-components)
7. [Conclusion](#conclusion)

---

### 1. What are React Components?

**React components** হলো React এর মূল building blocks, যা UI কে ছোট ছোট অংশে ভাগ করে পুনরায় ব্যবহারযোগ্য করে তোলে। প্রতিটি React component একটি JavaScript function বা class যা **HTML-like** structure (JSX) return করে এবং UI এর বিভিন্ন অংশে প্রদর্শিত হয়। Components independent হওয়ার কারণে, একটি component তার নিজস্ব state এবং props ব্যবহার করে নির্দিষ্ট অংশের কাজ সম্পন্ন করে।

##### Example of a Simple React Component:

```jsx
function Welcome() {
  return <h1>Hello, React!</h1>;
}
```

এখানে, **Welcome** হলো একটি React function component যা **Hello, React!** text কে render করে। React components ব্যবহার করে আপনি complex UI গুলোকে ছোট ছোট reusable অংশে ভাগ করতে পারেন।

---

### 2. Types of React Components

React এ দুটি প্রধান ধরনের component আছে: **Function Components** এবং **Class Components**।

#### Function Components

**Function Components** হলো JavaScript functions যা JSX return করে। এগুলো React Hooks ব্যবহার করে state এবং lifecycle এর সাথে কাজ করতে পারে। Function components সাধারণত সহজ এবং lightweight হয়।

##### Example of Function Component:

```jsx
function Greeting(props) {
  return <h1>Hello, {props.name}!</h1>;
}
```

#### Class Components

**Class Components** হলো ES6 এর JavaScript classes যা React.Component থেকে extend করে। এগুলো state এবং lifecycle methods support করে। তবে function components এবং hooks এর আগমনের পর class components এর ব্যবহার কমে গেছে।

##### Example of Class Component:

```jsx
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}
```

---

### 3. Props in React Components

**Props** হলো component এর external data যা parent component থেকে pass করা হয়। এটি immutable, অর্থাৎ component এর ভিতর থেকে props modify করা যায় না। Props এর মাধ্যমে component গুলো dynamic data গ্রহণ করে এবং সেই অনুযায়ী render করতে পারে।

##### Example of Passing Props:

```jsx
function Greeting(props) {
  return <h1>Hello, {props.name}!</h1>;
}

const element = <Greeting name="John" />;
ReactDOM.render(element, document.getElementById("root"));
```

এখানে, **name** prop parent component থেকে **Greeting** component এ pass করা হয়েছে, যা UI তে dynamic data প্রদর্শন করছে।

---

### 4. State in React Components

**State** হলো component এর internal data, যা পরিবর্তনশীল এবং component এর behavior কে dynamically পরিবর্তন করতে পারে। Function components এ state handle করতে **useState Hook** এবং class components এ **this.state** ব্যবহার করা হয়। State dynamic data handle করে, যা user interaction এর উপর ভিত্তি করে পরিবর্তিত হয়।

##### Example of State in Function Component:

```jsx
import React, { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}
```

##### Example of State in Class Component:

```jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  render() {
    return (
      <div>
        <p>You clicked {this.state.count} times</p>
        <button onClick={() => this.setState({ count: this.state.count + 1 })}>
          Click me
        </button>
      </div>
    );
  }
}
```

---

### 5. Lifecycle Methods in Class Components

React class components এ **lifecycle methods** থাকে, যা component এর বিভিন্ন পর্যায়ে (mounting, updating, unmounting) কাজ করতে সাহায্য করে। কিছু গুরুত্বপূর্ণ lifecycle methods হলো:

- **componentDidMount**: component render হওয়ার পর একবার চালানো হয়।
- **componentDidUpdate**: component re-render হলে এটি চালানো হয়।
- **componentWillUnmount**: component destroy হওয়ার আগে চালানো হয়।

##### Example of componentDidMount:

```jsx
class Timer extends React.Component {
  componentDidMount() {
    this.timerID = setInterval(() => this.tick(), 1000);
  }

  tick() {
    console.log("Timer is ticking");
  }

  render() {
    return <h1>Timer Running</h1>;
  }
}
```

---

### 6. Real-life Example of React Components

ধরা যাক, আপনি একটি **User Profile** তৈরি করতে চান যেখানে user এর নাম, বয়স এবং address দেখানো হবে। এটি component ভিত্তিক ভাবে খুব সহজেই করা যায়।

#### Example:

```jsx
function UserProfile(props) {
  return (
    <div className="profile">
      <h2>{props.name}</h2>
      <p>Age: {props.age}</p>
      <p>Address: {props.address}</p>
    </div>
  );
}

const element = (
  <UserProfile name="John Doe" age="30" address="123 React Street" />
);

ReactDOM.render(element, document.getElementById("root"));
```

#### Explanation:

- **UserProfile Component**: এখানে একটি reusable React component তৈরি করা হয়েছে, যা props এর মাধ্যমে dynamic data render করছে।
- **Props**: User এর **name**, **age**, এবং **address** props আকারে **UserProfile** component এ পাঠানো হয়েছে।

---

### 7. Conclusion

React এর **components** modern web development এর cornerstone, কারণ এগুলো UI কে ছোট, reusable অংশে ভাগ করে, যেগুলো dynamic ভাবে কাজ করে। React components বিভিন্ন ধরণের data handle করতে পারে, যেমন props, state, এবং lifecycle methods এর মাধ্যমে complex UI তৈরি করতে পারে।

Function components এবং hooks আসার পর থেকে React এর ব্যবহার আরও সহজ এবং efficient হয়েছে, কিন্তু class components এর শক্তিশালী lifecycle methods এখনও বেশ উপযোগী।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-07: React Class Components

### Table of Contents:

1. [What is a React Class Component?](#what-is-a-react-class-component)
2. [Defining a React Class Component](#defining-a-react-class-component)
3. [React Class vs Function Components](#react-class-vs-function-components)
4. [State in Class Components](#state-in-class-components)
5. [Lifecycle Methods in Class Components](#lifecycle-methods-in-class-components)
6. [Props in Class Components](#props-in-class-components)
7. [Real-life Example of React Class Components](#real-life-example-of-react-class-components)
8. [Conclusion](#conclusion)

---

### 1. What is a React Class Component?

**React Class Components** হলো traditional React components যা ES6 এর JavaScript class এর মাধ্যমে তৈরি করা হয়। Class components ব্যবহার করে state management, lifecycle methods এবং complex functionality সহজে handle করা যায়। যদিও function components এবং React Hooks এর আগমনে class components এর ব্যবহার কমে গেছে, তবুও class components এখনও পুরোনো কোডবেস এবং কিছু complex scenarios তে ব্যবহৃত হয়।

Class components React.Component class থেকে extend করে এবং অবশ্যই **render()** method রাখতে হয়, যা JSX বা React elements return করে।

---

### 2. Defining a React Class Component

React class component define করতে গেলে, আপনাকে ES6 class ব্যবহার করতে হবে, যা **React.Component** class থেকে inherit করে। নিচে একটি React class component এর উদাহরণ দেয়া হলো:

##### Example of Class Component:

```jsx
import React, { Component } from "react";

class Welcome extends Component {
  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}

export default Welcome;
```

#### Explanation:

1. **Welcome Component**: এখানে **Welcome** নামে একটি React class component তৈরি করা হয়েছে, যা **React.Component** থেকে extend করা হয়েছে।
2. **render() Method**: প্রত্যেক React class component এর মধ্যে **render()** method থাকতে হবে, যেখানে JSX বা React elements return করা হবে।
3. **props**: Class components এর মধ্যে **props** **this.props** ব্যবহার করে access করতে হয়।

---

### 3. React Class vs Function Components

React এর শুরুতে class components ব্যবহার করা হতো, কিন্তু function components এবং React Hooks আসার পর থেকে function components বেশি জনপ্রিয়। নিচে দুই ধরনের component এর পার্থক্য দেয়া হলো:

#### Function Components:

- **Simpler**: Function components সহজ এবং lightweight।
- **Hooks**: React Hooks এর মাধ্যমে function components state এবং lifecycle methods manage করতে পারে।
- **Less Boilerplate**: Function components এ class components এর মতো boilerplate কোড লিখতে হয় না।

#### Class Components:

- **State and Lifecycle**: Class components এ state এবং lifecycle methods প্রাকৃতিকভাবে আছে।
- **Legacy Code**: পুরোনো React কোডবেসে এখনও class components ব্যবহার করা হয়।
- **Complex Features**: কিছু complex feature class components এ বেশি সহজে handle করা যায়।

---

### 4. State in Class Components

**State** হলো class component এর internal data, যা dynamic ভাবে পরিবর্তিত হতে পারে এবং component এর UI কে update করতে পারে। Class components এ **this.state** এবং **this.setState()** ব্যবহার করে state manage করা হয়।

##### Example of State in Class Component:

```jsx
import React, { Component } from "react";

class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}

export default Counter;
```

#### Explanation:

1. **this.state**: এখানে **count** নামক একটি state তৈরি করা হয়েছে।
2. **this.setState()**: state update করতে **this.setState()** method ব্যবহার করা হয়েছে।
3. **render()**: state এর পরিবর্তন অনুযায়ী component re-render হয় এবং updated data UI তে প্রদর্শিত হয়।

---

### 5. Lifecycle Methods in Class Components

React class components এর একটি গুরুত্বপূর্ণ feature হলো **lifecycle methods**। এই methods component এর lifecycle এর বিভিন্ন পর্যায়ে (mounting, updating, unmounting) execute হয়।

#### Common Lifecycle Methods:

1. **componentDidMount**: Component render হওয়ার পর এটি একবার execute হয়।
2. **componentDidUpdate**: Component re-render হলে execute হয়।
3. **componentWillUnmount**: Component destroy হওয়ার আগে execute হয়।

##### Example of Lifecycle Method:

```jsx
import React, { Component } from "react";

class Timer extends Component {
  componentDidMount() {
    this.timerID = setInterval(() => this.tick(), 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    console.log("Timer ticking");
  }

  render() {
    return <h1>Timer is running</h1>;
  }
}

export default Timer;
```

#### Explanation:

1. **componentDidMount**: Timer শুরু করার জন্য **setInterval** এখানে ব্যবহার করা হয়েছে, যা component render হওয়ার পর চালু হয়।
2. **componentWillUnmount**: Component destroy হওয়ার আগে **clearInterval** ব্যবহার করে timer বন্ধ করা হয়েছে।

---

### 6. Props in Class Components

**Props** হলো external data যা parent component থেকে class component এ pass করা হয়। Class components এ props **this.props** ব্যবহার করে access করা হয়।

##### Example of Props in Class Component:

```jsx
import React, { Component } from "react";

class Welcome extends Component {
  render() {
    return <h1>Welcome, {this.props.name}!</h1>;
  }
}

export default Welcome;
```

#### Explanation:

1. **this.props**: এখানে **name** prop pass করা হয়েছে, যা **this.props.name** ব্যবহার করে UI তে প্রদর্শিত হচ্ছে।

---

### 7. Real-life Example of React Class Components

ধরা যাক, আপনি একটি **User Profile** class component তৈরি করতে চান, যেখানে user এর নাম এবং বয়স dynamic ভাবে প্রদর্শিত হবে এবং সেই তথ্য পরিবর্তিত হবে।

#### Example:

```jsx
import React, { Component } from "react";

class UserProfile extends Component {
  constructor(props) {
    super(props);
    this.state = { age: 25 };
  }

  incrementAge = () => {
    this.setState({ age: this.state.age + 1 });
  };

  render() {
    return (
      <div>
        <h2>{this.props.name}</h2>
        <p>Age: {this.state.age}</p>
        <button onClick={this.incrementAge}>Increase Age</button>
      </div>
    );
  }
}

export default UserProfile;
```

#### Explanation:

1. **UserProfile Component**: এখানে **UserProfile** একটি class component যা user এর নাম এবং বয়স প্রদর্শন করছে।
2. **Props and State**: User এর নাম **props** এর মাধ্যমে pass করা হয়েছে এবং বয়স **state** এর মাধ্যমে handle করা হচ্ছে।
3. **Increment Function**: **this.setState()** method ব্যবহার করে user এর বয়স বাড়ানো হচ্ছে।

---

### 8. Conclusion

React class components modern web development এর cornerstone, বিশেষ করে state management এবং lifecycle methods handle করার ক্ষেত্রে। যদিও function components এবং React Hooks আসার পরে class components এর ব্যবহার কিছুটা কমেছে, তবুও তারা পুরনো কোডবেস এবং complex applications এর জন্য এখনও গুরুত্বপূর্ণ। Class components এর মাধ্যমে React এর powerful features যেমন state, props, এবং lifecycle methods handle করা সম্ভব হয়।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-07.1: Lifecycle Methods in Class Components

### Table of Contents:

1. [What are Lifecycle Methods?](#what-are-lifecycle-methods)
2. [Phases of Component Lifecycle](#phases-of-component-lifecycle)
3. [Lifecycle Methods in Each Phase](#lifecycle-methods-in-each-phase)
   - [Mounting Phase](#mounting-phase)
   - [Updating Phase](#updating-phase)
   - [Unmounting Phase](#unmounting-phase)
4. [Real-life Example of Lifecycle Methods](#real-life-example-of-lifecycle-methods)
5. [Best Practices for Using Lifecycle Methods](#best-practices-for-using-lifecycle-methods)
6. [Conclusion](#conclusion)

---

### 1. What are Lifecycle Methods?

React এর class components এ **lifecycle methods** এমন কিছু বিশেষ method, যা component এর বিভিন্ন পর্যায়ে execute হয়। Component এর initialization থেকে শুরু করে update এবং destruction পর্যন্ত প্রতিটি ধাপে এই methods গুলো ব্যবহার করে component এর behavior control করা যায়। **Lifecycle methods** component render, update, এবং unmount হওয়ার সময় নির্দিষ্ট কাজ পরিচালনা করতে সাহায্য করে, যেমন: data fetching, DOM manipulation, cleanup, ইত্যাদি।

---

### 2. Phases of Component Lifecycle

React component এর lifecycle মূলত তিনটি ধাপে বিভক্ত:

1. **Mounting**: Component DOM এ প্রথমবার যুক্ত হওয়ার সময়।
2. **Updating**: Component এর props বা state পরিবর্তিত হলে।
3. **Unmounting**: Component যখন DOM থেকে remove হয়।

---

### 3. Lifecycle Methods in Each Phase

#### Mounting Phase

Mounting phase এ component তৈরি হয় এবং DOM এ প্রথমবার render হয়। এই সময়ে নিচের lifecycle methods গুলো sequentially call হয়:

1. **constructor()**
2. **getDerivedStateFromProps()**
3. **render()**
4. **componentDidMount()**

##### Explanation of Each Method:

- **constructor(props)**: Component এর initial state এবং props set করার জন্য constructor method ব্যবহার করা হয়। এটি lifecycle এর প্রথম method এবং **this.state** initialize করার জন্য এটি গুরুত্বপূর্ণ।

  ```javascript
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }
  ```

- **getDerivedStateFromProps(props, state)**: এটি একটি static method যা props এর উপর ভিত্তি করে state update করার জন্য ব্যবহৃত হয়। এটি rendering এর ঠিক আগে call হয় এবং state return করে।

  ```javascript
  static getDerivedStateFromProps(props, state) {
    if (props.reset) {
      return { count: 0 };
    }
    return null;
  }
  ```

- **render()**: render() method component এর UI define করে এবং JSX return করে। এটি mandatory method এবং এটি re-rendering trigger করে।

  ```javascript
  render() {
    return <h1>Count: {this.state.count}</h1>;
  }
  ```

- **componentDidMount()**: component প্রথমবার render হওয়ার পরে **componentDidMount** execute হয়। এটি API call বা DOM manipulation এর জন্য উপযুক্ত।

  ```javascript
  componentDidMount() {
    console.log("Component mounted!");
  }
  ```

---

#### Updating Phase

Updating phase এ component এর props বা state পরিবর্তিত হলে component re-render হয়। এই সময়ে sequentially নিচের lifecycle methods গুলো call হয়:

1. **getDerivedStateFromProps()**
2. **shouldComponentUpdate()**
3. **render()**
4. **getSnapshotBeforeUpdate()**
5. **componentDidUpdate()**

##### Explanation of Each Method:

- **shouldComponentUpdate(nextProps, nextState)**: এই method return করে true বা false, যা নির্ধারণ করে component re-render হবে কি না। এটি performance optimization এর জন্য উপযুক্ত।

  ```javascript
  shouldComponentUpdate(nextProps, nextState) {
    return nextState.count !== this.state.count;
  }
  ```

- **getSnapshotBeforeUpdate(prevProps, prevState)**: DOM update হওয়ার আগে component এর পূর্বের অবস্থার snapshot নিতে ব্যবহৃত হয়। এটি scrolling position, DOM updates track করতে ব্যবহৃত হয়।

  ```javascript
  getSnapshotBeforeUpdate(prevProps, prevState) {
    if (prevState.count < this.state.count) {
      return "Count increased";
    }
    return null;
  }
  ```

- **componentDidUpdate(prevProps, prevState, snapshot)**: Component update হওয়ার পরে execute হয় এবং **getSnapshotBeforeUpdate** এর return value receive করে।

  ```javascript
  componentDidUpdate(prevProps, prevState, snapshot) {
    if (snapshot) {
      console.log(snapshot);
    }
  }
  ```

---

#### Unmounting Phase

Unmounting phase এ component যখন DOM থেকে remove হওয়ার সময়, এই method টি call হয়:

- **componentWillUnmount()**: Component unmount হওয়ার আগে এই method execute হয়। এটি cleanup এর জন্য, যেমন: timers, subscriptions, event listeners remove করতে ব্যবহৃত হয়।

  ```javascript
  componentWillUnmount() {
    console.log("Component will unmount!");
  }
  ```

---

### 4. Real-life Example of Lifecycle Methods

ধরা যাক, আমরা একটি **Timer** component তৈরি করতে চাচ্ছি যা প্রতি সেকেন্ডে update হবে এবং component unmount হলে timer বন্ধ হবে।

##### Example:

```javascript
import React, { Component } from "react";

class Timer extends Component {
  constructor(props) {
    super(props);
    this.state = { seconds: 0 };
  }

  componentDidMount() {
    this.timerID = setInterval(() => {
      this.setState((prevState) => ({ seconds: prevState.seconds + 1 }));
    }, 1000);
  }

  componentDidUpdate() {
    console.log("Timer updated:", this.state.seconds);
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
    console.log("Timer cleared");
  }

  render() {
    return <h1>Seconds: {this.state.seconds}</h1>;
  }
}

export default Timer;
```

**Explanation**:

1. **componentDidMount**: এখানে interval set করা হয়েছে এবং timer প্রতি সেকেন্ডে update হচ্ছে।
2. **componentDidUpdate**: Timer এর প্রতি update console এ log করা হচ্ছে।
3. **componentWillUnmount**: Component unmount হওয়ার আগে interval clear করা হচ্ছে।

---

### 5. Best Practices for Using Lifecycle Methods

1. **Avoid Excessive use of componentDidUpdate**: Unnecessary re-renders এড়ানোর জন্য **componentDidUpdate** এ conditionals ব্যবহার করুন।
2. **Perform Cleanup in componentWillUnmount**: Memory leak এড়াতে cleanup নিশ্চিত করুন।
3. **Avoid Direct DOM Manipulation**: React এর built-in state এবং props ব্যবহার করুন, সরাসরি DOM access না করাই ভালো।

---

### 6. Conclusion

React এর class components এ **lifecycle methods** component এর initialization, update, এবং destruction phases কে manage করতে সাহায্য করে। Proper use of these lifecycle methods allows developers to control the behavior of components effectively, manage resources, and optimize performance, making React applications more robust and efficient.

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-07.2: Props in Class Components

### Table of Contents:

1. [What are Props?](#what-are-props)
2. [Why Use Props in Class Components?](#why-use-props-in-class-components)
3. [How to Access Props in Class Components](#how-to-access-props-in-class-components)
4. [Passing Props to Class Components](#passing-props-to-class-components)
5. [Default Props](#default-props)
6. [Prop Types for Validation](#prop-types-for-validation)
7. [Real-life Example of Props Usage](#real-life-example-of-props-usage)
8. [Conclusion](#conclusion)

---

### 1. What are Props?

**Props** বা "properties" হলো React এ data passing করার একটি পদ্ধতি, যা parent component থেকে child component এ data পাঠাতে ব্যবহৃত হয়। Props হলো immutable, অর্থাৎ, child component এ props এর মান পরিবর্তন করা যায় না। এটি component এর behavior customize করতে এবং dynamic content প্রদর্শন করতে সাহায্য করে।

---

### 2. Why Use Props in Class Components?

Props ব্যবহার করে:

- Parent component থেকে data child component এ পাঠানো যায়।
- Dynamic এবং reusable components তৈরি করা যায়।
- Component কে configurable এবং flexible করে তোলা সম্ভব হয়, যা কোডের reusability বাড়ায়।

---

### 3. How to Access Props in Class Components

Class components এ props access করতে `this.props` ব্যবহার করা হয়।

##### Example:

```javascript
class Greeting extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}
```

**Explanation**:

- এখানে **this.props.name** এর মাধ্যমে props এ পাঠানো `name` property access করা হচ্ছে।

---

### 4. Passing Props to Class Components

Parent component থেকে child component এ props পাঠানোর জন্য component attribute হিসেবে data pass করতে হয়।

##### Example:

```javascript
class App extends React.Component {
  render() {
    return <Greeting name="John" age={25} />;
  }
}

class Greeting extends React.Component {
  render() {
    return (
      <div>
        <h1>Hello, {this.props.name}!</h1>
        <p>Your age is {this.props.age}.</p>
      </div>
    );
  }
}

ReactDOM.render(<App />, document.getElementById("root"));
```

**Explanation**:

- **name** এবং **age** props হিসেবে **Greeting** component এ pass করা হয়েছে, এবং **this.props.name** ও **this.props.age** এর মাধ্যমে access করা হয়েছে।

**Output**:

```
Hello, John!
Your age is 25.
```

---

### 5. Default Props

React এ **default props** সেট করে দেয়া যায়, যা component এ props না পাঠালে default value হিসেবে ব্যবহৃত হবে।

##### Example:

```javascript
class Greeting extends React.Component {
  static defaultProps = {
    name: "Guest",
  };

  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}

ReactDOM.render(<Greeting />, document.getElementById("root"));
```

**Explanation**:

- এখানে **name** prop না পাঠালে default value হিসেবে "Guest" দেখাবে।

**Output**:

```
Hello, Guest!
```

---

### 6. Prop Types for Validation

React এ prop types ব্যবহার করে props validation করা যায়, যা সাহায্য করে সঠিক ধরনের data component এ pass হচ্ছে কি না তা নিশ্চিত করতে।

##### Example:

```javascript
import PropTypes from "prop-types";

class Greeting extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}

Greeting.propTypes = {
  name: PropTypes.string.isRequired,
};

ReactDOM.render(<Greeting name="John" />, document.getElementById("root"));
```

**Explanation**:

- **PropTypes** ব্যবহার করে props এর type নিশ্চিত করা হয়েছে। এখানে **name** একটি string এবং এটি অবশ্যই প্রয়োজন।

---

### 7. Real-life Example of Props Usage

ধরা যাক, আমরা একটি simple profile component তৈরি করতে চাই, যেখানে user এর নাম এবং তার কাজ দেখানো হবে।

##### Example:

```javascript
class Profile extends React.Component {
  render() {
    return (
      <div>
        <h1>Name: {this.props.name}</h1>
        <p>Profession: {this.props.profession}</p>
      </div>
    );
  }
}

class App extends React.Component {
  render() {
    return (
      <div>
        <Profile name="Alice" profession="Engineer" />
        <Profile name="Bob" profession="Designer" />
      </div>
    );
  }
}

ReactDOM.render(<App />, document.getElementById("root"));
```

**Explanation**:

- **App** component থেকে **Profile** component এ **name** এবং **profession** props হিসেবে pass করা হয়েছে। প্রতিটি **Profile** component এ আলাদা আলাদা data pass করে বিভিন্ন content render করা হচ্ছে।

**Output**:

```
Name: Alice
Profession: Engineer

Name: Bob
Profession: Designer
```

---

### 8. Conclusion

React এর class components এ **props** ব্যবহার করলে data সহজে parent থেকে child component এ pass করা যায়। এটি component কে flexible এবং reusable করে তোলে, কারণ parent component dynamic data পাঠিয়ে component এর behavior customize করতে পারে। **Default props** এবং **prop types validation** ব্যবহার করে props এর type এবং মান নিশ্চিত করা যায়।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-08: Props in Functional Components

### Table of Contents:

1. [What are Props in React?](#what-are-props-in-react)
2. [Why are Props Important?](#why-are-props-important)
3. [How to Pass Props in React](#how-to-pass-props-in-react)
4. [Accessing Props in Components](#accessing-props-in-components)
5. [Default Props](#default-props)
6. [Props vs State](#props-vs-state)
7. [Real-life Example of Props](#real-life-example-of-props)
8. [Conclusion](#conclusion)

---

### 1. What are Props in React?

**Props** হলো React components এর external data যা parent component থেকে child component এ pass করা হয়। React এর **props** system component গুলোর মধ্যে data share এবং dynamic UI তৈরি করার অন্যতম প্রধান উপায়। **Props** immutable, অর্থাৎ component এর ভেতর থেকে props পরিবর্তন করা যায় না, বরং এটি শুধুমাত্র read-only data হিসেবে কাজ করে।

Props এর মাধ্যমে React components reusability বাড়ানো যায়, কারণ parent component থেকে child component এ বিভিন্ন data পাঠানো যায় এবং সেই অনুযায়ী render করা যায়।

##### Example of Props:

```jsx
function Greeting(props) {
  return <h1>Hello, {props.name}!</h1>;
}
```

এখানে **props.name** এর মাধ্যমে **name** নামক external data component এ dynamically প্রদর্শিত হচ্ছে।

---

### 2. Why are Props Important?

Props React এ **reusable** এবং **dynamic** component তৈরি করার জন্য অত্যন্ত গুরুত্বপূর্ণ। এগুলো parent-child component গুলোর মধ্যে data communication এর কাজ করে। Parent component থেকে props pass করলে, child component সেই props data ব্যবহার করে dynamic content তৈরি করতে পারে।

#### Key Reasons Props are Important:

- **Reusability**: Props ব্যবহার করে একই component কে বিভিন্ন data দিয়ে পুনরায় ব্যবহার করা যায়।
- **Dynamic Rendering**: Props এর মাধ্যমে dynamic data handle করা যায়, যা UI কে ব্যবহারকারীর action অনুযায়ী পরিবর্তিত করতে পারে।
- **Unidirectional Data Flow**: React এর props system parent থেকে child component এ data flow নিশ্চিত করে।

---

### 3. How to Pass Props in React

React component এ props pass করতে গেলে JSX attributes এর মতো syntax ব্যবহার করতে হয়। Parent component থেকে child component এ props pass করা খুবই সহজ এবং নিচের উদাহরণে তা দেখানো হয়েছে।

##### Example of Passing Props:

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}!</h1>;
}

const element = <Welcome name="John" />;
ReactDOM.render(element, document.getElementById("root"));
```

#### Explanation:

1. **Parent Component**: Parent component থেকে **name="John"** props হিসেবে pass করা হয়েছে।
2. **Child Component**: Child component (Welcome) **props.name** এর মাধ্যমে সেই data access করছে এবং JSX এর মধ্যে render করছে।

---

### 4. Accessing Props in Components

**Props** কে class component এবং function component দুটিতেই ব্যবহার করা যায়, কিন্তু দুটো component এ props access করার পদ্ধতি কিছুটা আলাদা।

#### Accessing Props in Function Components:

Function components এ **props** function এর argument হিসেবে access করা হয়।

##### Example:

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}!</h1>;
}
```

#### Accessing Props in Class Components:

Class components এ **this.props** ব্যবহার করে props access করা হয়।

##### Example:

```jsx
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}
```

---

### 5. Default Props

কিছু ক্ষেত্রে, component এ কোনো props pass না হলে default value set করা দরকার হতে পারে। এই ক্ষেত্রে React এর **defaultProps** feature ব্যবহার করা হয়।

##### Example of Default Props:

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}!</h1>;
}

Welcome.defaultProps = {
  name: "Guest",
};
```

#### Explanation:

এখানে **name** props pass না করা হলে, **'Guest'** default হিসেবে render হবে।

---

### 6. Props vs State

**Props** এবং **State** উভয়ই component এর data manage করতে ব্যবহৃত হয়, কিন্তু এদের মধ্যে কিছু গুরুত্বপূর্ণ পার্থক্য রয়েছে:

| **Props**                      | **State**                              |
| ------------------------------ | -------------------------------------- |
| Immutable                      | Mutable                                |
| Parent component থেকে pass হয় | Component এর ভেতরে declare করা হয়     |
| Read-only                      | Component এর ভেতর থেকে update করা যায় |
| Unidirectional data flow করে   | Component এর behavior handle করে       |

#### Key Differences:

- **Props** parent থেকে child component এ data pass করার জন্য ব্যবহৃত হয়।
- **State** component এর internal data যা dynamic এবং component এর behavior পরিবর্তন করতে সাহায্য করে।

---

### 7. Real-life Example of Props

ধরা যাক, আপনি একটি **Product Card** component তৈরি করতে চান, যেখানে product এর image, নাম, এবং মূল্য থাকবে। Props ব্যবহার করে parent component থেকে এই data child component এ pass করা হবে।

#### Example:

```jsx
function ProductCard(props) {
  return (
    <div className="product-card">
      <img src={props.image} alt={props.name} />
      <h2>{props.name}</h2>
      <p>Price: ${props.price}</p>
    </div>
  );
}

const product = {
  name: "Laptop",
  price: 1200,
  image: "https://example.com/laptop.jpg",
};

ReactDOM.render(
  <ProductCard
    name={product.name}
    price={product.price}
    image={product.image}
  />,
  document.getElementById("root")
);
```

#### Explanation:

1. **ProductCard Component**: এখানে **ProductCard** নামে একটি component তৈরি করা হয়েছে, যেখানে props এর মাধ্যমে **name**, **price**, এবং **image** pass করা হয়েছে।
2. **Parent Component**: Parent component থেকে product এর সমস্ত data props হিসেবে **ProductCard** component এ pass করা হচ্ছে।
3. **Rendering**: Product এর নাম, মূল্য এবং ছবি dynamic ভাবে render হচ্ছে।

---

### 8. Conclusion

React এর **Props** হলো component গুলোর মধ্যে data flow এবং communication এর অন্যতম প্রধান উপাদান। এটি component কে dynamic ভাবে render করতে এবং reusability বাড়াতে সাহায্য করে। Props immutable হওয়ায় component এর ভিতরে এটি পরিবর্তন করা যায় না, যা predictable এবং stable component তৈরি করতে সহায়ক।

Props এবং state একসাথে ব্যবহার করে complex এবং interactive UI তৈরি করা সম্ভব হয়।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-09: React State & Lifecycle in Class Components

### Table of Contents:

1. [What is State in React Class Components?](#what-is-state-in-react-class-components)
2. [What is Lifecycle in React Class Components?](#what-is-lifecycle-in-react-class-components)
3. [Managing State in Class Components](#managing-state-in-class-components)
   - [Setting Initial State](#setting-initial-state)
   - [Updating State with setState](#updating-state-with-setstate)
4. [React Class Component Lifecycle Phases](#react-class-component-lifecycle-phases)
   - [Mounting Phase](#mounting-phase)
   - [Updating Phase](#updating-phase)
   - [Unmounting Phase](#unmounting-phase)
5. [Common Lifecycle Methods](#common-lifecycle-methods)
   - [componentDidMount](#componentdidmount)
   - [componentDidUpdate](#componentdidupdate)
   - [componentWillUnmount](#componentwillunmount)
6. [Real-life Example: Timer with State and Lifecycle](#real-life-example-timer-with-state-and-lifecycle)
7. [Conclusion](#conclusion)

---

### 1. What is State in React Class Components?

**State** হলো React class component এর internal data, যা component এর behavior এবং appearance পরিবর্তনের জন্য dynamically manage করা হয়। Class components এ **state** এর মাধ্যমে component এ পরিবর্তন আসলে UI সেই অনুযায়ী update হয়। State এমন একটি JavaScript object যা component এর ভেতরে থাকে এবং component এর data বা UI control করতে সাহায্য করে।

##### Example of State:

```jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  render() {
    return <h1>Count: {this.state.count}</h1>;
  }
}
```

---

### 2. What is Lifecycle in React Class Components?

**Component lifecycle** হলো React component এর বিভিন্ন পর্যায় যা component এর creation থেকে destruction পর্যন্ত চলে। একটি React class component মূলত তিনটি ধাপে থাকে:

1. **Mounting**: Component DOM এ প্রথমবার insert হওয়ার সময়।
2. **Updating**: Component এর props বা state পরিবর্তিত হলে।
3. **Unmounting**: Component DOM থেকে remove হওয়ার সময়।

React এর lifecycle methods এই বিভিন্ন ধাপগুলোতে component এর behavior পরিচালনা করে। এই methods component এর বিভিন্ন পর্যায়ে execute হয়, যেমন component যখন render হয় বা destroy হয়।

---

### 3. Managing State in Class Components

#### Setting Initial State

Class component এর **constructor()** method এর মাধ্যমে initial state set করা হয়। **this.state** এর মাধ্যমে state এর initial value নির্ধারণ করা হয়।

##### Example of Initial State:

```jsx
class Greeting extends React.Component {
  constructor(props) {
    super(props);
    this.state = { message: "Hello, World!" };
  }

  render() {
    return <h1>{this.state.message}</h1>;
  }
}
```

#### Updating State with setState

State কে পরিবর্তন করতে হলে **this.setState()** method ব্যবহার করা হয়। এটি asynchronous ভাবে কাজ করে এবং state এর পরিবর্তন অনুযায়ী component re-render করে।

##### Example of Updating State:

```jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <h1>Count: {this.state.count}</h1>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}
```

#### Explanation:

1. **this.state**: Initial state set করার জন্য **this.state** ব্যবহার করা হয়েছে।
2. **this.setState()**: state update করার জন্য **this.setState()** method ব্যবহার করা হয়েছে এবং count increment করা হচ্ছে।

---

### 4. React Class Component Lifecycle Phases

React class component lifecycle তিনটি ধাপে বিভক্ত:

#### Mounting Phase

এই phase এ component DOM এ প্রথমবার insert হয়। কিছু common lifecycle methods হলো:

- **constructor()**
- **componentDidMount()**

#### Updating Phase

Component এর state বা props পরিবর্তিত হলে component update হয়। এই phase এ কিছু common lifecycle methods হলো:

- **shouldComponentUpdate()**
- **componentDidUpdate()**

#### Unmounting Phase

Component যখন DOM থেকে remove হয়, তখন এই phase শুরু হয়। একটি common lifecycle method হলো:

- **componentWillUnmount()**

---

### 5. Common Lifecycle Methods

#### componentDidMount

**componentDidMount** lifecycle method টি তখন execute হয় যখন component DOM এ প্রথমবার render হয়। এটি সাধারণত API calls বা external resources load করার জন্য ব্যবহার করা হয়।

##### Example:

```jsx
class Timer extends React.Component {
  componentDidMount() {
    this.timerID = setInterval(() => this.tick(), 1000);
  }

  tick() {
    console.log("Timer is running");
  }

  render() {
    return <h1>Timer Started</h1>;
  }
}
```

#### componentDidUpdate

**componentDidUpdate** method টি component update হওয়ার পরে execute হয়। এটি props বা state এর পরিবর্তন অনুযায়ী কাজ করতে পারে।

##### Example:

```jsx
class Counter extends React.Component {
  componentDidUpdate(prevProps, prevState) {
    if (this.state.count !== prevState.count) {
      console.log("Count updated");
    }
  }

  render() {
    return <h1>Updated Count: {this.state.count}</h1>;
  }
}
```

#### componentWillUnmount

**componentWillUnmount** method component destroy হওয়ার আগে execute হয়। এটি component এর resources (যেমন timers, subscriptions) clear করতে ব্যবহার করা হয়।

##### Example:

```jsx
class Timer extends React.Component {
  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  render() {
    return <h1>Timer Stopped</h1>;
  }
}
```

---

### 6. Real-life Example: Timer with State and Lifecycle

ধরা যাক, আপনি একটি timer component তৈরি করতে চান, যেখানে প্রতি সেকেন্ডে timer increment হবে এবং component destroy হলে timer বন্ধ হবে।

##### Example:

```jsx
class Timer extends React.Component {
  constructor(props) {
    super(props);
    this.state = { seconds: 0 };
  }

  componentDidMount() {
    this.timerID = setInterval(() => this.tick(), 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    this.setState({ seconds: this.state.seconds + 1 });
  }

  render() {
    return (
      <div>
        <h1>Timer: {this.state.seconds} seconds</h1>
      </div>
    );
  }
}

export default Timer;
```

#### Explanation:

1. **State Management**: Timer component এর state initial value হিসাবে 0 set করা হয়েছে।
2. **Lifecycle Methods**: **componentDidMount** method এর মাধ্যমে timer শুরু করা হয়েছে এবং **componentWillUnmount** method এর মাধ্যমে timer clear করা হয়েছে।
3. **State Update**: **this.setState()** method এর মাধ্যমে প্রতি সেকেন্ডে state update হচ্ছে এবং seconds value বাড়ানো হচ্ছে।

---

### 7. Conclusion

React class components এর **state** এবং **lifecycle methods** React এর অন্যতম প্রধান features, যা dynamic এবং interactive UI তৈরি করতে সাহায্য করে। **State** component এর internal data manage করতে সাহায্য করে, যেখানে **lifecycle methods** component এর lifecycle এর বিভিন্ন পর্যায়ে বিভিন্ন কাজ পরিচালনা করে।

State এবং lifecycle methods ব্যবহার করে আপনি complex functionality handle করতে পারেন, যেমন asynchronous operations (API calls), timers, এবং resource management। Class components এ state এবং lifecycle একসাথে কাজ করে component behavior এবং rendering process কে নিয়ন্ত্রণ করে, যা একটি powerful tool React developers এর জন্য।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-10: React Events

### Table of Contents:

1. [What are Events in React?](#what-are-events-in-react)
2. [How Events Work in React](#how-events-work-in-react)
3. [Handling Events in React](#handling-events-in-react)
4. [Event Handling in Functional and Class Components](#event-handling-in-functional-and-class-components)
5. [Passing Arguments to Event Handlers](#passing-arguments-to-event-handlers)
6. [Common React Event Types](#common-react-event-types)
   - [Click Events](#click-events)
   - [Form Events](#form-events)
   - [Keyboard Events](#keyboard-events)
7. [Real-life Example: Form Handling with Events](#real-life-example-form-handling-with-events)
8. [Conclusion](#conclusion)

---

### 1. What are Events in React?

**Events** React এ এমন কার্যকলাপ যেগুলো ব্যবহারকারী UI এর সাথে ইন্টারেক্ট করলে ট্রিগার হয়। উদাহরণস্বরূপ, button এ click করা, input field এ টাইপ করা, form submit করা — এসবই events। React events web browsers এর native DOM events এর উপর ভিত্তি করে কাজ করে, কিন্তু React events **camelCase** এ লেখা হয় এবং inline **JavaScript functions** বা **function references** এর মাধ্যমে handle করা হয়।

---

### 2. How Events Work in React

React এ event handling এর process কিছুটা আলাদা। Traditional DOM এর events যেমন `onclick`, `onchange` এগুলো lowercase এ লেখা হয়, কিন্তু React এ event attributes গুলো **camelCase** এ লিখতে হয় যেমন `onClick`, `onChange` ইত্যাদি। React events **synthetic events** নামে পরিচিত, যা native browser events এর উপর ভিত্তি করে তৈরি।

Synthetic events cross-browser compatibility নিশ্চিত করে এবং React এর Virtual DOM এর সাথে efficiently কাজ করে।

---

### 3. Handling Events in React

React এ events handle করতে হলে inline function অথবা function reference ব্যবহার করা হয়। একটি React event handling এর উদাহরণ নিচে দেখানো হলো।

##### Example of Event Handling:

```jsx
function ButtonClick() {
  const handleClick = () => {
    alert("Button was clicked!");
  };

  return <button onClick={handleClick}>Click Me</button>;
}
```

#### Explanation:

- **handleClick function**: এই function টি button এ click হলে execute হবে।
- **onClick event**: **onClick** event attribute এর মাধ্যমে **handleClick** function button এ click করার সাথে সাথে ট্রিগার হয়।

---

### 4. Event Handling in Functional and Class Components

React এ event handling class components এবং functional components এ কিছুটা আলাদা পদ্ধতিতে করা হয়। Functional components এ সরাসরি function declare করা হয়, যেখানে class components এ event handlers typically class methods এর মাধ্যমে handle করা হয়।

#### Event Handling in Functional Components:

```jsx
function Greeting() {
  const handleClick = () => {
    console.log("Hello!");
  };

  return <button onClick={handleClick}>Greet</button>;
}
```

#### Event Handling in Class Components:

```jsx
class Greeting extends React.Component {
  handleClick = () => {
    console.log("Hello!");
  };

  render() {
    return <button onClick={this.handleClick}>Greet</button>;
  }
}
```

#### Key Differences:

- **Functional Components**: সরাসরি function declaration এর মাধ্যমে events handle করা হয়।
- **Class Components**: **this** keyword ব্যবহার করে class methods এর মাধ্যমে events handle করা হয়।

---

### 5. Passing Arguments to Event Handlers

React এ event handlers এ arguments pass করা সম্ভব। React এর events automatically **event object** কে প্রথম argument হিসেবে pass করে, তবে আপনি custom arguments pass করতে চাইলে inline function বা arrow function ব্যবহার করতে পারেন।

##### Example of Passing Arguments:

```jsx
function ButtonClick() {
  const handleClick = (message) => {
    alert(message);
  };

  return (
    <button onClick={() => handleClick("Button was clicked!")}>Click Me</button>
  );
}
```

#### Explanation:

- **Arrow Function**: Inline arrow function ব্যবহার করে custom message pass করা হয়েছে।

---

### 6. Common React Event Types

React এ বিভিন্ন ধরনের events আছে, যেগুলো UI এর বিভিন্ন element এর সাথে ব্যবহার করা যায়। নিচে কিছু common event types এর উদাহরণ দেয়া হলো:

#### Click Events

Click event হল এমন একটি event যা button, link, বা যেকোনো clickable element এ ঘটে।

##### Example:

```jsx
<button onClick={() => alert("Button clicked!")}>Click Me</button>
```

#### Form Events

Form elements এর জন্য যেমন **input**, **select**, **textarea** — এগুলোতে **onChange**, **onSubmit** events ব্যবহার করা হয়।

##### Example:

```jsx
function Form() {
  const handleChange = (event) => {
    console.log(event.target.value);
  };

  return <input type="text" onChange={handleChange} placeholder="Type here" />;
}
```

#### Keyboard Events

Keyboard events ব্যবহার করে keyboard interaction handle করা যায়, যেমন key press করা।

##### Example:

```jsx
function KeyPress() {
  const handleKeyPress = (event) => {
    console.log(`Key pressed: ${event.key}`);
  };

  return <input type="text" onKeyPress={handleKeyPress} />;
}
```

---

### 7. Real-life Example: Form Handling with Events

ধরা যাক, আপনি একটি simple form তৈরি করতে চান যেখানে user এর নাম এবং email input field থাকবে এবং submit button এর মাধ্যমে form data handle করা হবে।

##### Example:

```jsx
import React, { useState } from "react";

function SimpleForm() {
  const [formData, setFormData] = useState({ name: "", email: "" });

  const handleChange = (event) => {
    const { name, value } = event.target;
    setFormData((prevData) => ({
      ...prevData,
      [name]: value,
    }));
  };

  const handleSubmit = (event) => {
    event.preventDefault();
    console.log("Form Submitted: ", formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Name:</label>
        <input
          type="text"
          name="name"
          value={formData.name}
          onChange={handleChange}
        />
      </div>
      <div>
        <label>Email:</label>
        <input
          type="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
        />
      </div>
      <button type="submit">Submit</button>
    </form>
  );
}

export default SimpleForm;
```

#### Explanation:

1. **useState Hook**: **useState** hook ব্যবহার করে form এর **name** এবং **email** state management করা হচ্ছে।
2. **handleChange function**: Input field এ কোন পরিবর্তন আসলে সেই data **handleChange** function এর মাধ্যমে state এ store হচ্ছে।
3. **handleSubmit function**: Form submit করার সময় **handleSubmit** function prevent করে browser এর default behavior এবং data console এ দেখানো হচ্ছে।

---

### 8. Conclusion

React এর ইভেন্ট সিস্টেম developer দের dynamic এবং interactive user interfaces তৈরি করতে সাহায্য করে। React এর **synthetic events** ব্রাউজারের বিভিন্ন incompatibility সমস্যা থেকে মুক্তি দেয় এবং একটি unified event handling system প্রদান করে। ইভেন্টগুলোর মাধ্যমে ব্যবহারকারীর actions যেমন **button click**, **keyboard input**, **form submission** ইত্যাদি handle করা হয়।

React এর **functional components** এবং **class components** উভয় ক্ষেত্রেই ইভেন্ট সহজে handle করা যায়। **Props** এর মাধ্যমে ফাংশনগুলো dynamic ভাবে ব্যবহার করা হয় এবং **state management** এর মাধ্যমে UI তে পরিবর্তন আনা হয়।

React এ ইভেন্ট handling এর সুবিধা হলো:

- ইভেন্টগুলো **camelCase** ফর্মেটে লেখা হয় এবং inline function বা reference ফাংশনের মাধ্যমে সহজেই ব্যবহার করা যায়।
- Cross-browser compatibility নিশ্চিত হয় এবং performance উন্নত হয়।

React ইভেন্টগুলো সম্পর্কে ভালো ধারণা থাকলে, interactive এবং responsive web applications তৈরি করা অনেক সহজ হয়ে যায়।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-11: React Conditional Rendering

### Table of Contents:

1. [What is Conditional Rendering?](#what-is-conditional-rendering)
2. [Importance of Conditional Rendering](#importance-of-conditional-rendering)
3. [Different Ways to Implement Conditional Rendering](#different-ways-to-implement-conditional-rendering)
   - [Using if/else Statements](#using-ifelse-statements)
   - [Using Ternary Operators](#using-ternary-operators)
   - [Using Logical && Operator](#using-logical--operator)
   - [Using Switch Statements](#using-switch-statements)
4. [Real-life Example of Conditional Rendering](#real-life-example-of-conditional-rendering)
5. [Best Practices for Conditional Rendering](#best-practices-for-conditional-rendering)
6. [Conclusion](#conclusion)

---

### 1. What is Conditional Rendering?

React এ **Conditional Rendering** মানে হলো component গুলো নির্দিষ্ট শর্তের (conditions) ভিত্তিতে UI তে render হয়। অর্থাৎ, শর্ত অনুযায়ী একটি component UI তে প্রদর্শিত হবে, না হলে অন্য কিছু দেখানো হবে। উদাহরণস্বরূপ, user login করা থাকলে তার profile দেখা যাবে, আর না থাকলে login form দেখানো হবে।

---

### 2. Importance of Conditional Rendering

React এ **Conditional Rendering** এর গুরুত্ব অনেক। এটি আমাদের dynamic এবং responsive UI তৈরি করতে সাহায্য করে। Web application এ user এর interaction, data এবং state এর উপর ভিত্তি করে UI বিভিন্ন ভাবে পরিবর্তন করা প্রয়োজন হয়। এই dynamic পরিবর্তনগুলি Conditional Rendering এর মাধ্যমে সহজেই সম্ভব।

উদাহরণস্বরূপ, একটি e-commerce site এ user logged in থাকলে তার order history দেখানো হয়, আর logged in না থাকলে তাকে login করতে বলা হয়। এছাড়াও, যদি কোনো API call থেকে data fetch করতে সময় লাগে, তখন loader দেখানো হয় এবং data পাওয়ার পর result দেখানো হয়।

---

### 3. Different Ways to Implement Conditional Rendering

#### Using if/else Statements

Traditional **if/else** statement ব্যবহার করে React এ সহজেই conditional rendering করা যায়। তবে এই statements JSX এর মধ্যে ব্যবহার করা সম্ভব নয়, তাই function এর ভেতরে রাখতে হয়।

##### Example:

```jsx
function Greeting(props) {
  if (props.isLoggedIn) {
    return <h1>Welcome back!</h1>;
  } else {
    return <h1>Please sign up.</h1>;
  }
}

ReactDOM.render(
  <Greeting isLoggedIn={true} />,
  document.getElementById("root")
);
```

#### Breakdown:

- **if/else Statement**: এখানে **props.isLoggedIn** এর মান চেক করা হচ্ছে। যদি true হয়, তাহলে "Welcome back!" দেখানো হচ্ছে। না হলে "Please sign up."।
- Output:
  - যদি **isLoggedIn** true হয়: **"Welcome back!"**
  - যদি **isLoggedIn** false হয়: **"Please sign up."**

#### Using Ternary Operators

**Ternary operator** React এ conditional rendering এর জন্য সবচেয়ে সংক্ষিপ্ত উপায়। এটি একই কোড আরও ছোট করে লিখতে সাহায্য করে।

##### Example:

```jsx
function Greeting(props) {
  return (
    <div>
      {props.isLoggedIn ? <h1>Welcome back!</h1> : <h1>Please sign up.</h1>}
    </div>
  );
}

ReactDOM.render(
  <Greeting isLoggedIn={false} />,
  document.getElementById("root")
);
```

#### Breakdown:

- **Ternary Operator**: এক লাইনে condition check করে "Welcome back!" বা "Please sign up." দেখানো হচ্ছে।
- Output:
  - যদি **isLoggedIn** true হয়: **"Welcome back!"**
  - যদি **isLoggedIn** false হয়: **"Please sign up."**

#### Using Logical && Operator

**Logical && operator** React এ এমন শর্ত ব্যবহারের জন্য উপযুক্ত যেখানে কোনো শর্ত true হলে শুধুমাত্র একটি অংশ render হবে।

##### Example:

```jsx
function Greeting(props) {
  return <div>{props.isLoggedIn && <h1>Welcome back!</h1>}</div>;
}

ReactDOM.render(
  <Greeting isLoggedIn={true} />,
  document.getElementById("root")
);
```

#### Breakdown:

- **Logical && operator**: এখানে **props.isLoggedIn** true হলে "Welcome back!" দেখানো হচ্ছে। যদি false হয়, কিছুই render হবে না।
- Output:
  - যদি **isLoggedIn** true হয়: **"Welcome back!"**
  - যদি **isLoggedIn** false হয়: **(কিছুই দেখাবে না)**

#### Using Switch Statements

যখন একাধিক শর্ত থাকে, তখন **switch statement** ব্যবহার করা হয়। এটি বড় বড় conditions সহজে handle করতে সাহায্য করে।

##### Example:

```jsx
function Greeting(props) {
  switch (props.status) {
    case "guest":
      return <h1>Welcome, Guest!</h1>;
    case "user":
      return <h1>Welcome back!</h1>;
    case "admin":
      return <h1>Welcome, Admin!</h1>;
    default:
      return <h1>Hello!</h1>;
  }
}

ReactDOM.render(<Greeting status="admin" />, document.getElementById("root"));
```

#### Breakdown:

- **Switch Statement**: এখানে **props.status** চেক করে বিভিন্ন greeting message দেখানো হচ্ছে। যেমন, guest এর জন্য "Welcome, Guest!" এবং admin এর জন্য "Welcome, Admin!"।
- Output:
  - **status** "admin" হলে: **"Welcome, Admin!"**
  - **status** "guest" হলে: **"Welcome, Guest!"**
  - অন্য কোনো status থাকলে: **"Hello!"**

---

### 4. Real-life Example of Conditional Rendering

একটি বাস্তব উদাহরণে ধরুন, একটি **E-commerce Dashboard** রয়েছে, যেখানে user logged in থাকলে তার নাম এবং recent order গুলো দেখানো হবে, আর logged in না থাকলে তাকে login করতে বলবে।

##### Example:

```jsx
function UserDashboard(props) {
  if (props.isLoggedIn) {
    return (
      <div>
        <h1>Welcome back, {props.userName}!</h1>
        <p>Here are your recent orders:</p>
        {/* Order details */}
      </div>
    );
  } else {
    return (
      <div>
        <h1>Please log in to view your dashboard.</h1>
        <button onClick={props.onLogin}>Login</button>
      </div>
    );
  }
}

ReactDOM.render(
  <UserDashboard
    isLoggedIn={false}
    userName="John"
    onLogin={() => alert("Logging in...")}
  />,
  document.getElementById("root")
);
```

#### Breakdown:

- **isLoggedIn চেক করা হচ্ছে**: যদি user logged in থাকে, তার নাম এবং order details দেখানো হবে। আর না থাকলে login button দেখানো হবে।
- **Output**:
  - যদি **isLoggedIn = true** হয়, তাহলে দেখাবে:
    ```
    Welcome back, John!
    Here are your recent orders.
    ```
  - যদি **isLoggedIn = false** হয়, তাহলে দেখাবে:
    ```
    Please log in to view your dashboard.
    [Login Button]
    ```

---

### 5. Best Practices for Conditional Rendering

1. **Simple Logic ব্যবহার করুন**: Complex conditional rendering এর জন্য কোডকে যতটা সম্ভব সহজ রাখা উচিত। ছোট শর্তগুলির জন্য **ternary operator** এবং **&& operator** ব্যবহার করতে পারেন। উদাহরণস্বরূপ, একটি খুব ছোট condition এর জন্য একাধিক **if/else** না করে **ternary operator** ব্যবহার করতে পারেন।
2. **Nested JSX এড়িয়ে চলুন**: Nested JSX অনেক ক্ষেত্রে পড়তে এবং বোঝাতে জটিল হয়ে যায়। এর চেয়ে ভালো উপায় হলো subcomponents তৈরি করা।

3. **Switch Statement ব্যবহার করুন**: যখন একাধিক শর্ত রয়েছে, তখন **switch statement** ব্যবহার করলে কোড সহজ এবং পরিষ্কার হয়।

---

### 6. Conclusion

React এর **Conditional Rendering** একটি শক্তিশালী ফিচার, যা UI কে dynamic এবং responsive করতে সাহায্য করে। এই পদ্ধতিতে আপনি user এর state বা props এর উপর ভিত্তি করে UI এর বিভিন্ন অংশকে পরিবর্তন করতে পারেন। React এ conditional rendering এর বিভিন্ন পদ্ধতি রয়েছে, যেমন **if/else**, **ternary operators**, **&& operator**, এবং **switch statement**। প্রতিটি পদ্ধতি situation অনুযায়ী উপযোগী, তবে সবসময় কোডকে সহজ এবং পরিষ্কার রাখার চেষ্টা করা উচিত।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-12: React Composition vs Inheritance

### Table of Contents

1. [📜 Introduction to Composition and Inheritance](#introduction-to-composition-and-inheritance)
2. [📦 React Composition](#react-composition)
3. [🧬 React Inheritance](#react-inheritance)
4. [🤔 Why React Prefers Composition Over Inheritance](#why-react-prefers-composition-over-inheritance)
5. [🔍 Examples of Composition](#examples-of-composition)
6. [✅ Best Practices with Composition in React](#best-practices-with-composition-in-react)

---

### 1. 📜 Introduction to Composition and Inheritance

React একটি component-based framework যেখানে **UI** গুলো ছোট ছোট component এ ভাগ করা হয়। এই component গুলো আবার nested, reusable এবং encapsulated হয়। Component reuse করতে এবং নতুন component তৈরি করতে আমরা দুইটি প্রধান পদ্ধতি ব্যবহার করতে পারি:

1. **Composition**
2. **Inheritance**

React মূলত **Composition** কে প্রাধান্য দেয়, কারণ এটি component গুলোকে আরও modular এবং flexible ভাবে ব্যবহার করতে সহায়তা করে। React এর official documentation এ বলা হয়েছে, **Composition** হলো component reuse এর সবচেয়ে উপযোগী এবং নিরাপদ পদ্ধতি, যেখানে **Inheritance** প্রায়শই বিভ্রান্তিকর হতে পারে।

### 2. 📦 React Composition

**Composition** বলতে বোঝানো হয় যে, একটি component এর মধ্যে অন্য component গুলোকে nested আকারে রাখা হয় এবং সেই component গুলোর কাজ parent component থেকে পরিচালনা করা হয়। Composition এর মাধ্যমে component গুলোতে বিভিন্ন UI structure তৈরি করা যায় এবং code reuse করা সহজ হয়।

React এ Composition এর জন্য props বা children ব্যবহার করা হয়। এটি মূলত component গুলোর মধ্যে সম্পর্ক স্থাপন করে এবং parent component কে child component এর উপর নিয়ন্ত্রণের ক্ষমতা দেয়।

#### Example of Composition

1. **Simple Composition Example with Props**:

```javascript
function WelcomeMessage({ name }) {
  return <p>Welcome, {name}!</p>;
}

function App() {
  return (
    <div>
      <WelcomeMessage name="Alice" />
      <WelcomeMessage name="Bob" />
    </div>
  );
}
```

**Explanation**:

- `WelcomeMessage` component `App` component এর মধ্যে রাখা হয়েছে এবং props হিসেবে `name` পাস করা হয়েছে।
- এখানে `WelcomeMessage` component কে বিভিন্ন props সহ একাধিক বার ব্যবহার করা হচ্ছে, যা code reuse সহজ করছে।
- **Output**:
  - "Welcome, Alice!"
  - "Welcome, Bob!"

2. **Composition with Children**:

React এ **children** props ব্যবহার করে একটি component এর মধ্যে অন্য component কে pass করা যায়। এটি বিশেষ করে wrapper component তৈরি করতে কাজে আসে।

```javascript
function Card({ children }) {
  return <div className="card">{children}</div>;
}

function App() {
  return (
    <div>
      <Card>
        <h2>Title 1</h2>
        <p>This is the content of the first card.</p>
      </Card>
      <Card>
        <h2>Title 2</h2>
        <p>This is the content of the second card.</p>
      </Card>
    </div>
  );
}
```

**Explanation**:

- `Card` component একটি wrapper হিসেবে কাজ করছে, যেখানে `children` props এর মাধ্যমে যেকোনো content inject করা সম্ভব।
- এটি খুবই flexible, কারণ `Card` component এর মধ্যে আমরা যেকোনো ধরনের JSX element রাখতে পারি।
- **Output**:
  - Title 1 - This is the content of the first card.
  - Title 2 - This is the content of the second card.

### 3. 🧬 React Inheritance

**Inheritance** বলতে বোঝায়, একটি class এর বৈশিষ্ট্য আরেকটি class এর মধ্যে ব্যবহার করা। Object-Oriented Programming এ Inheritance খুব সাধারণ একটি ধারণা, যেখানে একটি class অন্য একটি class থেকে বৈশিষ্ট্য গ্রহণ করতে পারে।

React এ **Inheritance** ব্যবহার করে component তৈরি করা তুলনামূলক কম ব্যবহৃত হয়। কারণ, Inheritance component গুলোর মধ্যে সম্পর্ক এবং নিয়ন্ত্রণ জটিল করে তোলে। এর পরিবর্তে, React এ composition পদ্ধতিই বেশি কার্যকর।

React এর ক্ষেত্রে Inheritance কেবলমাত্র **React.Component** class extend করার জন্য ব্যবহৃত হয়। তবে component গুলোর মধ্যে parent-child সম্পর্ক তৈরি করতে composition বেশি প্রয়োগ করা হয়।

#### Why React Avoids Inheritance

React এ Inheritance কম ব্যবহৃত হওয়ার কারণ হলো:

1. **Responsive Coding Style**: Composition ব্যবহার করে আমরা ছোট ছোট component তৈরি করে তাদের nesting এর মাধ্যমে বড় component তৈরি করতে পারি।
2. **Increased Complexity**: Inheritance এ বিভিন্ন layer এর component এর উপর নির্ভরশীলতা বেড়ে যায়, যা debugging কে জটিল করে তোলে।
3. **Fixed Structure**: Composition এ component গুলো আরও modular এবং loosely-coupled হয়, যা inheritance এর মাধ্যমে সম্ভব নয়।

### 4. 🤔 Why React Prefers Composition Over Inheritance

1. **Component Reuse**: Composition ব্যবহার করলে component গুলোকে সহজে reuse করা যায়। Inheritance এর ক্ষেত্রে code reuse করতে হলে আরও বেশি layer তৈরি করতে হয়।
2. **Loose Coupling**: Composition component গুলোর মধ্যে একটি loose coupling তৈরি করে, যা component গুলোর মধ্যে সরাসরি কোনো নির্ভরশীলতা রাখে না।
3. **Easy Debugging**: Composition এর ক্ষেত্রে component গুলো independent থাকে এবং পৃথকভাবে কাজ করে, তাই debugging সহজ হয়।

### 5. 🔍 Examples of Composition

#### Example 1: Specialization through Composition

```javascript
function Button({ children, onClick }) {
  return <button onClick={onClick}>{children}</button>;
}

function DangerButton({ onClick }) {
  return (
    <Button onClick={onClick}>
      <span style={{ color: "red" }}>Delete</span>
    </Button>
  );
}

function App() {
  return (
    <div>
      <Button onClick={() => alert("Clicked!")}>Normal Button</Button>
      <DangerButton onClick={() => alert("Danger!")} />
    </div>
  );
}
```

**Explanation**:

- `Button` component সাধারণ button এর জন্য ব্যবহৃত, যা `children` এবং `onClick` props গ্রহণ করে।
- `DangerButton` component `Button` কে বিশেষায়িত করে একটি delete button তৈরি করেছে। এটি `Button` component এর সাথে `Delete` label এবং red color যুক্ত করে।
- **Output**:
  - প্রথম button এ ক্লিক করলে "Clicked!" এবং দ্বিতীয় button এ ক্লিক করলে "Danger!" alert message দেখায়।

#### Example 2: Containment through Composition

```javascript
function Container({ children }) {
  return <div className="container">{children}</div>;
}

function App() {
  return (
    <Container>
      <h1>Title</h1>
      <p>This is a paragraph inside the container.</p>
    </Container>
  );
}
```

**Explanation**:

- `Container` component একটি wrapper component হিসেবে কাজ করছে, যা `children` props এর মাধ্যমে nested content ধারণ করে।
- `App` component এ `Container` component এর মধ্যে `<h1>` এবং `<p>` tags ব্যবহার করা হয়েছে, যা `Container` component এর মধ্যে প্রদর্শিত হয়।
- **Output**:
  - Title
  - This is a paragraph inside the container.

### 6. ✅ Best Practices with Composition in React

1. **Create Flexible Components**: Component গুলো flexible রাখুন যেনো তাদের বিভিন্নভাবে ব্যবহার করা যায়।
2. **Use Children**: যেকোনো content inject করতে **children** props ব্যবহার করুন, এটি component গুলোর মধ্যে composition এর জন্য অত্যন্ত উপকারী।
3. **Use HOC (Higher Order Components)**: পুনরায় ব্যবহারযোগ্য component তৈরি করতে **Higher Order Components (HOC)** ব্যবহার করতে পারেন। এটি composition এর মাধ্যমে functionality wrap করে।
4. **Use Compound Components**: একটি complex component তৈরি করতে composition ব্যবহার করে nested component তৈরি করা যায়, যা বড় আকারের UI component তৈরি করতে সাহায্য করে।

---

Composition এবং Inheritance এর মধ্যে composition React এর জন্য সবচেয়ে কার্যকরী এবং প্রয়োজনীয় পদ্ধতি। এটি component গুলোকে nested এবং reusable ভাবে তৈরি করতে সাহায্য করে। Inheritance এর তুলনায় Composition ব্যবহার করে React এর UI component গুলো আরও modular, flexible এবং manageable রাখা যায়।

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-13: React Higher Order Components (HOC)

### Table of Contents

1. [🌟 What is a Higher Order Component (HOC)?](#what-is-a-higher-order-component-hoc)
2. [🧐 Why Use Higher Order Components?](#why-use-higher-order-components)
3. [⚙️ How HOCs Work](#how-hocs-work)
4. [🚀 Implementing HOCs in React](#implementing-hocs-in-react)
5. [🔍 Examples of Higher Order Components](#examples-of-higher-order-components)
6. [✅ Best Practices for HOCs](#best-practices-for-hocs)

---

### 1. 🌟 What is a Higher Order Component (HOC)?

A **Higher Order Component (HOC)** হলো React এ ব্যবহৃত একটি advanced technique যা একটি component কে অন্য একটি function এর মাধ্যমে wrap করে এবং নতুন একটি component return করে। এটি মূলত একটি **JavaScript function** যা একটি **React component** কে argument হিসেবে গ্রহণ করে এবং সেই component এর উপর ভিত্তি করে নতুন component return করে। HOC component গুলোকে reusable এবং dynamically configurable করে তোলে।

উদাহরণ হিসেবে ভাবুন, আমাদের একটি basic component আছে যেটা কিছু data render করে, কিন্তু আমরা সেই component এ একটি loading indicator যোগ করতে চাই। এ ক্ষেত্রে, একটি HOC তৈরি করে আমরা loading feature টি main component এ যুক্ত করতে পারি, যা component এর মূল structure কে পরিবর্তন না করেই সেই কাজটি করবে।

HOC এর কাজ হলো:

- Component কে enhance করা
- নতুন functionality যোগ করা
- Component কে reusable এবং flexible করে তোলা

**Example Structure**:

```javascript
const EnhancedComponent = higherOrderComponent(OriginalComponent);
```

এই কোডে, `higherOrderComponent` নামক একটি function আছে, যা `OriginalComponent` কে গ্রহণ করে এবং সেটির উপর কিছু নির্দিষ্ট কাজ করে নতুন `EnhancedComponent` তৈরি করে।

### 2. 🧐 Why Use Higher Order Components?

React এ HOC ব্যবহার করার কিছু গুরুত্বপূর্ণ কারণ রয়েছে, যা component এর পুনঃব্যবহারযোগ্যতা এবং modularity বাড়াতে সহায়তা করে।

#### a. **Code Reuse**

একই functionality বা logic যদি বিভিন্ন component এ প্রয়োজন হয়, তখন HOC ব্যবহার করে সেই logic কে reusable করা যায়। যেমন ধরুন, আমাদের প্রায় সব component এ একটি loading feature দরকার, তাহলে একটি HOC তৈরি করে সেই loading feature কে অন্যান্য component এ add করা সম্ভব।

#### b. **Separation of Concerns**

HOCs component থেকে নির্দিষ্ট কাজ আলাদা করে, যাকে **Separation of Concerns** বলা হয়। এতে মূল component এর logic কমplex না হয় এবং readability বাড়ে। ধরুন, authentication check করার জন্য একটি HOC ব্যবহার করা হয়েছে। এতে মূল component এর কোড সহজ থাকে এবং authentication logic আলাদা থাকে।

#### c. **Conditional Rendering**

কিছু নির্দিষ্ট পরিস্থিতিতে component এর behavior বা props পরিবর্তন করতে হলে HOC অত্যন্ত কার্যকরী। HOCs component এর মধ্যে বিশেষ feature conditionally যোগ করার জন্য আদর্শ।

#### d. **Enhancement without Modification**

HOC ব্যবহার করলে মূল component এর structure বা functionality পরিবর্তন না করেই নতুন feature যোগ করা যায়। এটি React এর **Pure Functions** এর ধারণার উপর ভিত্তি করে কাজ করে, যার ফলে মূল component এর উপর কোনো প্রভাব ফেলে না।

### 3. ⚙️ How HOCs Work

Higher Order Component একটি function এর মত কাজ করে, যেখানে একটি component কে argument হিসেবে নেওয়া হয় এবং এটি নতুন একটি component return করে। এটি props এবং state এর উপর নির্ভর করে মূল component কে enhance করে।

#### Example Code Structure

```javascript
function withExtraFunctionality(WrappedComponent) {
  return function EnhancedComponent(props) {
    // কিছু extra কাজ করা হচ্ছে
    return <WrappedComponent {...props} />;
  };
}
```

**Explanation**:

- `withExtraFunctionality` নামক function টির মধ্যে `WrappedComponent` component গ্রহণ করা হয়েছে।
- `EnhancedComponent` নামে নতুন একটি component return করা হয়েছে, যা মূল component কে enhance করে।
- `{...props}` ব্যবহার করে মূল component এর props retain করা হয়েছে, ফলে enhanced component সব props access করতে পারে।

### 4. 🚀 Implementing HOCs in React

React এ HOC তৈরি করার জন্য আমাদের একটি function তৈরি করতে হয়, যা একটি component কে গ্রহণ করে এবং একটি নতুন component return করে। HOC ব্যবহার করে আমরা code reusability এবং component behavior পরিবর্তন করতে পারি।

#### Implementing a Loading Indicator HOC

```javascript
import React from "react";

function withLoadingIndicator(WrappedComponent) {
  return function EnhancedComponent({ isLoading, ...props }) {
    if (isLoading) return <p>Loading...</p>;
    return <WrappedComponent {...props} />;
  };
}
```

**Explanation**:

1. **HOC Definition**: `withLoadingIndicator` নামক HOC তৈরি করা হয়েছে। এটি `WrappedComponent` কে গ্রহণ করে এবং নতুন component return করে।
2. **Conditional Rendering**: `isLoading` prop check করা হয়। `isLoading` true হলে "Loading..." মেসেজ দেখায়।
3. **Main Component Render**: `isLoading` false হলে মূল `WrappedComponent` render হয়।

এখন আমরা এই `withLoadingIndicator` HOC কে বিভিন্ন component এ ব্যবহার করতে পারি, এবং প্রয়োজন অনুযায়ী loading feature যুক্ত করতে পারি।

### 5. 🔍 Examples of Higher Order Components

#### Example 1: Loading Indicator with HOC

```javascript
import React from "react";

function withLoadingIndicator(WrappedComponent) {
  return function EnhancedComponent({ isLoading, ...props }) {
    if (isLoading) return <p>Loading...</p>;
    return <WrappedComponent {...props} />;
  };
}

function DataDisplay({ data }) {
  return <div>Data: {data}</div>;
}

const DataDisplayWithLoading = withLoadingIndicator(DataDisplay);

// Usage in App
function App() {
  return <DataDisplayWithLoading isLoading={true} data="Some Data" />;
}
```

**Detailed Explanation**:

1. **withLoadingIndicator HOC**: এখানে একটি HOC তৈরি করা হয়েছে যা `isLoading` prop গ্রহণ করে। যদি `isLoading` true হয়, তবে এটি একটি "Loading..." মেসেজ প্রদর্শন করে।
2. **DataDisplay Component**: এটি একটি সাধারণ component, যা `data` props থেকে একটি simple message render করে।
3. **Enhanced Component**: `DataDisplayWithLoading` নামে নতুন component তৈরি করা হয়েছে, যা `DataDisplay` কে `withLoadingIndicator` এর মাধ্যমে enhanced করেছে।
4. **Usage**: যখন `isLoading={true}` পাস করা হয়, তখন "Loading..." প্রদর্শিত হয়। আর `isLoading` false হলে `DataDisplay` component এর content প্রদর্শিত হয়।

#### Example 2: Authorization HOC

```javascript
import React from "react";

function withAuthorization(WrappedComponent) {
  return function EnhancedComponent({ isAuthenticated, ...props }) {
    if (!isAuthenticated)
      return <p>You are not authorized to view this content.</p>;
    return <WrappedComponent {...props} />;
  };
}

function SecretContent() {
  return <div>Secret Content: Only for authorized users!</div>;
}

const AuthorizedContent = withAuthorization(SecretContent);

// Usage in App
function App() {
  return <AuthorizedContent isAuthenticated={false} />;
}
```

**Detailed Explanation**:

1. **withAuthorization HOC**: এই HOC authentication check করার জন্য ব্যবহৃত হচ্ছে। এটি `isAuthenticated` prop গ্রহণ করে। যদি `isAuthenticated` false হয়, তবে "You are not authorized to view this content" মেসেজ দেখায়।
2. **SecretContent Component**: এটি একটি সাধারণ component, যা authorized users এর জন্য গোপনীয় content প্রদর্শন করে।
3. **Enhanced Component**: `AuthorizedContent` নামে একটি নতুন component তৈরি হয়েছে, যা `SecretContent` কে `withAuthorization` HOC এর মাধ্যমে enhance করেছে।
4. **Usage**: যখন `isAuthenticated={false}` পাস করা হয়, তখন user কে "You are not authorized..." মেসেজ দেখানো হয়। আর `isAuthenticated` true হলে মূল content দেখানো হয়।

### 6. ✅ Best Practices for HOCs

1. **Descriptive Naming**: HOC গুলোর নাম meaningful হওয়া উচিত যেন বুঝা যায় HOC টির কাজ কি, যেমন `withLoadingIndicator`, `withAuthorization` ইত্যাদি।
2. **Don’t Overuse HOCs**: HOC গুলো অতিরিক্ত ব্যবহার করা উচিত নয়। একই কাজ সম্ভব হলে composition বা custom hooks ব্যবহার করা যায়।
3. **Props Management**: HOC এ `props` pass করার সময় নিশ্চিত হোন যে wrapped component এর সব props ঠিকঠাকভাবে pass হচ্ছে। `{...props}` ব্যবহার করলে সব props wrapped component এ চলে যাবে।
4. **Static Method Copy**: HOCs ব্যবহার করার সময় static methods হারিয়ে যেতে পারে। `hoist-non-react-statics` library ব্যবহার করে static methods এবং properties সংরক্ষণ করা যায়।
5. **Avoid Side Effects**: HOCs pure function হওয়া উচিত, অর্থাৎ এর মধ্যে এমন কোনো কাজ করা উচিত নয় যা wrapped component এর বাইরের কোনো value বা state পরিবর্তন করে।

---

React এ **Higher Order Components (HOC)** একটি শক্তিশালী টুল যা component গুলোকে reusable এবং modular ভাবে তৈরি করতে সাহায্য করে। এটি component এর behavior পরিবর্তন না করেই বিভিন্ন feature যোগ করতে এবং logic আলাদা করতে সহায়ক। HOC এর সঠিক ব্যবহার application কে modular, flexible, এবং maintainable করে তোলে। 😄

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-14: React Render Props

### Table of Contents

- [Introduction to Render Props](#introduction-to-render-props)
- [The Purpose and Benefits of Render Props](#the-purpose-and-benefits-of-render-props)
- [Implementing Render Props in React](#implementing-render-props-in-react)
- [Real-life Examples](#real-life-examples)
- [Best Practices for Render Props](#best-practices-for-render-props)

---

### 📘 Introduction to Render Props

**Render Props** হলো একটি React pattern, যা component এর ভেতরে একটি function পাঠানোর অনুমতি দেয় যা component কিভাবে render হবে তা নির্ধারণ করে। Render Props concept এর মাধ্যমে আপনি component গুলোর মধ্যে **functionality** এবং **presentation** কে আলাদা করতে পারেন, যা code structure কে flexible এবং maintainable করে তোলে।

#### Basic Structure of Render Props

Render Props ব্যবহার করতে হলে parent component এ একটি function তৈরি করতে হয়, যা child component এ props হিসেবে pass করা হয়। এই function component কিভাবে render হবে তা নির্ধারণ করে।

```javascript
<MyComponent render={(data) => <div>{data}</div>} />
```

এখানে `MyComponent` একটি `render` props হিসেবে একটি function গ্রহণ করছে। এই function এর মাধ্যমে `data` render হবে। এই প্যাটার্নের মাধ্যমে আমরা বিভিন্ন UI structure তৈরি করতে পারি যা reusability এবং flexibility বাড়ায়।

---

### 🧐 The Purpose and Benefits of Render Props

React এ component গুলোর মধ্যে data, functionality, এবং behavior share করতে Render Props প্যাটার্ন অত্যন্ত গুরুত্বপূর্ণ। এটি code reusability এবং flexibility বাড়ায় এবং component গুলোর মধ্যে **logic** ও **presentation** কে আলাদা রাখে।

Render Props এর প্রধান সুবিধাগুলি হলো:

1. **Code Reusability**: একই logic বারবার implement করার পরিবর্তে render props ব্যবহার করে একটি reusable function তৈরি করা যায়।
2. **Flexible UI Control**: Render Props ব্যবহার করে component এর UI control খুবই সহজ হয়। Parent component এর data dynamically child component এ render করা যায়।
3. **Separation of Concerns**: Component এর core logic এবং UI কে পৃথকভাবে পরিচালনা করতে পারে, যা কোড structure পরিষ্কার রাখে এবং maintenance সহজ করে।

### ⚙️ Implementing Render Props in React

React এ Render Props implement করার জন্য, প্রথমে parent component এ একটি function তৈরি করতে হয় যা props হিসেবে data pass করে এবং child component এ dynamically render করে। নিচে Render Props এর একটি basic উদাহরণ দেখানো হলো:

#### Example of Basic Render Props

```javascript
class DataProvider extends React.Component {
  state = { data: "Hello, World!" };

  render() {
    return this.props.render(this.state.data);
  }
}

function App() {
  return <DataProvider render={(data) => <div>{data}</div>} />;
}
```

**Explanation**:

1. **DataProvider Component**: `DataProvider` নামক একটি component তৈরি করা হয়েছে, যার মধ্যে `data` state রয়েছে।
2. **Render Method**: এই component এর `render` method এ `this.props.render(this.state.data)` call করে data pass করা হয়েছে।
3. **Using Render Prop**: `App` component এ render props হিসেবে একটি function পাঠানো হয়েছে, যা `data` কে UI তে render করে।

এই structure এর মাধ্যমে component গুলোর মধ্যে logic এবং UI কে আলাদা রাখা যায়, যা reusability এবং flexibility বাড়ায়।

---

### 📖 Real-life Examples

নিচে Render Props এর দুটি বাস্তব উদাহরণ রয়েছে, যা এই প্যাটার্নটির ব্যবহারকে আরও স্পষ্ট করে তুলবে।

#### Example 1: Library Management System

ধরুন, আমাদের একটি library management system আছে যেখানে বিভিন্ন genre এর বই রয়েছে। আমরা চাই, প্রতিটি genre অনুযায়ী আলাদা layout এ বইগুলো display হবে।

```javascript
class Library extends React.Component {
  state = {
    books: [
      { title: "Book 1", genre: "Fiction" },
      { title: "Book 2", genre: "Science" },
      { title: "Book 3", genre: "History" },
    ],
  };

  render() {
    return (
      <div>
        <h1>Library</h1>
        {this.props.render(this.state.books)}
      </div>
    );
  }
}

function App() {
  return (
    <Library
      render={(books) => (
        <div>
          <h2>Available Books:</h2>
          <ul>
            {books.map((book, index) => (
              <li key={index}>
                {book.title} - {book.genre}
              </li>
            ))}
          </ul>
        </div>
      )}
    />
  );
}
```

**Explanation**:

1. **Library Component**: `Library` component এ `books` নামে একটি state রয়েছে, যা বিভিন্ন genre এর বই ধারণ করে।
2. **Render Prop for Custom Layout**: `App` component এ `Library` component কে render props হিসেবে একটি function pass করা হয়েছে, যা বইগুলোকে custom layout এ display করে।
3. **Output**: প্রতিটি genre এর বই list আকারে UI তে display হবে।

এই উদাহরণে, Render Props ব্যবহার করে `Library` component কে flexible রাখা হয়েছে, যা আলাদা আলাদা layout এ বই display করতে পারে।

---

#### Example 2: Online Store Product Filter

ধরুন, আমাদের একটি online store আছে যেখানে বিভিন্ন category এর product রয়েছে। আমরা চাই, প্রতিটি category অনুযায়ী products আলাদা layout এ display হবে। Render Props ব্যবহার করে এটি সহজেই implement করা যায়।

```javascript
class ProductFilter extends React.Component {
  state = {
    products: [
      { name: "Laptop", category: "Electronics" },
      { name: "Shirt", category: "Clothing" },
      { name: "Coffee Maker", category: "Appliances" },
    ],
  };

  render() {
    return (
      <div>
        <h1>Product List</h1>
        {this.props.render(this.state.products)}
      </div>
    );
  }
}

function App() {
  return (
    <ProductFilter
      render={(products) => (
        <div>
          <h2>Filtered Products:</h2>
          <ul>
            {products.map((product, index) => (
              <li key={index}>
                {product.name} - {product.category}
              </li>
            ))}
          </ul>
        </div>
      )}
    />
  );
}
```

**Explanation**:

1. **ProductFilter Component**: `ProductFilter` component এ `products` নামে একটি state রয়েছে, যা বিভিন্ন category এর products ধারণ করে।
2. **Render Prop for Dynamic Display**: `App` component এ render props হিসেবে custom function পাঠানো হয়েছে, যা products কে filtered list আকারে display করে।
3. **Output**: `products` array থেকে আলাদা আলাদা category এর products display করা হয়।

এই উদাহরণে, Render Props এর মাধ্যমে একই `ProductFilter` component ভিন্ন ভিন্ন category এর জন্য dynamically render হচ্ছে। এটি online store এর মতো সিস্টেমে পণ্য প্রদর্শনের জন্য খুবই কার্যকরী।

---

### ✅ Best Practices for Render Props

Render Props ব্যবহার করার সময় কিছু Best Practices অনুসরণ করলে code structure আরও পরিষ্কার এবং maintainable হয়।

1. **Use Descriptive Names**: Render props function এর নাম সংক্ষেপে এবং অর্থপূর্ণ হওয়া উচিত। যেমন, `renderContent`, `renderData` ইত্যাদি।
2. **Avoid Excessive Nesting**: Render Props structure nested হলে code জটিল হয়ে যায়, তাই nesting যতটা সম্ভব কম রাখা উচিত।
3. **Use Pure Functions**: Render props হিসেবে পাঠানো function কে pure function হিসেবে লেখা উচিত, যাতে এটি বাইরের state বা props পরিবর্তন না করে।
4. **Document and Comment Clearly**: Render Props এর প্রতিটি অংশের জন্য comments এবং documentation রাখা উচিত, যাতে এর কাজ বোঝা সহজ হয়।

---

React এ Render Props প্যাটার্ন component গুলোর মধ্যে logic এবং data share করতে একটি গুরুত্বপূর্ণ টুল। এটি component কে আরও modular, reusable এবং flexible করে তোলে। Proper implementation এবং best practices অনুসরণ করে Render Props ব্যবহার করলে React এ উন্নত মানের application তৈরি করা সম্ভব। 😊

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-15: React Context API

## Table of Contents

- [Introduction to Context API](#introduction-to-context-api)
- [Why Use Context API?](#why-use-context-api)
- [Core Concepts of Context API](#core-concepts-of-context-api)
- [Implementing Context API in React](#implementing-context-api-in-react)
- [Real-life Examples](#real-life-examples)
- [Best Practices for Context API](#best-practices-for-context-api)

---

### 📘 Introduction to Context API

React **Context API** হলো একটি powerful tool যা component গুলোর মধ্যে data pass এবং share করতে ব্যবহার করা হয়। সাধারণত, data parent থেকে child component এ props এর মাধ্যমে pass করা হয়। তবে, যদি component গুলোর মধ্যে nested structure অনেক বড় হয়, তখন প্রতিটি layer এ props pass করা cumbersome হয়ে ওঠে। **Context API** এই সমস্যা সমাধান করে data globally manage এবং access করার সুবিধা দিয়ে।

Context API ব্যবহার করে component tree তে data সরাসরি এক স্তর থেকে অন্য স্তরে pass করা যায়, যা data এর accessibility এবং component গুলোর মধ্যে interaction সহজ করে তোলে।

---

### 🧐 Why Use Context API?

Context API এর প্রধান কাজ হলো component গুলোর মধ্যে data share সহজ করা। এটি একটি central location তৈরি করে যেখানে data রাখা হয় এবং যেকোনো nested component সহজেই এই data access করতে পারে। নিচে Context API ব্যবহারের কারণগুলো উল্লেখ করা হলো:

1. **Avoids Prop Drilling**: অনেকগুলো nested component এর মধ্যে data pass করার জন্য প্রতি layer এ props ব্যবহার করার প্রয়োজন নেই।
2. **Centralized State Management**: একটি central state তৈরি করা যায়, যা application এর যেকোনো component এ access করা সম্ভব।
3. **Reusability and Flexibility**: একই context বিভিন্ন component এ সহজে ব্যবহৃত হতে পারে, যা reusability এবং flexibility বাড়ায়।

Context API সাধারণত এমন পরিস্থিতিতে ব্যবহার করা হয়, যখন কিছু data (যেমন theme, user information, authentication status) global ভাবে accessible থাকা প্রয়োজন।

---

### 🔍 Core Concepts of Context API

Context API এর মূলত তিনটি প্রধান অংশ রয়েছে:

1. **Context Creation**: প্রথম ধাপে context তৈরি করতে হয়, যা data store করার জন্য একটি container হিসেবে কাজ করে।

   ```javascript
   const ThemeContext = React.createContext(defaultValue);
   ```

   এখানে `ThemeContext` একটি context তৈরি করে, যা পরে data provide এবং consume করার জন্য ব্যবহার হবে।

2. **Provider Component**: Context provider component data বা state provide করে এবং এই data যেকোনো child component access করতে পারে।

   ```javascript
   <ThemeContext.Provider value={/* some data */}>
     {/* Child components */}
   </ThemeContext.Provider>
   ```

   Provider component এ `value` props এর মাধ্যমে data pass করা হয়, যা nested component গুলো access করতে পারে।

3. **Consumer Component**: Context consumer component ব্যবহার করে যে কোনো nested component context থেকে data consume করতে পারে।
   ```javascript
   <ThemeContext.Consumer>
     {value => /* render something based on the context value */}
   </ThemeContext.Consumer>
   ```
   Consumer component ব্যবহার করে context এর data dynamically render করা হয়।

এই তিনটি অংশ Context API এর মাধ্যমে data share এবং access এর কাজকে সহজ করে।

---

### ⚙️ Implementing Context API in React

React এ Context API implement করতে, প্রথমে context তৈরি করা হয়, তারপর provider component এর মাধ্যমে data provide করা হয় এবং consumer component এর মাধ্যমে context থেকে data access করা হয়। নিচে একটি basic উদাহরণ দেখানো হলো।

#### Example: Implementing Theme Context

```javascript
import React, { createContext, useState, useContext } from "react";

// Step 1: Create a Context
const ThemeContext = createContext();

// Step 2: Create a Provider Component
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState("light");

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

// Step 3: Create a Component that Consumes the Context
function ThemedButton() {
  const { theme, setTheme } = useContext(ThemeContext);

  return (
    <button
      onClick={() => setTheme(theme === "light" ? "dark" : "light")}
      style={{
        background: theme === "light" ? "#fff" : "#333",
        color: theme === "light" ? "#000" : "#fff",
      }}
    >
      Toggle Theme
    </button>
  );
}

// Step 4: Use the Provider in the App Component
function App() {
  return (
    <ThemeProvider>
      <ThemedButton />
    </ThemeProvider>
  );
}

export default App;
```

**Explanation**:

1. **Context Creation**: `ThemeContext` তৈরি করা হয়েছে, যা theme সংক্রান্ত data রাখবে।
2. **Provider Component**: `ThemeProvider` component `ThemeContext.Provider` এর মাধ্যমে data provide করছে। `theme` এবং `setTheme` value হিসাবে context এ pass করা হয়েছে।
3. **Consumer Component**: `ThemedButton` component `useContext` hook এর মাধ্যমে `ThemeContext` থেকে data access করছে এবং button এর theme dynamically update করছে।
4. **Using the Provider**: `App` component এ `ThemeProvider` ব্যবহার করে পুরো application এ `theme` context provide করা হয়েছে।

এই উদাহরণে, Context API ব্যবহার করে একটি global theme তৈরি করা হয়েছে, যা application এর যেকোনো component এ dynamically access করা সম্ভব।

---

### 📖 Real-life Examples

নিচে Context API এর দুটি বাস্তব উদাহরণ রয়েছে, যা এই প্যাটার্নটির কাজকে আরও ভালভাবে বোঝাবে।

#### Example 1: User Authentication Context

ধরুন, আমাদের একটি application আছে যেখানে user authentication status check করা প্রয়োজন। Context API ব্যবহার করে আমরা একটি central authentication context তৈরি করতে পারি, যা application এর বিভিন্ন component এ সহজেই access করা যাবে।

```javascript
import React, { createContext, useState, useContext } from "react";

// Create an Authentication Context
const AuthContext = createContext();

function AuthProvider({ children }) {
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  const login = () => setIsAuthenticated(true);
  const logout = () => setIsAuthenticated(false);

  return (
    <AuthContext.Provider value={{ isAuthenticated, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

// Component that Consumes the Auth Context
function UserStatus() {
  const { isAuthenticated, login, logout } = useContext(AuthContext);

  return (
    <div>
      {isAuthenticated ? (
        <>
          <p>User is logged in</p>
          <button onClick={logout}>Logout</button>
        </>
      ) : (
        <>
          <p>User is logged out</p>
          <button onClick={login}>Login</button>
        </>
      )}
    </div>
  );
}

function App() {
  return (
    <AuthProvider>
      <UserStatus />
    </AuthProvider>
  );
}

export default App;
```

**Explanation**:

1. **AuthContext Creation**: `AuthContext` তৈরি করা হয়েছে, যা user এর authentication status সংরক্ষণ করবে।
2. **Provider Component**: `AuthProvider` component এ `isAuthenticated`, `login`, এবং `logout` method value হিসেবে provide করা হয়েছে।
3. **Consumer Component**: `UserStatus` component `AuthContext` থেকে `isAuthenticated` status access করছে এবং user এর login বা logout status অনুযায়ী UI render করছে।
4. **Using the Provider**: `App` component এ `AuthProvider` ব্যবহার করা হয়েছে, যা পুরো application এ authentication context provide করছে।

এই উদাহরণে, Context API ব্যবহার করে একটি central authentication state তৈরি করা হয়েছে, যা application এর বিভিন্ন component এ ব্যবহার করা যায়।

---

#### Example 2: Language Context for Multilingual Application

একটি multilingual application এর জন্য language context তৈরি করা যায়, যেখানে user এর পছন্দ অনুযায়ী language change করা যায়।

```javascript
import React, { createContext, useState, useContext } from "react";

// Create a Language Context
const LanguageContext = createContext();

function LanguageProvider({ children }) {
  const [language, setLanguage] = useState("en");

  const switchLanguage = (lang) => setLanguage(lang);

  return (
    <LanguageContext.Provider value={{ language, switchLanguage }}>
      {children}
    </LanguageContext.Provider>
  );
}

// Component that Consumes the Language Context
function LanguageSwitcher() {
  const { language, switchLanguage } = useContext(LanguageContext);

  return (
    <div>
      <p>Current Language: {language}</p>
      <button onClick={() => switchLanguage("en")}>English</button>
      <button onClick={() => switchLanguage("es")}>Spanish</button>
    </div>
  );
}

function App() {
  return (
    <LanguageProvider>
      <LanguageSwitcher />
    </LanguageProvider>
  );
}

export default App;
```

**Explanation**:

1. **LanguageContext Creation**: `LanguageContext` তৈরি করা হয়েছে, যা user এর language preference সংরক্ষণ করবে।
2. **Provider Component**: `LanguageProvider` component এ `language` এবং `switchLanguage` function provide করা হয়েছে।
3. **Consumer Component**: `LanguageSwitcher` component এ `useContext` hook এর মাধ্যমে `LanguageContext` থেকে data access করা হচ্ছে এবং language switch এর জন্য UI প্রদান করা হচ্ছে।
4. **Using the Provider**: `App` component এ `LanguageProvider` ব্যবহার করা হয়েছে, যা পুরো application এ language context provide করছে।

এই উদাহরণে, Context API ব্যবহার করে একটি central language management system তৈরি করা হয়েছে, যা user এর ভাষার প

ছন্দ অনুযায়ী UI change করতে সাহায্য করে।

---

### ✅ Best Practices for Context API

Context API ব্যবহার করার সময় কিছু Best Practices অনুসরণ করলে code structure আরও পরিষ্কার এবং maintainable হয়।

1. **Avoid Overusing Context**: প্রতিটি data এর জন্য context ব্যবহার না করে গুরুত্বপূর্ণ এবং frequently accessed data এর জন্য context ব্যবহার করুন।
2. **Use Separate Contexts for Different Data**: বিভিন্ন ধরনের data এর জন্য আলাদা context ব্যবহার করুন যাতে code আরও modular থাকে।
3. **Minimize Re-renders**: Context value change করলে re-render হয়, তাই যে data প্রায়ই পরিবর্তিত হয় তা context এ না রাখা ভালো।
4. **Document Context Usage**: Context API ব্যবহার করার সময় context এর প্রতিটি অংশের জন্য উপযুক্ত comments এবং documentation প্রদান করুন।

---

React এ Context API প্যাটার্ন component গুলোর মধ্যে data share এবং accessibility সহজ করে তোলে। এটি component কে আরও modular, reusable এবং flexible করে তোলে। Proper implementation এবং best practices অনুসরণ করে Context API ব্যবহার করলে React এ উন্নত মানের application তৈরি করা সম্ভব। 😊

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-16: How to Use React Context API

## Table of Contents

- [Overview of Context API](#overview-of-context-api)
- [When to Use Context API](#when-to-use-context-api)
- [Steps to Implement Context API](#steps-to-implement-context-api)
  - [1. Creating a Context](#1-creating-a-context)
  - [2. Providing the Context](#2-providing-the-context)
  - [3. Consuming the Context](#3-consuming-the-context)
- [Example: Theme Context in a Simple Application](#example-theme-context-in-a-simple-application)
- [Best Practices](#best-practices)

---

### 📘 Overview of Context API

React **Context API** হলো এমন একটি প্যাটার্ন যা component গুলোর মধ্যে data share করার জন্য ব্যবহার করা হয়। সাধারণত, React এ data pass করার জন্য **props drilling** করতে হয়, যা খুবই জটিল হয়ে ওঠে যখন nested component structure বড় হয়। Context API ব্যবহার করে data সরাসরি parent থেকে deep-nested child component এ pass করা যায়, যা props drilling এর প্রয়োজনীয়তা দূর করে।

---

### 🧐 When to Use Context API

Context API সাধারণত এমন পরিস্থিতিতে ব্যবহার করা হয় যখন data বা state application এর একাধিক component এ প্রয়োজন হয়। Context API এর সাধারণ use cases:

1. **Authentication State**: Logged-in user এর তথ্য application এর বিভিন্ন স্থানে প্রয়োজন হলে।
2. **Theme Management**: Light এবং dark mode এর মত global theme switch করার জন্য।
3. **Language Preference**: Multilingual applications এ preferred language context হিসেবে সংরক্ষণ করতে।

Context API ব্যবহার করার আগে নিশ্চিত হোন যে data টি সত্যিই global level এ প্রয়োজন; অন্যথায়, শুধুমাত্র props ব্যবহার করা ভালো।

---

### 🔍 Steps to Implement Context API

React এ Context API implement করতে প্রধানত তিনটি ধাপ অনুসরণ করতে হয়।

---

#### 1. Creating a Context

প্রথমে একটি context তৈরি করতে হয়। Context তৈরি করতে `React.createContext()` function ব্যবহার করা হয়।

```javascript
import React, { createContext } from "react";

// Creating a Theme Context
const ThemeContext = createContext();
```

**Explanation**:

- `ThemeContext` নামক একটি context তৈরি করা হয়েছে যা data সংরক্ষণ করতে সাহায্য করবে।
- এই context এর মাধ্যমে আমরা data globally provide এবং consume করতে পারব।

---

#### 2. Providing the Context

Context তৈরি করার পরে, এটি **Provider** component এর মাধ্যমে component tree তে provide করা হয়। Provider component এর মাধ্যমে context data সকল child component এ accessible হয়ে যায়।

```javascript
import React, { useState } from "react";

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState("light");

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export { ThemeProvider, ThemeContext };
```

**Explanation**:

- `ThemeProvider` component `ThemeContext.Provider` কে wrap করে এবং `value` prop এর মাধ্যমে data provide করে।
- `theme` এবং `setTheme` value হিসেবে `ThemeContext` এ pass করা হয়েছে, যা child component গুলো access করতে পারবে।
- এই provider component যেকোনো nested component এ context data access করতে সহায়ক।

---

#### 3. Consuming the Context

Context data consume করতে **Consumer component** বা **useContext hook** ব্যবহার করা হয়। Consumer component বা useContext hook ব্যবহার করে child component context থেকে data access করতে পারে।

```javascript
import React, { useContext } from "react";
import { ThemeContext } from "./ThemeProvider";

function ThemedButton() {
  const { theme, setTheme } = useContext(ThemeContext);

  return (
    <button
      onClick={() => setTheme(theme === "light" ? "dark" : "light")}
      style={{
        backgroundColor: theme === "light" ? "#fff" : "#333",
        color: theme === "light" ? "#000" : "#fff",
      }}
    >
      Toggle Theme
    </button>
  );
}

export default ThemedButton;
```

**Explanation**:

- `useContext(ThemeContext)` এর মাধ্যমে `theme` এবং `setTheme` access করা হয়েছে।
- Button এর style `theme` এর উপর নির্ভর করে change হচ্ছে এবং click event এ theme toggle হচ্ছে।

---

### 📖 Example: Theme Context in a Simple Application

একটি simple উদাহরণ দেখা যাক যেখানে আমরা Context API ব্যবহার করে একটি theme context তৈরি করব এবং তা button এর মাধ্যমে toggle করব।

```javascript
import React, { createContext, useState, useContext } from "react";

// Step 1: Create a Context
const ThemeContext = createContext();

// Step 2: Create a Provider Component
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState("light");

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

// Step 3: Create a Component that Consumes the Context
function ThemedButton() {
  const { theme, setTheme } = useContext(ThemeContext);

  return (
    <button
      onClick={() => setTheme(theme === "light" ? "dark" : "light")}
      style={{
        backgroundColor: theme === "light" ? "#fff" : "#333",
        color: theme === "light" ? "#000" : "#fff",
      }}
    >
      Toggle Theme
    </button>
  );
}

// Step 4: Use the Provider in the App Component
function App() {
  return (
    <ThemeProvider>
      <ThemedButton />
    </ThemeProvider>
  );
}

export default App;
```

**Explanation**:

1. **Creating the Context**: `ThemeContext` নামে একটি context তৈরি করা হয়েছে যা theme data store করবে।
2. **Providing the Context**: `ThemeProvider` component `ThemeContext.Provider` কে wrap করে এবং `theme` এবং `setTheme` value হিসেবে provide করছে।
3. **Consuming the Context**: `ThemedButton` component `useContext` hook ব্যবহার করে `ThemeContext` থেকে `theme` এবং `setTheme` access করছে এবং button এর মাধ্যমে theme toggle করছে।
4. **Using the Provider**: `App` component এ `ThemeProvider` ব্যবহার করে, পুরো application এ theme context provide করা হয়েছে।

**Output**:

- Button click করলে theme light থেকে dark এ এবং dark থেকে light এ toggle হবে।

---

### ✅ Best Practices for Context API

Context API ব্যবহারের সময় কিছু Best Practices অনুসরণ করলে code structure আরও পরিষ্কার এবং maintainable হয়।

1. **Limit Context Usage to Global Data**: প্রতিটি data এর জন্য context ব্যবহার না করে, শুধুমাত্র global data এর জন্য context ব্যবহার করুন।
2. **Use Multiple Contexts for Different Data**: বিভিন্ন ধরনের data এর জন্য আলাদা context ব্যবহার করুন, যাতে code আরও modular থাকে।
3. **Memoize Context Values**: Context value প্রায়ই পরিবর্তিত হলে re-renders কমানোর জন্য `useMemo` ব্যবহার করতে পারেন।
4. **Clear Documentation**: Context API এর প্রতিটি অংশের জন্য উপযুক্ত comments এবং documentation ব্যবহার করুন।

---

React এর Context API প্যাটার্নটি component গুলোর মধ্যে global data share করার জন্য একটি গুরুত্বপূর্ণ টুল। এটি component কে modular, reusable এবং flexible করে তোলে। Proper implementation এবং best practices অনুসরণ করে Context API ব্যবহার করলে React এ উন্নত মানের application তৈরি করা সম্ভব। 😊

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-17: React Context API: `contextType` & `useContext` Hook

## Table of Contents

- [Introduction to Context API](#introduction-to-context-api)
- [What is `contextType`](#what-is-contexttype)
- [How to Use `contextType`](#how-to-use-contexttype)
- [The `useContext` Hook Explained](#the-usecontext-hook-explained)
- [Comparing `contextType` and `useContext`](#comparing-contexttype-and-usecontext)
- [Real-life Examples](#real-life-examples)
- [Best Practices](#best-practices)

---

### 📘 Introduction to Context API

React **Context API** হলো এমন একটি tool যা component গুলোর মধ্যে data share করার জন্য ব্যবহৃত হয়। Context API props drilling এর পরিবর্তে একটি central location থেকে data access করতে সাহায্য করে, যা data management সহজ করে। Context API তে `Provider` এবং `Consumer` থাকে, যেগুলি combined করে global data sharing করা সম্ভব।

Context API এর সাথে দুটি গুরুত্বপূর্ণ concept রয়েছে: **`contextType`** এবং **`useContext` hook**। এগুলি context data consume করার জন্য দুটি ভিন্ন পদ্ধতি প্রদান করে।

---

### 🧐 What is `contextType`

`contextType` হলো একটি static property যা class components এ context data access করতে ব্যবহৃত হয়। যখন একটি class component এ context ব্যবহার করতে হয়, তখন `contextType` property এর মাধ্যমে context সরাসরি component এ access করা যায়। এটি শুধুমাত্র class component এর ক্ষেত্রে কার্যকর।

#### Syntax of `contextType`

```javascript
class MyComponent extends React.Component {
  static contextType = MyContext;

  render() {
    return <div>Context Value: {this.context}</div>;
  }
}
```

**Explanation**:

- `MyComponent` class এ `static contextType = MyContext` ব্যবহার করে `MyContext` context এ সংযুক্ত করা হয়েছে।
- `this.context` ব্যবহার করে context এর data access করা যায়।

---

### 🔍 How to Use `contextType`

`contextType` ব্যবহার করার জন্য, context কে `static contextType` property হিসেবে define করতে হয় এবং `this.context` এর মাধ্যমে data access করা হয়। এটি শুধুমাত্র একক context ব্যবহার করার জন্য উপযুক্ত এবং nested বা multiple contexts এর জন্য ideal নয়।

#### Example of `contextType`

```javascript
import React, { createContext, Component } from "react";

// Create a Context
const ThemeContext = createContext("light");

class ThemedComponent extends Component {
  static contextType = ThemeContext;

  render() {
    return (
      <div
        style={{
          backgroundColor: this.context === "light" ? "#fff" : "#333",
          color: this.context === "light" ? "#000" : "#fff",
        }}
      >
        Current Theme: {this.context}
      </div>
    );
  }
}

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <ThemedComponent />
    </ThemeContext.Provider>
  );
}

export default App;
```

**Explanation**:

1. **Creating the Context**: `ThemeContext` নামে একটি context তৈরি করা হয়েছে যা default value হিসেবে `"light"` গ্রহণ করে।
2. **Using `contextType` in Class Component**: `ThemedComponent` class এ `static contextType = ThemeContext` ব্যবহার করে context data access করা হয়েছে।
3. **Rendering Context Data**: `this.context` এর মাধ্যমে context এর current theme dynamically render করা হচ্ছে।
4. **Using the Provider**: `App` component এ `ThemeContext.Provider` ব্যবহার করে context value হিসেবে `"dark"` pass করা হয়েছে।

---

### ⚙️ The `useContext` Hook Explained

**`useContext` hook** হলো একটি React hook যা functional components এ context consume করতে ব্যবহৃত হয়। এটি সহজে context data access করতে সাহায্য করে এবং props drilling ছাড়াই context থেকে সরাসরি data retrieve করে।

#### Syntax of `useContext`

```javascript
const contextValue = useContext(MyContext);
```

**Explanation**:

- `useContext` hook এর মাধ্যমে `MyContext` এর data access করা যায়।
- `useContext` শুধুমাত্র functional components এ কাজ করে এবং context কে props হিসেবে সরাসরি pass করার প্রয়োজনীয়তা দূর করে।

#### Example of `useContext`

```javascript
import React, { createContext, useContext } from "react";

// Create a Context
const ThemeContext = createContext("light");

function ThemedButton() {
  const theme = useContext(ThemeContext);

  return (
    <button
      style={{
        backgroundColor: theme === "light" ? "#fff" : "#333",
        color: theme === "light" ? "#000" : "#fff",
      }}
    >
      Current Theme: {theme}
    </button>
  );
}

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <ThemedButton />
    </ThemeContext.Provider>
  );
}

export default App;
```

**Explanation**:

1. **Creating the Context**: `ThemeContext` context তৈরি করা হয়েছে যা default value `"light"` ধারণ করে।
2. **Using `useContext` Hook**: `ThemedButton` component এ `useContext(ThemeContext)` ব্যবহার করে theme value access করা হয়েছে।
3. **Rendering Theme Data**: button এর background এবং color `theme` value এর উপর ভিত্তি করে পরিবর্তিত হচ্ছে।
4. **Providing the Context**: `App` component এ `ThemeContext.Provider` ব্যবহার করে theme value `"dark"` set করা হয়েছে।

---

### 🔄 Comparing `contextType` and `useContext`

| Feature         | `contextType`                             | `useContext`                                 |
| --------------- | ----------------------------------------- | -------------------------------------------- |
| **Usage**       | Only works in class components            | Only works in functional components          |
| **Syntax**      | `static contextType = MyContext`          | `const value = useContext(MyContext)`        |
| **Limitations** | Limited to a single context per component | Supports multiple contexts easily            |
| **When to Use** | For older class-based codebases           | For modern, hook-based functional components |

---

### 📖 Real-life Examples

#### Example 1: Authentication Status with `useContext`

একটি application এ logged-in user এর authentication status handle করার জন্য context API এবং `useContext` ব্যবহার করা যায়।

```javascript
import React, { createContext, useContext, useState } from "react";

// Create Auth Context
const AuthContext = createContext();

function AuthProvider({ children }) {
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  const login = () => setIsAuthenticated(true);
  const logout = () => setIsAuthenticated(false);

  return (
    <AuthContext.Provider value={{ isAuthenticated, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

function UserStatus() {
  const { isAuthenticated, login, logout } = useContext(AuthContext);

  return (
    <div>
      {isAuthenticated ? (
        <>
          <p>Welcome back!</p>
          <button onClick={logout}>Logout</button>
        </>
      ) : (
        <>
          <p>Please log in.</p>
          <button onClick={login}>Login</button>
        </>
      )}
    </div>
  );
}

function App() {
  return (
    <AuthProvider>
      <UserStatus />
    </AuthProvider>
  );
}

export default App;
```

**Explanation**:

1. **Auth Context Creation**: `AuthContext` তৈরি করা হয়েছে যা authentication data store করে।
2. **Provider Component**: `AuthProvider` component এ `isAuthenticated`, `login`, এবং `logout` function provide করা হয়েছে।
3. **Consuming Context with `useContext`**: `UserStatus` component এ `useContext(AuthContext)` ব্যবহার করে authentication data access এবং update করা হয়েছে।

---

#### Example 2: Using `contextType` for User Preferences in Class Components

একটি class component এ user এর preferred language context handle করার জন্য `contextType` ব্যবহার করা যেতে পারে।

```javascript
import React, { createContext, Component } from "react";

// Create Language Context
const LanguageContext = createContext("en");

class LanguageDisplay extends Component {
  static contextType = LanguageContext;

  render() {
    return (
      <div>
        Preferred Language: {this.context === "en" ? "English" : "Spanish"}
      </div>
    );
  }
}

function App() {
  return (
    <LanguageContext.Provider value="es">
      <LanguageDisplay />
    </LanguageContext.Provider>
  );
}

export default App;
```

**Explanation**:

1. **Creating Language Context**: `LanguageContext` তৈরি করা হয়েছে এবং default value `"en"` প্রদান করা হয়েছে।
2. **Using `contextType` in Class Component**: `LanguageDisplay` class component এ `contextType` এর মাধ্যমে `LanguageContext` এ সংযুক্ত করা হয়েছে।
3. **Accessing Context with `this.context`**: `this.context` ব্যবহার করে preferred language dynamically display করা হচ্ছে।
4. **Providing Context**: `App` component এ `LanguageContext.Provider` ব্যবহার করে value `"es"` set করা হয়েছে।

---

### ✅ Best Practices for Using `contextType` and `useContext`

1. **Use `useContext` for Modern Functional Components**: Functional component এ `useContext` ব্যবহারের ফলে code সহজ এবং concise হয়।
2. **Use `contextType` in Legacy Class Components**: পুরোনো class component গুলোর জন্য `contextType` ব্যবহার করা উচিত।
3. **Limit Context Usage to Necessary Data**: শুধুমাত্র essential এবং frequently accessed data context এ রাখা উচিত।
4. **Clear Documentation**: Context API ব্যবহারের সময় `contextType`

এবং `useContext` এর প্রতিটি অংশের জন্য উপযুক্ত comments এবং documentation প্রদান করুন।

---

React এ **`contextType`** এবং **`useContext`** দুটি গুরুত্বপূর্ণ tool, যা Context API ব্যবহার করে component গুলোর মধ্যে data sharing সহজ করে। `useContext` functional component এর জন্য অত্যন্ত উপযোগী, যেখানে `contextType` class component এর জন্য উপযোগী। Proper usage এবং best practices অনুসরণ করে Context API এবং এর সাথে সংশ্লিষ্ট tools ব্যবহার করলে React এ আরও maintainable এবং scalable application তৈরি করা সম্ভব। 😊

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-18: React Hooks

## Table of Contents

- [Introduction to React Hooks](#introduction-to-react-hooks)
- [Why Use Hooks?](#why-use-hooks)
- [Essential React Hooks](#essential-react-hooks)
  - [1. `useState`](#1-usestate)
  - [2. `useEffect`](#2-useeffect)
  - [3. `useContext`](#3-usecontext)
- [Additional React Hooks](#additional-react-hooks)
  - [1. `useReducer`](#1-usereducer)
  - [2. `useRef`](#2-useref)
  - [3. `useMemo`](#3-usememo)
  - [4. `useCallback`](#4-usecallback)
- [Real-life Examples](#real-life-examples)
- [Best Practices](#best-practices)

---

### 📘 Introduction to React Hooks

**React Hooks** হলো React 16.8 এ পরিচিত একটি feature যা functional components এ state এবং lifecycle methods ব্যবহারের সুযোগ দেয়। সাধারণত class components এ state এবং lifecycle methods ব্যবহৃত হতো, তবে Hooks আসার পর functional components এও এই সুবিধা যুক্ত হয়েছে। এর ফলে code structure আরও সহজ ও পরিষ্কার হয়েছে।

React Hooks এর মাধ্যমে component গুলোকে reusable এবং modular করা সহজ হয়, কারণ Hooks একই logic বারবার ব্যবহারের সুযোগ দেয় এবং component এর মধ্যে এর behavior আলাদা রাখা সম্ভব করে।

---

### 🧐 Why Use Hooks?

Hooks React এর structure এবং code লেখা পদ্ধতিতে একটি বড় পরিবর্তন এনেছে। এটি ব্যবহার করার প্রধান কারণগুলো হলো:

1. **Functional Components Only**: Hooks এর মাধ্যমে শুধুমাত্র functional components ব্যবহার করে state এবং lifecycle logic handle করা যায়, যা class components এর প্রয়োজনীয়তা দূর করে।
2. **Reusable Logic**: Hooks একই logic কে reusable করে, যা component গুলোর মধ্যে common logic share করতে সহায়ক।
3. **Simplifies Code Structure**: Hooks component structure কে আরো সহজ এবং maintainable করে।
4. **Avoids Prop Drilling**: Context API এর সাথে `useContext` ব্যবহার করে nested components এর মধ্যে data সহজে pass করা যায়।

---

### 🔍 Essential React Hooks

#### 1. `useState`

**`useState`** হলো এমন একটি Hook যা component এ state তৈরি এবং পরিচালনা করতে ব্যবহৃত হয়। এটি একটি initial state গ্রহণ করে এবং সেই state এর current value এবং একটি function প্রদান করে যা state update করতে সাহায্য করে।

**Syntax**:

```javascript
const [state, setState] = useState(initialValue);
```

**Example**:

```javascript
import React, { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

**Explanation**:

- `count` একটি state variable যা `useState(0)` এর মাধ্যমে initialize হয়েছে।
- `setCount` function এর মাধ্যমে `count` update করা হয়, যা button এর click event এ call করা হয়।

---

#### 2. `useEffect`

**`useEffect`** হলো একটি Hook যা side effects handle করতে ব্যবহৃত হয়, যেমন data fetch করা, DOM update করা, বা timer set করা। এটি component এর rendering এর পর execute হয় এবং dependency array এর উপর ভিত্তি করে re-run হয়।

**Syntax**:

```javascript
useEffect(() => {
  // Side effect code
}, [dependencies]);
```

**Example**:

```javascript
import React, { useState, useEffect } from "react";

function DataFetcher() {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch("https://api.example.com/data")
      .then((response) => response.json())
      .then((result) => setData(result));
  }, []);

  return <div>{data ? JSON.stringify(data) : "Loading..."}</div>;
}
```

**Explanation**:

- Data fetch করার জন্য `useEffect` ব্যবহার করা হয়েছে, যা component render এর পর execute হয়।
- `[]` empty dependency array প্রদান করা হয়েছে, ফলে এই effect শুধুমাত্র একবার run হবে।

---

#### 3. `useContext`

**`useContext`** হলো এমন একটি Hook যা Context API এর মাধ্যমে global state বা data consume করতে সাহায্য করে। এটি props drilling এড়াতে এবং context থেকে সরাসরি data access করতে ব্যবহৃত হয়।

**Syntax**:

```javascript
const contextValue = useContext(MyContext);
```

**Example**:

```javascript
import React, { createContext, useContext } from "react";

const ThemeContext = createContext("light");

function ThemedComponent() {
  const theme = useContext(ThemeContext);

  return <div>Current Theme: {theme}</div>;
}

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <ThemedComponent />
    </ThemeContext.Provider>
  );
}
```

**Explanation**:

- `useContext` Hook ব্যবহার করে `ThemeContext` থেকে theme value সরাসরি access করা হয়েছে।
- `ThemeContext.Provider` এর মাধ্যমে `ThemedComponent` context এ provide করা value access করতে পারে।

---

### 🔄 Additional React Hooks

#### 1. `useReducer`

**`useReducer`** একটি complex state management Hook যা reducer function ব্যবহার করে state এবং dispatch function প্রদান করে। এটি `useState` এর মতোই কাজ করে, তবে complex logic handle করার জন্য এটি বেশি কার্যকর।

**Syntax**:

```javascript
const [state, dispatch] = useReducer(reducer, initialState);
```

**Example**:

```javascript
import React, { useReducer } from "react";

function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: "increment" })}>Increment</button>
      <button onClick={() => dispatch({ type: "decrement" })}>Decrement</button>
    </div>
  );
}
```

---

#### 2. `useRef`

**`useRef`** হলো এমন একটি Hook যা component এর মধ্যে mutable reference তৈরি করতে ব্যবহৃত হয়। এটি DOM element এর reference তৈরি করতে বা value persist করতে ব্যবহৃত হয়।

**Syntax**:

```javascript
const ref = useRef(initialValue);
```

**Example**:

```javascript
import React, { useRef } from "react";

function TextInputFocus() {
  const inputRef = useRef(null);

  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={() => inputRef.current.focus()}>Focus Input</button>
    </div>
  );
}
```

---

#### 3. `useMemo`

**`useMemo`** একটি Hook যা computationally expensive function এর result কে cache করতে সাহায্য করে, যাতে rerendering এর সময় computation বারবার না হয়।

**Syntax**:

```javascript
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

**Example**:

```javascript
import React, { useMemo, useState } from "react";

function ExpensiveCalculationComponent({ number }) {
  const calculatedValue = useMemo(() => {
    return expensiveCalculation(number);
  }, [number]);

  return <div>Calculated Value: {calculatedValue}</div>;
}
```

---

#### 4. `useCallback`

**`useCallback`** এমন একটি Hook যা function এর instance কে cache করে এবং dependency পরিবর্তন না হলে সেই instance পুনরায় ব্যবহার করে।

**Syntax**:

```javascript
const memoizedCallback = useCallback(() => {
  // Function code
}, [dependencies]);
```

---

### 📖 Real-life Examples

#### Example 1: User Authentication with `useContext` and `useState`

```javascript
import React, { createContext, useContext, useState } from "react";

const AuthContext = createContext();

function AuthProvider({ children }) {
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  const login = () => setIsAuthenticated(true);
  const logout = () => setIsAuthenticated(false);

  return (
    <AuthContext.Provider value={{ isAuthenticated, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

function UserStatus() {
  const { isAuthenticated, login, logout } = useContext(AuthContext);

  return (
    <div>
      {isAuthenticated ? (
        <>
          <p>Welcome, User!</p>
          <button onClick={logout}>Logout</button>
        </>
      ) : (
        <>
          <p>Please log in.</p>
          <button onClick={login}>Login</button>
        </>
      )}
    </div>
  );
}

function App() {
  return (
    <AuthProvider>
      <UserStatus />
    </AuthProvider>
  );
}

export default App;
```

#### Example 2: Theme Toggle with `useState` and `useContext`

```javascript
import React, { createContext, useState, useContext } from "react";

const ThemeContext = createContext();

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState("light");

  const toggleTheme = () => set;

  Theme(theme === "light" ? "dark" : "light");

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

function ThemedComponent() {
  const { theme, toggleTheme } = useContext(ThemeContext);

  return (
    <div
      style={{
        backgroundColor: theme === "light" ? "#fff" : "#333",
        color: theme === "light" ? "#000" : "#fff",
      }}
    >
      <p>Current Theme: {theme}</p>
      <button onClick={toggleTheme}>Toggle Theme</button>
    </div>
  );
}

function App() {
  return (
    <ThemeProvider>
      <ThemedComponent />
    </ThemeProvider>
  );
}

export default App;
```

---

### ✅ Best Practices for Using Hooks

1. **Use Hooks Only in Functional Components**: Hooks শুধুমাত্র functional components এ ব্যবহার করা উচিত।
2. **Follow Hook Rules**: Hooks এর মাধ্যমে nested structure এড়ানো উচিত এবং শুধুমাত্র top-level এ use করা উচিত।
3. **Optimize with `useMemo` and `useCallback`**: Expensive computations এবং unnecessary re-renders কমাতে `useMemo` এবং `useCallback` ব্যবহার করুন।
4. **Use Custom Hooks for Reusable Logic**: Custom Hooks তৈরি করে reusable logic encapsulate করা উচিত।

React Hooks component structure আরও modular, reusable, এবং maintainable করতে সাহায্য করে। Proper usage এবং best practices অনুসরণ করে Hooks ব্যবহারে React application এ আরও উন্নত performance এবং code clarity অর্জন করা যায়। 😊

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-19:

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-20:

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Chapter-21:

<div align="right">
    <b><a href="#learn-reactjs-in-30-chapters">↥ Go to Top</a></b>
</div>

# Project-01:

### Difficulty: Easy (2/10)

### You Will Learn

-

### Project Description

### Project Screenshot

### Live Project Link

[Open in CodePen]()

### Video Explanation

Coming Soon...

### Project Source Codes

[Source Codes]()
